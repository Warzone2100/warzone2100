//------------------------------------------------------
//	Public variables
//------------------------------------------------------
public	STRUCTURESTAT		legoSt[12],derrick,powGen,factory,resLab,powModule,facModule,resModule,vtolFactory,wall,
				repairFacility,extraStructs[3],defenses[18],structChoice[5],baseStructs[13],vtolPad,vtolDefStruct[2],sens[3],arty[5],attackStructs[5],cybFactory;
public	FEATURESTAT		oilRes;
public	INT			numLego,player,numTemplates,numExtraStructs,numDefenses,numBaseStructs,numSVtolTemplates,numTVtolTemplates,sPref[6],numVtolDefStr,numAttackStructs;
public	TEMPLATE		tmpl[2][12],constructor,sVtols[2][1],tVtols[2][3],tmplRep[2],cybMechanic,cybTmpl[10],Transport;
public	WEAPON			sVtolWeapon[3],tVtolWeapon[3];
public	TEXTSTRING		ai_ally_msg[5],DebugMsg[15];
public	PROPULSION		cyborgProp,vtolProp;	

//------------------------------------------------------
//	Private variables
//------------------------------------------------------
private GROUP			buildGroup,tempGroup,sendOutpostGr,sendAttackGr,collectSendGr,attackGroup,scoutGroup[3],oilGr,sVtolGr,tVtolGr,defendGr,repGr,repairedGroup,transportGr,dropGr;
private INT			count,count2,result,result2,result3,result4,temp,buildX,buildY,baseX,baseY,tempX,tempY,maxy,maxx,miny,minx,outpostDist;
private INT			minAttackH,maxAttackH,maxOilGr,scoutX[2],scoutY[2],stuckX,stuckY,stuckTimes,maxTVtols,maxSVtols,maxDefenders;
private	INT			oilX,oilY;
private DROID			droid,tempDroid,outpostDroid,repDefendDroid[2],toRepDefendDroid[2],transportDroid,transportDroid2;
private	INT			numRetreats,NumOldDefenders,helpAllyPlayer,helpAllyPlayerX,helpAllyPlayerY;
private BOOL			boolResult,boolResult2,haveOutpost,powerSaving,defendingBase;
private FEATURE			feature,feature2;
private TEMPLATE		tmplChoice[5];
private STRUCTURE		structure,structure2;	//attackDerrick;

private BOOL			actPlayer[8],allyPlayer[8],debugMode,dropEnabled,alreadyAttacked,bigMap;
private BASEOBJ			baseobj,attackObject,defendObject,tVtolObject,sVtolObject;

private INT			numEnemies,Enemies[8],EnemyX[8],EnemyY[8],LZ_X,LZ_Y,transportZ,cybTemplate;

//------------------------------------------------------
//	Static private variables
//------------------------------------------------------
private INT			mainPhase,curLegoStr,TemplDepth,maxTrucks,curEnemy,curEnemyX,curEnemyY,dropPhase,
				attackPhase,maxScouts,extraStruct,curEnEdgeX,curEnEdgeY,KeepDist,numRushers,maxRepairing,maxRetreats,muchoPower;

//===============================================================================================
//
//						Triggers
//
//===============================================================================================

//------------------------------------------------------
//	Lego
//------------------------------------------------------
trigger StartGameTr			(wait, 5);
trigger LegoBuildTr			(every, 10);

//------------------------------------------------------
//	Rush
//------------------------------------------------------
trigger RushTr				(every, 30);
trigger RushControlTr			(every, 90);	//Was 80

//------------------------------------------------------
//	Rush preparations
//------------------------------------------------------
trigger BuildAttackForceTr		(every, 20);
trigger	buildCyborgsTr			(every, 50);
trigger buildVtolsTr			(every, 60);
trigger doResearchTr			(every, 50);
trigger buildDerricksTr			(every, 80);	//was 60
trigger sendScoutsTr			(every, 30);
trigger expandBaseTr			(every, 60);	//was 150
trigger buildDefensesTr			(every, 210);
trigger buildVtolPadsTr			(every, 80);
trigger basedetailsTr			(every, 50);
trigger oilDefensesTr			(every, 100);

//------------------------------------------------------
//	Other
//------------------------------------------------------
trigger droidDestroyedTr		(CALL_DROID_DESTROYED,  player, ref droid);
trigger nowTr				(wait, 0);
trigger keepTrackTr			(every, 60);
trigger chooseEnemyTr			(every, 70);
trigger LegoTrucksTr			(every, 10);
trigger buildPowerGeneratorsTr		(every, 60);
trigger droidBuiltTr			(CALL_NEWDROID,player, ref droid,ref structure);
trigger difficultyModTr			(every, 600);
trigger upgradeStructuresTr		(every, 50);
trigger moveIfAttackedTr		(CALL_DROID_ATTACKED, player, ref droid, ref baseobj);
trigger BuildOutpostTr			(every, 100);
trigger updateDetailsTr			(every, 40);
trigger savePowerTr			(every, 20);
trigger destroyOilTr			(every, 60);
trigger stuckTr				(every, 80);
trigger vtolAttackTr			(every, 50);
trigger vtolDefendTr			(CALL_STRUCT_ATTACKED, player, ref structure, ref baseobj);
trigger formAllianceEventTr		(every, 120);
trigger humanAllianceTr			(CALL_ALLIANCEOFFER,ref count, ref count2);
trigger	FinishStructuresTr		(every, 120);
trigger	repairStuffTr			(every, 130);
trigger	cyborgDropTr			(every, 20);
trigger	manageDropAttacksTr		(every, 40);
trigger WatchDefendBaseTr		(every, 160);	//was 200
trigger WatchHelpAllyTr			(every, 200);
trigger agressiveDefenceTr		(every, 90);
trigger additVTOLDefensesTr		(every, 180);

//===============================================================================================
//
//					Events
//
//===============================================================================================
event endPhaseOne;
event initializeRushPrep;
event BuildAttackForce;
event doResearch;
event buildDerricks;
event chooseEnemy;
event RushControl;
event sendScouts;
event expandBase;
event buildDefenses;
event basedetails;
event oilDefenses;
event LegoTrucks;
event stopAttack;
event BuildOutpost;
event updateDetails;
event savePower;
event destroyOil;
event buildVtolPads;
event StartGame;
event FinishStructures;
event WatchDefendBase;
event WatchHelpAlly;
event agressiveDefence;
event additVTOLDefenses;


//===============================================================================================
//
//					[LEGO PHASE]
//
//===============================================================================================

//------------------------------------------------------
//	Initialize
//------------------------------------------------------
event StartGame(StartGameTr)
{

	//Initialize variables
	//--------------------
	mainPhase = 0;
	curLegoStr = 0;
	maxTrucks = 5;

	temp = random(16);
	if(temp > 12)
	{
		numRushers = 8;		//Early rush
	}
	else if((temp >= 5) and (temp <= 12))
	{
		numRushers = 17;	//Mass attack
	}
	else
	{
		numRushers = 12;	//Normal attack
	}

	curEnemy = -1;
	curEnemyX = -1;
	curEnemyY = -1;
	attackPhase = 0;
	TemplDepth = 1;				//From how many different templates to choose a template randomly, depends on res phase
	maxScouts = 1;				//Enable atleast 1 scout at startup, otherwise might take too long (if 20 attackers)
	extraStruct = 0;
	curEnEdgeX = -1;
	KeepDist = (19 * 128);			//Distance to keep of the enemy base when sending attackGr for regrouping
	minAttackH = 47;			//Min attack health. Retreat if < minAttackH
	maxAttackH = 90;			//Attack only if health > maxAttackH, must be bigger than minAttackH
	//numRepairing = 0;			//How many attackers are repairing at the moment
	haveOutpost = FALSE;			//Outpost to retreat to and where to repair damadged units
	powerSaving = FALSE;			//If we are in power saving mode
	defendingBase = FALSE;			//Attackers are currently defending the base
	maxOilGr = 4;				//Number of droids in the oilGr
	//attackOilX = -1;			//Coordinates of enemy derrick
	//attackOilY = -1;			//Coordinates of enemy derrick
	//attackDerrick = NULLOBJECT;		//No enemy derricks to attack yet
	maxTVtols = 8;				//Max number of antitank VTOLs
	maxSVtols = 10;				//Max number of antistructure  VTOLs
	maxDefenders = 5;			//Max number of defenders
	outpostDist = 0;			//Remember the distance between the enemy base and the outpost
	maxRetreats = 6;			//Max time to retreat before alloutattack
	muchoPower = 3500;			//If this amount of power is available, then start building expensive templates
	transportDroid = NULLOBJECT;		//Cyborg transport
	dropPhase = 0;				//Phase of the vurrent cyborg drop
	transportZ = 0;				//Height of the transport when landing
	cybTemplate = 0;			//Cyborg template to use for drops
	dropEnabled = FALSE;			//Wheather to drop or not to drop
	alreadyAttacked = FALSE;		//Wheather we have already attacked an enemy base atleast 1 time
	//toRepDefendDroid = NULLOBJECT;		//Defender, which is about to be repaired by the repair unit
	NumOldDefenders = 0;			//How many defenders there were, before base defence was turned on (revert to this number)
	
	helpAllyPlayer = -1;			//No ally in danger right now
	helpAllyPlayerX = -1;			//Coords of where to send help for the ally
	helpAllyPlayerY = -1;			//Coords of where to send help for the ally

	bigMap = FALSE;
	if((mapHeight > 150) and (mapWidth > 150))
	{
		bigMap = TRUE;
	}

	oilX = 0;
	oilY = 0;


	temp = (9 * 128);

	scoutX[0] = temp;				//Bottom left
	scoutY[0] = (mapHeight * 128) - temp;
	scoutX[1] = (mapWidth * 128) - temp;	//Top right
	scoutY[1] = temp;

	//Prepair features for future use
	//-------------------------------
	initGetFeature(oilRes,player,player);

	//Temp base
	//---------
	baseX = (128*mapWidth)/2;
	baseY = (128*mapHeight)/2;

	//Add all droids to a group and sort out constructors
	//---------------------------------------------------
	groupAddArea(tempGroup, player, 0, 0, (mapWidth*128), (mapHeight*128));
	initIterateGroup(tempGroup);
	droid = iterateGroup(tempGroup);
	while(droid != NULLOBJECT)
	{
		if(droid.droidType == DROID_CONSTRUCT)	//If a constructor
		{
			//forceDamageObject(droid, 50);

			baseX = droid.x;	//Base coordinates
			baseY = droid.y;

			droidLeaveGroup(droid);
			groupAddDroid(buildGroup,droid);
		}
		droid = iterateGroup(tempGroup);
	}


	//Send one truck to build factory
	//-------------------------------
	boolResult = FALSE;
	buildX = baseX;
	buildY = baseY;
	initIterateGroup(buildGroup);
	droid = iterateGroup(buildGroup);
	while((boolResult == FALSE) and (droid != NULLOBJECT))
	{
		if(droid.order == DORDER_NONE)
		{
			boolResult2 = pickStructLocation(factory, ref buildX, ref buildY,player);
			if(boolResult2 == TRUE)
			{
				orderDroidStatsLoc(droid, DORDER_BUILD, factory, buildX,buildY);
				boolResult = TRUE;
			}
		}
		droid = iterateGroup(buildGroup);
	}

	//transportDroid = addDroid(Transport, baseX, baseY, player);
}


//------------------------------------------------------
//	Build all necessary structures
//------------------------------------------------------
event LegoBuild(LegoBuildTr)
{
	//DERRICKS
	//--------
	initGetFeature(oilRes,player,player);
	feature = getFeature(player);
	if(feature != NULLOBJECT)
	{
		buildX = feature.x;
		buildY = feature.y;

		//If no no trucks already trying to build the same derrick
		initIterateGroup(buildGroup);
		droid = iterateGroup(buildGroup);
		count = 0;
		while((droid != NULLOBJECT) and (count == 0))
		{
			if((droid.orderx == buildX) and (droid.ordery == buildY))
			{
				count = count + 1;	//Count trucks
			}
			droid = iterateGroup(buildGroup);
		}

		if(count == 0)		//Send only 1 truck to each derrick
		{
			initIterateGroup(buildGroup);
			droid = iterateGroup(buildGroup);
			boolResult = FALSE;
			while((boolResult == FALSE) and (droid != NULLOBJECT))
			{
				if(droid.order == DORDER_NONE)
				{
					orderDroidStatsLoc(droid, DORDER_BUILD,derrick, buildX,buildY);
					boolResult = TRUE;
				}
				droid = iterateGroup(buildGroup);
			}
		}
	}

	//Upgrade factories if it is T3
	//-----------------------------
	if(isStructureAvailable(facModule,player))		//If Factory module is already available
	{
		initEnumStruct(FALSE,factory,player,player);			
		structure= enumStruct();
		while(structure != NULLOBJECT)
		{
			//if((skGetFactoryCapacity(structure) < 2) and (skCanBuildTemplate(player,structure, tmpl[0][8])))		//No fac module and T3 (if we have Trck Python HC)		
			if(skGetFactoryCapacity(structure) < 2)
			{
				initIterateGroup(buildGroup);
				droid = iterateGroup(buildGroup);
				//boolResult = TRUE;			//Send only 1 truck
				//while((droid != NULLOBJECT) and (boolResult))
				while(droid != NULLOBJECT)
				{
					if(droid.order == DORDER_NONE)
					{
						//boolResult = FALSE;
						orderDroidStatsLoc(droid, DORDER_BUILD, facModule, structure.x,structure.y);
					}
					droid = iterateGroup(buildGroup);
				}
			}
			structure = enumStruct();
		}
	}

	//STRUCTURES
	//----------
	if(curLegoStr < numLego)
	{
		buildX = baseX;
		buildY = baseY;
		droid = NULLOBJECT;
		boolResult = FALSE;

		initIterateGroup(buildGroup);
		droid = iterateGroup(buildGroup);
		while((droid != NULLOBJECT) and (boolResult == FALSE))
		{
			if(droid.order == DORDER_NONE)
			{
				boolResult2 = pickStructLocation(legoSt[curLegoStr], ref buildX, ref buildY,player);
				if(boolResult2 == TRUE)
				{
					tempDroid = droid;
					boolResult = TRUE;
				}
			}
			droid = iterateGroup(buildGroup);	//Next droid
		}

		//Find out if a truck is already building on the spot where another truck might try to build and will fail
		if(boolResult)
		{
			boolResult = TRUE;
			initIterateGroup(buildGroup);
			droid = iterateGroup(buildGroup);
			while((droid != NULLOBJECT) and (boolResult == TRUE))
			{
				if(droid != tempDroid)
				{
					if(droid.order == DORDER_BUILD)
					{
						if((buildX == droid.orderx) and (buildY == droid.ordery))
						{
							boolResult = FALSE;
						}
					}
				}
				droid = iterateGroup(buildGroup);
			}
		}

		//Build
		if(boolResult)
		{
			orderDroidStatsLoc(tempDroid, DORDER_BUILD,legoSt[curLegoStr], buildX,buildY);
			curLegoStr = curLegoStr + 1;
		}
	}

	//End Lego phase, start rush preparations
	//---------------------------------------
	if(mainPhase == 0)	//If not already activated
	{
		if(curLegoStr == (numLego - 1))		// (numLego - HQ)
		{
			setEventTrigger(endPhaseOne,nowTr);
		}
	}

	//Now that HQ is built we can deactivate it
	//-----------------------------------------
	if(curLegoStr == numLego)
	{
		setEventTrigger(LegoBuild, inactive);
	}
}


//------------------------------------------------------
//	End Lego phase, start rush preparations
//------------------------------------------------------
event endPhaseOne(inactive)
{
	//Start rush preparation phase
	//----------------------------
	setEventTrigger(doResearch,doResearchTr);
	setEventTrigger(buildDerricks,buildDerricksTr);
	setEventTrigger(initializeRushPrep,nowTr);
	setEventTrigger(RushControl,RushControlTr);
	//setEventTrigger(sendScouts,sendScoutsTr);
	setEventTrigger(expandBase,expandBaseTr);
	setEventTrigger(buildDefenses,buildDefensesTr);
	setEventTrigger(oilDefenses,oilDefensesTr);
	//setEventTrigger(updateDetails,updateDetailsTr);
	setEventTrigger(savePower,savePowerTr);
	setEventTrigger(destroyOil,destroyOilTr);
	setEventTrigger(buildVtolPads,buildVtolPadsTr);
	setEventTrigger(FinishStructures,FinishStructuresTr);

	setEventTrigger(LegoTrucks,inactive);
	setEventTrigger(endPhaseOne, inactive);
	
}

//=============================================================================================
//					[RUSH]
//=============================================================================================

//------------------------------------------------------
//	Send units to the outpost, near the enemy base
//------------------------------------------------------
event Rush(RushTr)
{
	if((sendOutpostGr.members + attackGroup.members + collectSendGr.members) > numRushers)
	{
		//setFogColour(random(200) + 50, 1, 1);
		if(curEnemy != -1)	//We have an enemy and not already on our way
		{
			//setFogColour(1, random(200) + 50, 1);
			if((curEnEdgeX > 0) and (attackPhase == 0))
			{
				maxTrucks = 12;							//Maximum number of the trucks to be built in this phase

				if(bigMap)
				{
					maxScouts = 3;
				}
				else
				{
					maxScouts = 2;
				}
				groupAddGroup(sendOutpostGr, collectSendGr);		//From collectSendGr to sendOutpostGr
				groupAddGroup(sendOutpostGr, attackGroup);		//From attackGroup to sendOutpostGr
				setGroupSecondary(sendOutpostGr, DSO_HALTTYPE, DSS_HALT_GUARD);	//Don't start attacking the base
				orderGroupLoc(sendOutpostGr, DORDER_MOVE, curEnEdgeX, curEnEdgeY);
				attackPhase = 1;						//On our way

				alreadyAttacked = TRUE;

				//If we were making an early rush then make sure we build more units before we attack again (otherwise will be slowly increased by 1)
				//if(numRushers < 10)
				//{
				//	numRushers = 10;
				//}

				setEventTrigger(BuildOutpost,BuildOutpostTr);		//Start building outpost
				setEventTrigger(Rush,inactive);
			}
		}
	}
}

//------------------------------------------------------
//	Cancel current attack
//------------------------------------------------------
event stopAttack(inactive)
{
	showConsoleText(DebugMsg[4], player);		//Attack stopped

	attackPhase = 0;
	curEnemy = -1;
	curEnEdgeX = -1;
	curEnEdgeY = -1;
	curEnemyX = -1;
	curEnemyY = -1;
	numRetreats = 0;

	groupAddGroup(sendOutpostGr, attackGroup);	//Add attackGroup to sendOutpostGr
	groupAddGroup(sendOutpostGr, collectSendGr);	//Add collectSendGr to sendOutpostGr
	groupAddGroup(sendOutpostGr, repairedGroup);	//Add repairedGroup to sendOutpostGr
	groupAddGroup(repGr, repairedGroup);		//Add repGr to sendOutpostGr

	//setGroupSecondary(attackGroup, DSO_HALTTYPE, DSS_HALT_GUARD);
	//orderGroupLoc(attackGroup, DORDER_MOVE,attackGroup.x,attackGroup.y);	//Collect them a bit
	setGroupSecondary(sendOutpostGr, DSO_HALTTYPE, DSS_HALT_GUARD);
	orderGroupLoc(sendOutpostGr, DORDER_MOVE,attackGroup.x,attackGroup.y);	//Collect them a bit
	setEventTrigger(Rush,RushTr);

	setEventTrigger(stopAttack,inactive);
}

//------------------------------------------------------
//	Control the attack
//------------------------------------------------------
event RushControl(inactive)
{
	//=====================================================================
	//		attackPhase explaination:
	//	0:	idle
	//	1:	on our way to the enemy 'edge' (waiting for regrouping)
	//	2:	on our way to the base
	//	3:	attacking
	//=====================================================================

	if((not defendingBase) and (helpAllyPlayer < 0))	//Attackers not busy
	{

		temp = (KeepDist / 2);			//Enemy base range

		//maxRepairing = numRushers * 3 / 7 + 1;		//Max number of units allowed to be repairing before retreating

		//Max number of units that may be going to repair at the same time before retreat
		//-------------------------------------------------------------------------------
		result = attackGroup.members + repGr.members;		//Total available units (+repGr units to make it more precise)

		//if(numRushers > attackGroup.members)
		//{
		//	result = numRushers;		//Use numRushers or number of attackers to calculate how many units may repair at a time (whatever number is bigger)
		//}

		maxRepairing = attackGroup.members * 3 / 7 + 2;		//Max number of units allowed to be repairing before retreating



		//------------------------
		//Stop attack if necessary
		//------------------------
		if((attackPhase > 0) and (curEnemy != -1))	//If dead
		{
			if(not actPlayer[curEnemy])
			{
			//Retreat if enemy is dead
				//------------------------
				setEventTrigger(stopAttack,nowTr);	//Cancel attack, clear variables
				attackPhase = 0;
			}
		}

		//Add units from collectSendGr to sendOutpostGr if we have a small group which can protect itself (prevent ant-tail)
		if(collectSendGr.members > 6)
		{
			groupAddGroup(sendOutpostGr, collectSendGr);	//Add collectSendGr to sendOutpostGr
		}

		//-------------------------------------------------------------
		//Add units to attack group after they have reached the outpost
		//-------------------------------------------------------------
		if(attackPhase > 0)	//If on our way to the outpost
		{
			//If all attack units were killed or alloutattack, then make defend units attackers
			//---------------------------------------------------------------------------------
			if(((attackGroup.members + sendOutpostGr.members + repGr.members) < (numRushers / 2)) or (numRetreats > maxRetreats))
			{
				if(defendGr.members > (maxDefenders / 2))		//Enough defenders
				{
					showConsoleText(DebugMsg[5], player);		//Adding some defenders to attackers

					initIterateGroup(defendGr);
					droid = iterateGroup(defendGr);
					count = defendGr.members;
					count2 = defendGr.members;
					while((count > (count2 / 2)) and (droid != NULLOBJECT))	//Leave atleast 50% of available number of defenders
					{
						if(droid.droidType != DROID_REPAIR)		//Leave them the repair unit, so this will not screw up everything
						{
							groupAddDroid(sendOutpostGr, droid);	//Add to attackers
							count = count - 1;
						}
						droid = iterateGroup(defendGr);		//Next droid
					}

					toRepDefendDroid[0] = NULLOBJECT;		//Make repairer stop following this unit if it became an attacker
					toRepDefendDroid[1] = NULLOBJECT;
				}
			}

			//Do alloutattack if failed too many times already
			//------------------------------------------------
			if(numRetreats > maxRetreats)
			{
				//if(not defendingBase)		//(Done earlier now)
				//{
					showConsoleText(DebugMsg[3], player);		//Alloutattack
					groupAddGroup(sendOutpostGr, collectSendGr);	//Add collectSendGr to sendOutpostGr
					groupAddGroup(sendOutpostGr, attackGroup);	//Add attackGroup to sendOutpostGr
					groupAddGroup(sendOutpostGr, scoutGroup[0]);	//Add scout group1 to sendOutpostGr
					groupAddGroup(sendOutpostGr, scoutGroup[1]);	//Add scout group2 to sendOutpostGr
					groupAddGroup(sendOutpostGr, oilGr);		//Add oil attacking group to sendOutpostGr
	
					numRetreats = 0;	//Reset (necessary?)
				//}
			}

			//Send newly-built units to the edge
			//----------------------------------
			boolResult = FALSE;
			if(((attackGroup.members + sendOutpostGr.members) > (numRushers / 2)) and (sendOutpostGr.members > 3))		//Check this condition only one time
			{
				//showConsoleText(DebugMsg[2], player);	//reinforcements on the way
				boolResult = TRUE;
			}

			//tempX = sendOutpostGr.x;			//Find center of the group
			//tempY = sendOutpostGr.y;
			//result = tempGroup.members;		//By accessing another group we make WZ clear the cached sendOutpostGr member variables, to reinitialize them next time we run this event (otherwise values won't change)

			initIterateGroup(sendOutpostGr);
			droid = iterateGroup(sendOutpostGr);
			while(droid != NULLOBJECT)
			{
				if(distBetweenTwoPoints(droid.x, droid.y, curEnEdgeX, curEnEdgeY) > temp)		//If not in the outpost
				{
					//Prevent the ant-tail, send units to the center of the group if too far away ahead
					//if(distBetweenTwoPoints(droid.orderx, droid.ordery, curEnEdgeX, curEnEdgeY) < temp)		//If was already sent to the outpost
					//{
					//	if(distBetweenTwoPoints(droid.x, droid.y, tempX, tempY) > (9 * 128))		//If too far away from its buddies
					//	{
					//		orderDroidLoc(droid, DORDER_MOVE, tempX, tempY);		//Prevent ant-tail, send unit back to the group center
					//	}
					//}
					//else

					if(distBetweenTwoPoints(droid.orderx, droid.ordery, curEnEdgeX, curEnEdgeY) >= temp)		//If not going to the outpost
					{
						if(boolResult == TRUE)		//Condition checked before
						{
							setDroidSecondary(droid, DSO_HALTTYPE, DSS_HALT_GUARD);
							result = (7 * 128);
							//orderDroidLoc(droid, DORDER_MOVE, curEnEdgeX + random(result) - (result/2), curEnEdgeY + random(result) - (result/2));		//Send to the outpost
							orderDroidLoc(droid, DORDER_SCOUT, curEnEdgeX + random(result) - (result/2), curEnEdgeY + random(result) - (result/2));		//Send to the outpost
						}
					}
				}
				else	//Add to attackers if reached outpost
				{
					//droidLeaveGroup(droid);
					groupAddDroid(attackGroup,droid);
				}
				droid = iterateGroup(sendOutpostGr);		//Next droid
			}

			//-------------------------------------------
			//Add repaired units back to the attack group
			//-------------------------------------------
			initIterateGroup(repGr);
			droid = iterateGroup(repGr);
			while(droid != NULLOBJECT)
			{

				if((droid.health > 85) or (not haveOutpost))	//Don't have to or can't repair
				{
					groupAddDroid(repairedGroup, droid);	//Collect them, add to a temporary group to prevent ant-tail
				}
				else	//Re-send to repair
				{
					if((droid.health < 85)  and (haveOutpost) and  (droid.order != DORDER_RTR))	//Has to and can repair and not going to repair
					{
						orderDroid(droid, DORDER_RTR);		//Re-order to repair
					}
				}

			/*
				if((droid.health < 85) and (haveOutpost) and (droid.order != DORDER_RTR))
				{	
					//if(droid.order != DORDER_RTR)			//If not going to repair
					//{
						orderDroid(droid, DORDER_RTR);		//Order to repair
					//}
				}
				else		//If already repaired or can't repair
				{
					if(((droid.health > 85) or (not haveOutpost)) and (droid.order != DORDER_RTR))			//If not going to repair
					{
						//droidLeaveGroup(droid);
						//groupAddDroid(attackGroup, droid);	//Add to attackers
						groupAddDroid(repairedGroup, droid);	//Collect them, add to a temporary group to prevent ant-tail
					}
				}
			*/

				droid = iterateGroup(repGr);			//Next droid
			}

			//If units are far (already attacking enemy base) then wait for more peraired units
			if(attackPhase > 2)
			{
				result = 3;
				if(repGr.members > 7)
				{
					result = 6;		//Wait for more repaired units, if many of them are going to repair, before sending back to enemy
				}
				
				if(repairedGroup.members > result)	//Prevent ant-tail while attacking
				{
					groupAddGroup(sendOutpostGr, repairedGroup);	//Add back to action
				}
			}
			else
			{
				groupAddGroup(attackGroup, repairedGroup);	//Add back to attackers directly
			}

			//Remove unit from the attack group if it is goint to repair
			//----------------------------------------------------------
			initIterateGroup(attackGroup);
			droid = iterateGroup(attackGroup);
			while(droid != NULLOBJECT)
			{
				if(droid.order == DORDER_RTR)			//If going to repair
				{
					//droidLeaveGroup(droid);
					setDroidSecondary(droid, DSO_HALTTYPE, DSS_HALT_GUARD);		//Don't pursue, guard position
					groupAddDroid(repGr, droid);		//Add to repair group
			
				}
				droid = iterateGroup(attackGroup);		//Next droid
			}
		}


		//------------------------------------------------------------------
		//Start attacking enemy base if most of the units are in the outpost
		//------------------------------------------------------------------
		if(attackPhase == 1)		//If on our way to the outpost
		{
			//Check if we can start our invasion
			//----------------------------------
			//if(attackGroup.members > numRushers)			//If we have enough units
			//{
				boolResult = FALSE;
				//if(numRepairing == 0)
				//{
					if(haveOutpost == TRUE)
					{
						boolResult = TRUE;	//Repair units with light damage
					}
				//}

				//Find idle repair facility
				//-------------------------
				//structure2 = NULLOBJECT;
				//initEnumStruct(FALSE,factory,player,player);
				//structure = enumStruct();
				//while(structure != NULLOBJECT)
				//{
				//	if(structureIdle(structure) == TRUE)
				//	{
				//		structure2 = structure;
				//	}
				//	structure = enumStruct();
				//}

				//Count idle units
				//----------------
				result2 = repGr.members;
				result = 0;
				initIterateGroup(attackGroup);
				droid = iterateGroup(attackGroup);
				while(droid != NULLOBJECT)
				{
					if((droid.order == DORDER_NONE) or ((droid.orderx == curEnEdgeX) and (droid.ordery == curEnEdgeY)))	//Not moving or retreating	//Was != DORDER_MOVE
					{
						result = result + 1;		//Num of idle units

						//Repair units with light damage
						//------------------------------
						//if((droid.health < 60) and (boolResult) and ((result2 + 2) < maxRepairing))	//If it's damaged a bit and can repair, don't sent to rpare too many units, keep number under maxRepairing
						if((droid.health < 70) and (boolResult))	//If it's damaged a bit and can repair
						{
							orderDroid(droid, DORDER_RTR);	//Repair unit
							result2 = result2 + 1;
						}
					}
					droid = iterateGroup(attackGroup);
				}

				//Send to the enemy base if everything's ok
				//-----------------------------------------
				if((attackGroup.members) > numRushers)		//If have enough units ready to attack
				{
					boolResult = FALSE;
					if(isHumanPlayer(curEnemy))		//Move instead of scout if attacking human
					{
						boolResult = TRUE;
					}

					//result2 = (result * 100 / attackGroup.members);

					//if((result2 > 60) or (result >= numRushers))				// > 60% of the entire group is ready for attack, or have enough, even if many repairing
					//{
						if(((haveOutpost) and (attackGroup.health >= maxAttackH)) or (haveOutpost == FALSE))
						{
							//if((numRepairing < (attackGroup.members / 2)) and (repGr.members < (numRushers / 4)))		//If not too many attackers repairing
							if(repGr.members < (maxRepairing / 2))	//Not too many repairing otherwise wait until repaired
							{
								//Send to the enemy base
								//----------------------
								attackPhase = 2;
								showConsoleText(DebugMsg[2], player);	//Starting attack
								setGroupSecondary(attackGroup, DSO_HALTTYPE, DSS_HALT_GUARD);

								//if(boolResult == TRUE)		//If human
								//{
								//	orderGroupLoc(attackGroup, DORDER_MOVE, curEnemyX, curEnemyY);
								//}
								//else					//AI
								//{
									orderGroupLoc(attackGroup, DORDER_SCOUT, curEnemyX, curEnemyY);
								//}
							}
						}
					//}
				}
			//}
		}


		//-------------------------------
		//Sending to the enemy base rules
		//-------------------------------
		if(attackPhase > 1)	//If goint to the enemy base or already reached it
		{
			//If attack failed
			//----------------
			//if((attackGroup.members < (numRushers * 2 / 3)) or ((haveOutpost) and (attackGroup.health < minAttackH)) or (numRepairing >= (attackGroup.members / 2)) or (repGr.members > maxRepairing))	//If not enough units available

			boolResult = FALSE;

			if(attackGroup.members < 6)	//Not enough units left 
			{
				showConsoleText(DebugMsg[6], player);		//Not enough units left 
				boolResult = TRUE;
			}

			//else if((haveOutpost) and (attackGroup.health < minAttackH))	//Too many damaged units
			//{
			//	showConsoleText(DebugMsg[5], player);			//Too many damaged units
			//	boolResult = TRUE;
			//}
			//if(repGr.members >= maxRepairing)	//Too many repairing
			//{
			//	showConsoleText(DebugMsg[4], player);		//Too many repairing
			//	boolResult = TRUE;
			//}
			//else if(attackGroup.members < (numRushers * 2 / 5))	//If not enough units available
			//{
			//	showConsoleText(DebugMsg[6], player);		//Not enough units left 
			//	boolResult = TRUE;
			//}

			if(boolResult)		//Cancel attack, retreat
			{
				attackPhase = 1;
				setGroupSecondary(attackGroup, DSO_HALTTYPE, DSS_HALT_GUARD);
				orderGroupLoc(attackGroup, DORDER_MOVE, curEnEdgeX, curEnEdgeY);	//Retreat
				numRushers = numRushers + 2;	//Increase number of attackers
				if(numRushers > 40)
				{
					numRushers = 40;
				}

				numRetreats = numRetreats + 1;		//Remember how many times our attacks failed
			}
			else		//If enough units available
			{
				boolResult = FALSE;
				if(isHumanPlayer(curEnemy))		//Move instead of scout if attacking human
				{
					boolResult = TRUE;
				}

				//--------------------------------------------------
				//Send newly-arrived units (outpost units) to attack
				//--------------------------------------------------
				//tempX = attackGroup.x;			//Find center of the group
				//tempY = attackGroup.y;
				//result = tempGroup.members;		//By accessing another group we make WZ clear the cached sendOutpostGr member variables, to reinitialize them next time we run this event (otherwise values won't change)
				initIterateGroup(attackGroup);
				droid = iterateGroup(attackGroup);

				while(droid != NULLOBJECT)
				{
					if(distBetweenTwoPoints(droid.x, droid.y, curEnemyX, curEnemyY) > temp)		//If not in the enemy base
					{
						if((droid.order == DORDER_NONE) or ((droid.orderx != curEnemyX) and (droid.ordery != curEnemyY)))		//Idle, or going somewhere else, but not to the enemy base
						{
							setDroidSecondary(droid, DSO_HALTTYPE, DSS_HALT_GUARD);
							//if(boolResult == TRUE)		//Human
							//{
							//	orderDroidLoc(droid, DORDER_MOVE, curEnemyX, curEnemyY);
							//}
							//else			//AI
							//{
								orderDroidLoc(droid, DORDER_SCOUT, curEnemyX, curEnemyY);
							//}
						}
						//else	//If already on the way to the enemy base
						//{
						//	//Prevent the ant-tail, send units to the center of the group if too far away ahead
						//	if(distBetweenTwoPoints(droid.x, droid.y, tempX, tempY) > (9 * 128))		//If too far away from its buddies
						//	{
						//		orderDroidLoc(droid, DORDER_MOVE, tempX, tempY);		//Prevent ant-tail, send unit back to the group center
						//	}
						//}
					}
					else				//Already in the enemy base
					{
						if(attackPhase != 3)
						{
							showConsoleText(DebugMsg[7], player);		//Reached enemy base
						}

						attackPhase = 3;
						setDroidSecondary(droid,DSO_HALTTYPE, DSS_HALT_PERSUE);	//Persue. For more efficient structure targeting.
					}
					droid = iterateGroup(attackGroup);		//Next droid
				}
			}
		}


		//------------
		//Attack rules
		//------------
		if(attackPhase == 3)			//If attacking
		{
			//If we were making an early rush then make sure we build more units before we attack again (otherwise will be slowly increased by 1)
			if(numRushers < 10)
			{
				numRushers = 10;
			}

			//They are repairing bunker we attack! Eliminate the truck
			//--------------------------------------------------------
			boolResult = FALSE;
			resetDroidTargets();
			setDroidTarPref(DT_CONSTRUCT);
			tempDroid = droidTargetInArea(curEnemy, player, curEnemyX - temp, curEnemyY - temp, curEnemyX + temp, curEnemyY + temp);
			if(tempDroid != NULLOBJECT)
			{
				if(tempDroid.droidType == DROID_CONSTRUCT)
				{
					//Order droid close to the truck to attack it
					//-------------------------------------------
					boolResult = TRUE;
					initIterateGroup(attackGroup);
					droid = iterateGroup(attackGroup);
					while(droid != NULLOBJECT)
					{
						if(distBetweenTwoPoints(droid.x, droid.y, tempDroid.x, tempDroid.y) < (10 * 128))
						//if(losTwoObjects(droid, tempDroid, TRUE))	//If can see truck
						{
							orderDroidObj(droid, DORDER_ATTACK,tempDroid);
							attackObject = tempDroid;
						}
						droid = iterateGroup(attackGroup);
					}
				}
			}

			//Hi-priority structures
			//----------------------
			count = numAttackStructs - 1;
			while(count >= 0)
			{
				result = (15 * 128);
				initEnumStruct(FALSE,attackStructs[count],curEnemy,player);			
				structure = enumStruct();
				while(structure != NULLOBJECT)
				{
					if(distBetweenTwoPoints(curEnemyX, curEnemyY, structure.x, structure.y) < result)		//If in the enemy base
					{
						boolResult = TRUE;
						initIterateGroup(attackGroup);
						droid = iterateGroup(attackGroup);
						while(droid != NULLOBJECT)
						{
							if(droid.order != DORDER_ATTACK)	//Not already attacking
							{
								//if(distBetweenTwoPoints(droid.x, droid.y, structure.x, structure.y) < (12 * 128))
								if(losTwoObjects(droid, structure, FALSE))	//If can see this structure
								{
									orderDroidObj(droid, DORDER_ATTACK, structure);
									sVtolObject = structure;
								}
							}
							droid = iterateGroup(attackGroup);
						}
					}
					structure = enumStruct();
				}
				count = count - 1;
			}

			if(boolResult == FALSE)		//Factories
			{
				resetStructTargets();
				setStructTarPref(ST_FACTORY);
				structure = structTargetInArea(curEnemy, player, curEnemyX - temp, curEnemyY - temp, curEnemyX + temp, curEnemyY + temp);
				if(structure != NULLOBJECT)
				{
					//Order droid close to the factory to attack it
					initIterateGroup(attackGroup);
					droid = iterateGroup(attackGroup);
					while(droid != NULLOBJECT)
					{
						if(distBetweenTwoPoints(droid.x, droid.y, structure.x, structure.y) < (10 * 128))
						{
							orderDroidObj(droid, DORDER_ATTACK,structure);
							attackObject = structure;
						}
						droid = iterateGroup(attackGroup);
					}
				}
			}
		}

		//--------------------------------------------------------
		//Allow repairing if we have repair facilities in outposts
		//--------------------------------------------------------
		if(haveOutpost)
		{
			setGroupSecondary(attackGroup, DSO_REPAIR_LEVEL, DSS_REPLEV_HIGH);
		}
		else
		{
			setGroupSecondary(attackGroup, DSO_REPAIR_LEVEL, DSS_REPLEV_NEVER);
		}
	}
}

//------------------------------------------------------
//Finish part-built structures
//------------------------------------------------------
event FinishStructures(inactive)
{
	//Find structure closest to the base
	//----------------------------------
	temp = tempGroup.members;		//Reset cached buildGroup values
	result = 99999;
	structure2 = NULLOBJECT;
	initEnumStruct(TRUE,derrick,player,player);		//TRUE: iterate through all structures
	structure= enumStruct();
	while(structure != NULLOBJECT)
	{
		if(not structureComplete(structure))		//If structure not finished
		{
			//Check if anybody is building it already
			//---------------------------------------
			boolResult = TRUE;
			initIterateGroup(buildGroup);				// find idle droids in build group.
			droid = iterateGroup(buildGroup);
			while((droid != NULLOBJECT) and (boolResult))
			{
				if((droid.orderx == structure.x) and (droid.ordery == structure.y)) 
				{
					boolResult = FALSE;			//Somebody is building it, try next structure
				}
				droid = iterateGroup(buildGroup);
			}

			//Make sure it is not an Outpost defense (since outpost builder is not in the buildGroup)
			//--------------------------------------
			if(boolResult)
			{
				if(outpostDroid != NULLOBJECT)
				{
					if((outpostDroid.orderx == structure.x) and (outpostDroid.ordery == structure.y))
					{
						boolResult = FALSE;		//Don't finish building this structure
					}
				}
			}

			//Remember this structure if it is the closest one so far
			//-------------------------------------------------------
			if(boolResult)						//If nobody is building it already
			{
				result2 = distBetweenTwoPoints(baseX, baseY, structure.x, structure.y);		//How far away from the base
				if(result2 < result)				//If this structure is closer than the last one, then store it instead of the last one
				{
					result = result2;
					structure2 = structure;			//Remember this structure
				}
			}
		}
		structure = enumStruct();
	}

	//Finish building structure, if there are any
	//-------------------------------------------
	if((structure2 != NULLOBJECT) and (boolResult))			//If found an unbuilt structure and nobody is building it already
	{
		//Find closest truck
		//------------------
		result = 99999;
		tempDroid = NULLOBJECT;
		initIterateGroup(buildGroup);				// find idle droids in build group.
		droid = iterateGroup(buildGroup);
		while(droid != NULLOBJECT)
		{
			if(droid.order == DORDER_NONE)			//If idle
			{
				result2 = distBetweenTwoPoints(droid.x, droid.y, structure2.x, structure2.y);		//How far away this truck is from the unfinished structure
				if(result2 < result)
				{
					result = result2;
					tempDroid = droid;		//Remember this truck, it is the closest so far
				}
			}
			droid = iterateGroup(buildGroup);
		}

		//Send to build if found a truck
		//------------------------------
		if(tempDroid != NULLOBJECT)
		{
			orderDroidObj(tempDroid,DORDER_HELPBUILD,structure2);
		}
	}
}

//------------------------------------------------------
//Destroy enemy derricks
//------------------------------------------------------
event destroyOil(inactive)
{
	if(idleGroup(oilGr) > (oilGr.members / 2))
	{
		if(oilGr.members >= maxOilGr)
		{
			boolResult = FALSE;
			//if(attackDerrick != NULLOBJECT)		//If we have derrick to attack
			if(oilX > 0)
			{
				temp = (4 * 128);
				count = 0;
				while((count < numEnemies) and (boolResult == FALSE))
				{
					boolResult = structInArea(Enemies[count], oilX - temp, oilY - temp, oilX + temp, oilY + temp);
					count = count + 1;
				}
			}

			//Find new derrick
			if(boolResult == FALSE)		//No structures found in the area or first search
			{
				//Find closest enemy derrick
				//--------------------------
				oilX = 0;
				result = 99999;
				structure2 = NULLOBJECT;
				count = 0;
				while(count < numEnemies)
				{
					temp = 2432;	//19 * 128
					initEnumStruct(FALSE,derrick,Enemies[count],Enemies[count]);
					structure = enumStruct();
					while(structure != NULLOBJECT)
					{
						if(EnemyX[count] > 0)
						{
							if(distBetweenTwoPoints(structure.x, structure.y, EnemyX[count], EnemyY[count]) > temp)		//Not in the enemy base
							{
								result2 = distBetweenTwoPoints(baseX, baseY, structure.x,structure.y);
								if(result2 < result)
								{
									result = result2;
									structure2 = structure;
								}
							}
						}
						structure = enumStruct();
					}
					count = count + 1;
				}

				//Assign to the found object
				//--------------------------
				if(structure2 != NULLOBJECT)
				{
					//attackDerrick = structure2;
					oilX = structure2.x;
					oilY = structure2.y;
					boolResult = TRUE;
				}
			}

			if(boolResult == TRUE)
			{
				orderGroupLoc(oilGr, DORDER_MOVE, oilX, oilY);
			}
		}
	}

	//Manage oil attack when arrived, destroy derrick if we can get it
	//----------------------------------------------------------------
	//if(oilX > 0)		//If we have an enemy derrick to attack
	//{
	//	initIterateGroup(oilGr);
	//	droid = iterateGroup(oilGr);
	//	while(droid != NULLOBJECT)
	//	{
	//		//if(distBetweenTwoPoints(attackDerrick.x, attackDerrick.y, droid.x, droid.y) < (7 128))	//If close
	//		if(losTwoObjects(droid, attackDerrick, TRUE))	//If we can shoot at the derrick
	//		{
	//			orderDroidObj(droid, DORDER_ATTACK, attackDerrick);
	//		}
	//		droid = iterateGroup(oilGr);
	//	}
	//}
}

//------------------------------------------------------
//	Find most suitabe enemy
//------------------------------------------------------
event chooseEnemy(chooseEnemyTr)
{

	//if((curEnemy == -1) and (numEnemies > 0))
	if(numEnemies > 0)
	{
		if((sendOutpostGr.members + attackGroup.members + collectSendGr.members) > numRushers)
		{
			temp = -1;	//Temp enemy
			count = 0;
			result = 99999;
			while(count < numEnemies)
			{
				if((isHumanPlayer(Enemies[count])) and (EnemyX[count] > 0))
				{
					result2 = distBetweenTwoPoints(baseX, baseY, EnemyX[count], EnemyY[count]);
					if(result2 < result)
					{
						result = result2;	//Remember closest distance so far
						result3 = result2;	//Remember for later use
						temp = Enemies[count];
					}
				}
				count = count + 1;
			}

			//If no human players, find the closest AI
			if(temp == -1)
			{
				result = 99999;
				count = 0;
				while(count < numEnemies)
				{
					if(EnemyX[count] > 0)
					{
						result2 = distBetweenTwoPoints(baseX, baseY, EnemyX[count], EnemyY[count]);
						if(result2 < result)
						{
							result = result2;	//Remember closest distance so far
							result3 = result2;	//For later use
							temp = Enemies[count];
						}
					}
					count = count + 1;
				}
			}
			

			//Change enemy only if new enemy is *much* closer (20 tiles)
			//----------------------------------------------------------
			if(curEnemyX > 0)
			{
				result = distBetweenTwoPoints(baseX, baseY, curEnemyX, curEnemyY) + (20 * 128);
			}

			if(((curEnemyX > 0) and (result3 > result)) or (curEnemyX < 1))	//If already have enemy and new enemy is much closer or no enemy set yet
			{
				curEnemy = temp;	//Remember 'best' enemy
				numRetreats = 0;	//Reset, need to do it in a better place to make generic
			}
		}
	}

	
	//Find bases again even if (curEnemy != -1) so that attackers could find next factory if its far away
	//---------------------------------------------------------------------------------------------------
	count = 0;
	while(count < numEnemies)
	{

		//-----------------------
		//	Find enemy's base
		//-----------------------
		tempX = baseX;
		tempY = baseY;

		//Store enemy base coords, find closest structure
		//-----------------------------------------------
		EnemyX[count] = -1;
		EnemyY[count] = -1;
		result = 99999;
		count2 = 0;
		while(count2 < numBaseStructs)		//For all base structures
		{
			initEnumStruct(FALSE,baseStructs[count2],Enemies[count],Enemies[count]);
			structure = enumStruct();
			while(structure != NULLOBJECT)
			{
				//if(structureComplete(structure))
				//{
					result2 = distBetweenTwoPoints(tempX, tempY, structure.x, structure.y);
					if(result2 < result)
					{
						result = result2;
						EnemyX[count] = structure.x;
						EnemyY[count] = structure.y;
					}
				//}
				structure = enumStruct();
			}
			count2 = count2 + 1;
		}

		//Remember coordinates of the enemy
		//---------------------------------
		if(Enemies[count] == curEnemy)
		{
			
			if((EnemyX[count] != -1) and (EnemyY[count] != -1))
			{
				curEnemyX = EnemyX[count];
				curEnemyY = EnemyY[count];
			}

			result = distBetweenTwoPoints(curEnEdgeX, curEnEdgeY, curEnemyX, curEnemyY);		//If base moved too much
			if((curEnEdgeX == -1) or ((result + (6 * 128)) < outpostDist) or ((result - (6 * 128)) > outpostDist) )	//If no outpost coord yet or enemy base moved too much
			{
				//Find 'edge' of the base
				//-----------------------
				curEnEdgeX = -1;
				curEnEdgeY = -1;
				result = 99999;
				count2 = 0;

				tempX = baseX;
				tempY = baseY;

				curEnEdgeX = curEnemyX;
				curEnEdgeY = curEnemyY;

				//Calculate destination point of the attack group for regrouping
				//--------------------------------------------------------------
				if(curEnEdgeX != -1)
				{
					result = 1;	//KeepDist;	//Assume enemy base to the left
					result2 = 1;	//KeepDist;	//Assume enemy base above the base

					if(curEnEdgeX > maxx)		//Enemy base to the right
					{
						result = result * (-1);	//Go to the left from the enemy base for oupost
					}
					else if(curEnEdgeX > minx)	//Almost on the same X level
					{
						result = 0;
					}

					if(curEnEdgeY > maxy)		//Enemy base lower to the base
					{
						result2 = result2 * (-1);	//Go up for the outpot y coord
					}
					else if(curEnEdgeY > miny)	//Almost on the same Y level
					{
						result2 = 0;
					}

					curEnEdgeX = curEnEdgeX + (result * KeepDist);
					curEnEdgeY = curEnEdgeY + (result2 * KeepDist);

					//Check limits
					if(curEnEdgeX < 0)
					{
						curEnEdgeX = (4 * 128);
					}
					if(curEnEdgeY < 0)
					{
						curEnEdgeY = (4 * 128);
					}
					if(curEnEdgeX > (128 * mapWidth))
					{
						curEnEdgeX = ((128 * mapWidth) - (4 * 128));
					}
					if(curEnEdgeY > (128 * mapHeight))
					{
						curEnEdgeY = ((128*mapHeight) - (4 * 128));
					}

					outpostDist = distBetweenTwoPoints(curEnEdgeX, curEnEdgeY, curEnemyX, curEnemyY);
					boolResult = pickStructLocation(factory, ref curEnEdgeX, ref curEnEdgeY,player);
					if(boolResult == FALSE)
					{
						curEnEdgeX = -1;
						curEnEdgeY = -1;
					}
					
/*
					//--------------------------
					//Pathfinding
					//--------------------------
					//result and result2 are directions
					temp = 0;
					result3 = 0;			//Final lenght between enemy base and outpost in tiles
					result4 = 150;			//Max number of iterations (in tiles)

					tempX = curEnemyX + (result * 512);	//Skip 4 tiles in outpost's direction
					tempY = curEnemyY + (result2 * 512);	//Skip 4 tiles in outpost's direction

					//Round to 128 (+ 64)
					tempX  = tempX / 128;
					tempX  = tempX * 128 + 64;

					tempY = tempY / 128;
					tempY = tempY * 128 + 64;

					boolResult = TRUE;		//Horizontal direction not blocked
					boolResult2 = TRUE;		//Vertical direction not blocked
					while((result4 > 0) and (result3 < 85))		//while still tries left and dist less than 50 tiles
					{
						//---------------------------------------------
						//Choose new coordinates
						//---------------------------------------------
						if(temp == 0)	//Move Horizontally
						{
							buildX = tempX + (result * 128);		//Move 1 tile in outpost's direction horizontaly (x)
							buildY = tempY;
						}
						else		//Move vertically
						{
							buildX = tempX;
							buildY = tempY + (result2 * 128);	//Move 1 tile in outpost's direction vertically (y)
						}

						//---------------------------------------------
						//Check new location with a wall
						//---------------------------------------------
						count = buildX;	//Remember to compare later
						count2 = buildY;

						if(pickStructLocation(wall, ref buildX, ref buildY, player))	//Try this location
						{
							
							if((count != (buildX + 128)) or (count2 != (buildY + 128)))	//If this location is not accessible (building coords were modified)
							{
								//turnPowerOff();
								//setPowerLevel(buildX, player);
								//addStructure( vtolPad, player, tempX - (3 * 128) , tempY );	//DEBUG
			showConsoleText(DebugMsg[2], player);

								if(temp == 0)		//Moving horizontally
								{
									boolResult = FALSE;	//Can't move horizontally
								}
								else			//Moving vertically
								{
									boolResult2 = FALSE;	//Can't move vertically
								}
							}
							else	//This tile is ok
							{
			showConsoleText(DebugMsg[3], player);
			addStructure( wall, player, count  , count2 );	//DEBUG

								tempX = count;	//Remember new coords permanently
								tempY = count2;	//Remember new coords permanently

								if(temp == 0)		//Moving horizontally
								{
									boolResult = TRUE;	//Cancel direction blockage flag, if was blocked
								}
								else			//Moving vertically
								{
									boolResult2 = TRUE;	//Cancel direction blockage flag, if was blocked
								}

								result3 = result3 + 1;		//Moved 1 tile
							}
						}

						//------------------------------------------------
						//If can't move further in the outpost's direction
						//------------------------------------------------
						if((not boolResult) and (not boolResult2))	//If both directions blocked (hor and vert)
						{
			showConsoleText(DebugMsg[1], player);
							if(temp==0)	//Was moving horizontally this time (X)
							{
								buildY = tempY - (result2 * 128);
								buildX = tempX;
								count = buildX;		//Remember to compare later
								count2 = buildY;
								pickStructLocation(wall, ref buildX, ref buildY,player);	//Try this location
								if((count == (buildX + 128)) and (count2 == (buildY + 128)))	//If this location is accessible (building coords were same)
								{
									temp = 1;
									tempY = count2;
									tempX = count;
									boolResult2 = TRUE;	//Reset Vertical blockage
								}
							}
							else	//Was moving vertically this time (Y)
							{
								buildX = tempX - (result * 128);	//Move 1 tile back (reversed) into a horizontal direction
								buildY = tempY;
								count = buildX;		//Remember to compare later
								count2 = buildY;
								pickStructLocation(wall, ref buildX, ref buildY,player);	//Try this location
								if((count == (buildX + 128)) and (count2 == (buildY + 128)))	//If this location is accessible (building coords were same)
								{
									temp = 0;		//Move vertically again next time (temp will be set to 1 later)
									tempX = count;		//Remember new X position
									tempY = count2;
									boolResult = TRUE;	//Reset Horizontal blockage
								}
							}

							//boolResult = TRUE;	//Reset Horizontal blockage
							//boolResult2 = TRUE;	//Reset Vertical blockage
						}

						//--------------------------------
						//Cycle moving direction
						//--------------------------------
						if(temp == 0)
						{
							temp = 1;		//Vertically next time
						}
						else
						{
							temp = 0;		//Horizontally next time
						}
						

						result4 = result4 - 1;
					}

					if(tempX < 0)
					{
						tempX = (4 * 128);
					}
					if(tempY < 0)
					{
						tempY = (4 * 128);
					}
					if(tempX > (128 * mapWidth))
					{
						tempX = ((128 * mapWidth) - (4 * 128));
					}
					if(tempY > (128 * mapHeight))
					{
						tempY = ((128*mapHeight) - (4 * 128));
					}

					centreViewPos(tempX, tempY);
*/


				}
			}
			
		}
		count = count + 1;
	}
}

//==============================================================================================
//
//					[RUSH PREPARATION]
//
//==============================================================================================


//------------------------------------------------------
//	Initialize rush preparation phase.
//------------------------------------------------------
event initializeRushPrep(inactive)
{
	mainPhase = 1;			//Next phase became active
}

//------------------------------------------------------
//	Build attack units
//------------------------------------------------------
event BuildAttackForce(BuildAttackForceTr)
{
	//Enable more trucks after 15 mins, if got stuck in Lego phase somehow
	if(gameTime > 9000)
	{
		maxTrucks = 12;
	}

	//Manage truck production
	//-----------------------
	result2 = 0;	//Number of trucks we started building (don't build too many at one time since we can't count how many of them will get built)		
	temp = 2;	//How many trucks to build at a time

	//if(buildGroup.members == 0)
	//{
	//	temp = 5;	//Build more trucks at a time
	//}

	temp = maxTrucks - buildGroup.members;
	if(temp > 4)
	{
		temp = 5;	//How many trucks to build at a time
	}

	//Build units
	//-----------
	result = 0;	//Index of the current factory (count factories)
	initEnumStruct(FALSE,factory,player,player);
	structure = enumStruct();
	while(structure != NULLOBJECT)
	{
		if((structureIdle(structure) == TRUE) and (structureComplete(structure)))
		{
			boolResult = TRUE;	//Didn't start building anything yet

			//We have not enough trucks
			//-------------------------
			if(boolResult)
			{
				if((buildGroup.members < maxTrucks) and (result2 < temp))	//Only <temp> trucks at a time
				{
					buildDroid(constructor, structure, player, 1);	//Normal one
					result2 = result2 + 1;		//Count trucks
					boolResult = FALSE;
				}
			}

			if(boolResult)		//Didn't start build anything yet
			{
				if((attackPhase > 0) and (result == 0) and (not defendingBase))	//If no repair unit and we already have enough attackers, use only 1 factory (result == 0)
				{
					if(repDefendDroid[0] == NULLOBJECT)
					{
						boolResult = FALSE;
					}
					else if(repDefendDroid[1] == NULLOBJECT)
					{
						boolResult = FALSE;
					}
				}

				if(not boolResult)	//If decided to build a repair unit
				{
					if(skCanBuildTemplate(player,structure, tmplRep[1]))
					{
						buildDroid(tmplRep[1], structure, player, 1);	//Heavy repair unit
					}
					else
					{
						buildDroid(tmplRep[0], structure, player, 1);	//Light repair unit
					}
				}
				
			}

			//Attack units
			//----------------------
			if(boolResult)		//Didn't start build anything yet
			{
				//Decide weather to use cheap or expensive templates
				//--------------------------------------------------
				result3 = 0;			//Cheap templates
				if(playerPower(player) > muchoPower)
				{
					result3 = 1;		//Use expensive templates if we have plenty of power
				}

				//Fill array with best templates
				//------------------------------
				count2 = 0;
				count = numTemplates - 1;
				while((count2 < TemplDepth) and (count >= 0))
				{
					if(skCanBuildTemplate(player,structure, tmpl[result3][count]))
					{
						//setFogColour(random(200) + 50, 1, 1);

						tmplChoice[count2] = tmpl[result3][count];
						count2 = count2 + 1;		//We have chosen one more template
					}
					count = count - 1;			//Check next template
				}

				if(count2 > 0)		//Any templates found
				{
					
					if(getDroidCount(player) < 85)	//Let it build VTOLs and trucks
					{
						boolResult = FALSE;
						buildDroid(tmplChoice[random(count2)],structure,player,1);
					}
				}
			}
		}
		result = result + 1;		//Remember factory index
		structure = enumStruct();
	}
}

//--------------------------------------------------------
//Build cyborgs
//--------------------------------------------------------
event buildCyborgs(buildCyborgsTr)
{
	if((transportGr.members < 10) and (dropGr.members < 6) and (dropPhase == 0))
	{
		if(getStructure(vtolFactory,player) != NULLOBJECT)	//Already have VTOL tech to build transporter soon?
		{
			if(dropEnabled and (not powerSaving))
			{
				initEnumStruct(FALSE,cybFactory,player,player);
				structure= enumStruct();					//Find factory
				while(structure != NULLOBJECT)
				{
					if(structureIdle(structure))
					{

				//count = 1;		//numTemplates - 1
				//count2 = 0;
				//while(count >= 0)
				//{
				//	if(skCanBuildTemplate(player,structure, cybTmpl[count]) )
				//	{
				//		tmplChoice[count2] = cybTmpl[count];
				//		count2 = count2 + 1;
				//	}
				//	count = count - 1;
				//}

						if(cybTemplate > -1)
						{
							buildDroid(cybTmpl[cybTemplate],structure,player,1);
						}		
					}
					structure= enumStruct();
				}
			}
		}
	}

}


//------------------------------------------------------
//	Research Stuff
//------------------------------------------------------
event doResearch(doResearchTr)
{

	//Count how many are already researching
	//--------------------------------------
	initEnumStruct(FALSE,resLab,player,player);
	structure = enumStruct();
	result = 0;
	while(structure != NULLOBJECT)
	{
		if(not structureIdle(structure))	//Max 2 res fac if low on power
		{
			result = result + 1;
		}
		structure = enumStruct();
	}

	//Research
	//--------
	initEnumStruct(FALSE,resLab,player,player);
	structure = enumStruct();
	while(structure != NULLOBJECT)
	{
		if(structureIdle(structure))	//Not researching already
		{
			if((not powerSaving) or (powerSaving and (result < 2)))		//Max 2 res fac if low on power
			{
			
				if(not ((mainPhase >= 2) and (result >= 3) and (playerPower(player) < 600)))		//If we already have Trck Python HC template (and low on power) then don't use more then 3 res fac
				{
					skDoResearch(structure,player,0);
					result = result + 1;
				}
			}
		}
		structure = enumStruct();
	}
}


//------------------------------------------------------
//	Build derricks with nearest truck
//------------------------------------------------------
event buildDerricks(inactive)
{
	//Find closest oil resource
	//-------------------------
	result = 99999;
	feature2 = NULLOBJECT;
	initGetFeature(oilRes,player,player);
	feature = getFeature(player);
	while(feature != NULLOBJECT)
	{
		//Make sure no other truck is  trying to build it
		//-----------------------------------------------
		boolResult = TRUE;
		initIterateGroup(buildGroup);
		droid = iterateGroup(buildGroup);
		while((droid != NULLOBJECT) and (boolResult))
		{
			if(droid.order == DORDER_BUILD)
			{
				if((droid.orderx == feature.x) and (droid.ordery == feature.y))
				{
					boolResult = FALSE;
				}
			}
			droid = iterateGroup(buildGroup);
		}

		//Make sure there are no enemy units and defenses nearby
		if(boolResult)
		{
			temp = (13 * 128);
			count = 0;
			while((count < numEnemies) and (boolResult))
			{
				resetStructTargets();
				setStructTarPref(ST_DEF_GROUND);

				//if(numStructsByTypeInArea(Enemies[count], REF_DEFENSE, feature.x - temp, feature.y - temp, feature.x + temp, feature.y + temp) > 0)

				structure = structTargetInArea(Enemies[count], Enemies[count], feature.x - temp, feature.y - temp, feature.x + temp, feature.y + temp);
				if(structure != NULLOBJECT)
				{
					boolResult = FALSE;		//Too dangerous
				}
				else
				{
					resetDroidTargets();
					setDroidTarPref(DT_WEAP_GROUND);
					droid = droidTargetInArea(Enemies[count], Enemies[count], feature.x - temp, feature.y - temp, feature.x + temp, feature.y + temp);
					if(droid != NULLOBJECT)
					{
						boolResult = FALSE;		//Too dangerous
					}
				}
				
				count = count + 1;
			}
		}

		//Remember closest structure
		//--------------------------
		if(boolResult)		//If not trying to build already and no enemy defenses
		{
			result2 = distBetweenTwoPoints(baseX, baseY, feature.x, feature.y);		//How close to the base
			if(result2 < result)			//If closer
			{
				result = result2;
				feature2 = feature;			//Remember this oil resource
			}
		}

		feature = getFeature(player);
	}

	//Build oil derrick
	//-----------------
	if(feature2 != NULLOBJECT)
	{
		//Find closest truck
		//------------------
		tempDroid = NULLOBJECT;
		result = 99999;
		initIterateGroup(buildGroup);
		droid = iterateGroup(buildGroup);
		while(droid != NULLOBJECT)
		{
			if(droid.order == DORDER_NONE)
			{
				result2 = distBetweenTwoPoints(droid.x, droid.y, feature2.x, feature2.y);
				if(result2 < result)
				{
					result = result2;
					tempDroid = droid;
				}
			}
			droid = iterateGroup(buildGroup);
		}

		//Build derrick
		//-------------
		if(tempDroid != NULLOBJECT)
		{
			orderDroidStatsLoc(tempDroid, DORDER_BUILD,derrick, feature2.x, feature2.y);
		}
	}
}


//------------------------------------------------------
//	Send scouts to look for oil resources
//------------------------------------------------------
event sendScouts(sendScoutsTr)
{
	count = 0;
	temp = (43 * 128);		//Step

	while(count < maxScouts)
	{
		if(scoutGroup[count].members > 0)
		{
			if(idleGroup(scoutGroup[count]) > (scoutGroup[count].members /2))
			{
				if(count > 1)	//3rd scout vitits random places (only on big maps)
				{
					tempX = random(mapWidth) * 128;
					tempY = random(mapHeight) * 128;
					boolResult = pickStructLocation(vtolPad, ref tempX, ref tempY,player);
					if(boolResult == TRUE)
					{
						orderGroupLoc(scoutGroup[count], DORDER_MOVE, tempX, tempY);
					}
				}
				else		//Using a scouting algorithm for the first 2 scouts
				{
					//Send to scout before choosing new coords, so that
					//they would visit the initial (first) location
					//-------------------------------------------------
					tempX = scoutX[count];
					tempY = scoutY[count];
					boolResult = pickStructLocation(vtolPad, ref tempX, ref tempY,player);
					if(boolResult == TRUE)
					{
						orderGroupLoc(scoutGroup[count], DORDER_MOVE, tempX, tempY);
					}


					//Try 3 times to find a safe scouting location
					//--------------------------------------------
					boolResult = FALSE;
					result = 0;		//Number of times failed to find safe location
					while((result < 3) and (not boolResult))	//May fail max 3 times
					{
						if(count == 0)	//SCOUT1: From bottom left to the top
						{
							scoutY[count] = scoutY[count] - temp;	//Move up 1 step
							if(scoutY[count] < 512)			//If reached top
							{
								scoutY[count] = (128 * mapHeight) - (9 * 128);	//Back to bottom
								scoutX[count] = scoutX[count] + temp;		//Move right 1 step
							}

							if(scoutX[count] > (mapWidth * 128))	//If reached right border
							{
								scoutX[count] = (9 * 128);		//Start from the left
							}

						}
						else	//SCOUT2: From top right to the left
						{
							scoutX[count] = scoutX[count] - temp;	//Move left 1 step
							if(scoutX[count] < 512)			//If reached left border
							{
								scoutX[count] = (mapWidth * 128) - (9 * 128);		//Start from right
								scoutY[count] = scoutY[count] + temp;	//Move line down
							}

							if(scoutY[count] > (128 * mapHeight))		//If reached bottom
							{
								scoutY[count] = (9 * 128);		//Start from top
							}
						}


						//Check if new scouting location is safe
						//--------------------------------------
						count2 = 0;
						boolResult = TRUE;		//All ok right now (for max tries)
						while((count2 < numEnemies) and (boolResult))
						{
							if(objectInRange(Enemies[count2], scoutX[count],scoutY[count], 1280))	//10*128
							{
								boolResult = FALSE;		//This location failed this time
								result = result + 1;		//# of times safety check failed
							}
							count2 = count2 + 1;	//Next enemy
						}
					}
				}
			}
		}
		count = count + 1;
	}
}


//------------------------------------------------------
//	Build base
//------------------------------------------------------
event expandBase(inactive)
{
	//if(not powerSaving)
	//{
		if(extraStruct == numExtraStructs)	// loop round
		{
			extraStruct = 0;
		}

		//We have all vital structures, expand the base
		//---------------------------------------------
		boolResult = FALSE;
		if(isStructureAvailable(extraStructs[extraStruct],player))
		{
			buildX = baseX;
			buildY = baseY;

			//Don't try to build a second HQ
			//------------------------------
			boolResult2 = TRUE;
			if(extraStruct == 2)	//HQ
			{
				if(getStructure(extraStructs[2],player) != NULLOBJECT)
				{
					boolResult2 = FALSE;
				}
			}

			boolResult = FALSE;
			if(boolResult2)		//If not a second HQ
			{
				boolResult2 = pickStructLocation(extraStructs[extraStruct], ref buildX, ref buildY,player);
				if(boolResult2 == TRUE)
				{
					boolResult = TRUE;
				}
			}
		}

		if(boolResult)
		{
			result = 99999;
			tempDroid = NULLOBJECT;

			initIterateGroup(buildGroup);
			droid = iterateGroup(buildGroup);
			while(droid != NULLOBJECT)
			{
				if(droid.order == DORDER_NONE)
				{
					result2 = distBetweenTwoPoints(buildX, buildY, droid.x, droid.y);
					if(result2 < result)
					{
						result = result2;
						tempDroid = droid;
					}
				}
				droid = iterateGroup(buildGroup);
			}

			if(tempDroid != NULLOBJECT)
			{
				orderDroidStatsLoc(tempDroid, DORDER_BUILD,extraStructs[extraStruct], buildX,buildY);
			}
		}
		extraStruct = extraStruct + 1;		//Next structure
	//}
}


//------------------------------------------------------
//	Build base defenses
//------------------------------------------------------
event buildDefenses(inactive)
{
	if(not powerSaving)
	{
		count = numDefenses - 1;
		count2 = 0;
		boolResult = TRUE;
		while((boolResult == TRUE) and (count >= 0))
		{
			if(isStructureAvailable(defenses[count],player))
			{
				structChoice[0] = defenses[count];
				boolResult = FALSE;
			}
			count = count - 1;
		}

		if(boolResult == FALSE)
		{
			buildX = baseX;
			buildY = baseY;
			boolResult2 = pickStructLocation(powGen, ref buildX, ref buildY,player);
			if(boolResult2 == TRUE)
			{
				result = 99999;
				tempDroid = NULLOBJECT;

				initIterateGroup(buildGroup);
				droid = iterateGroup(buildGroup);
				while(droid != NULLOBJECT)		//Find truck who is near the oil resource
				{
					if(droid.order == DORDER_NONE)
					{
						result2 = distBetweenTwoPoints(buildX, buildY, droid.x, droid.y);
						if(result2 < result)
						{
							result = result2;
							tempDroid = droid;
						}
					}
					droid = iterateGroup(buildGroup);
				}

				if(tempDroid != NULLOBJECT)
				{
					orderDroidStatsLoc(tempDroid, DORDER_BUILD,structChoice[0], buildX,buildY);
				}
			}
		}
	}
}


//------------------------------------------------------
//	Build oil defenses
//------------------------------------------------------
event oilDefenses(inactive)
{
	if(not powerSaving)
	{
		temp = (4 * 128);		//Defenses range
		result = 99999;
		boolResult = TRUE;
		structure2 = NULLOBJECT;

		initEnumStruct(FALSE,derrick,player,player);
		structure = enumStruct();
		while(structure != NULLOBJECT)
		{
			result2 = distBetweenTwoPoints(baseX, baseY, structure.x, structure.y);
			if(result2 < result)
			{
				boolResult = TRUE;

				//If not within a base
				//--------------------
				if((structure.x > minx) and (structure.y > miny) and (structure.x < maxx) and (structure.y <maxy))
				{
					boolResult = FALSE;
				}

				//If not to many defenses already
				//-------------------------------
				if(boolResult == TRUE)
				{
					if(numStructsInArea(player, structure.x - temp, structure.y - temp, structure.x + temp, structure.y + temp) > 3)
					{
						boolResult = FALSE;
					}
				}

				//Choose best defense
				//-------------------
				if(boolResult == TRUE)
				{
					count = numDefenses - 1;
					boolResult = FALSE;
					while((count >= 0) and (boolResult == FALSE))
					{
						if(isStructureAvailable(defenses[count], player))
						{
							structChoice[0] = defenses[count];
							boolResult = TRUE;			//Stop
						}
						count = count - 1;
					}
				}

				if(boolResult == TRUE)
				{
					//If we have a derrick to defend
					//------------------------------
					boolResult = FALSE;
					result3 = 99999;
					tempDroid = NULLOBJECT;

					initIterateGroup(buildGroup);
					droid = iterateGroup(buildGroup);
					while(droid != NULLOBJECT)
					{
						if(droid.order == DORDER_NONE)
						{
							result4 = distBetweenTwoPoints(structure.x, structure.y, droid.x, droid.y);
							if(result4 < result3)
							{
								boolResult = TRUE;
								result3 = result4;
								tempDroid = droid;
							}
						}
						droid = iterateGroup(buildGroup);
					}
				}

				//If we have a droid
				//------------------
				if(boolResult == TRUE)
				{
					buildX = structure.x;
					buildY = structure.y;
					boolResult = pickStructLocation(structChoice[0], ref buildX, ref buildY,player);
					if(boolResult == TRUE)
					{
						boolResult = FALSE;
						if((buildX > structure.x - temp) and (buildY > structure.y - temp) and (buildX < structure.x + temp) and (buildY < structure.y + temp))		//If in the range
						{
							boolResult = TRUE;
						}
					}
				}

				if(boolResult == TRUE)
				{
					result = result2;
					structure2 = structure;
				}
			}
			structure = enumStruct();
		}

		//If we can build it now
		//----------------------
		if((structure2 != NULLOBJECT) and (tempDroid != NULLOBJECT))
		{
			orderDroidStatsLoc(tempDroid, DORDER_BUILD, structChoice[0], buildX, buildY);
		}
	}
}

//------------------------------------------------------
//	Keep details about the size and postion of the
//	ai players base
//------------------------------------------------------
event basedetails(basedetailsTr)
{
	// clear old extremities
	//----------------------
	maxy = 0;
	maxx = 0;
	miny = (mapHeight*128);
	minx = (mapWidth*128);

	//Now find the extremities of our vital structures
	//------------------------------------------------
	count = 0;
	while(count < numBaseStructs)
	{
		initEnumStruct(FALSE,baseStructs[count],player,player);					
		structure = enumStruct();
		while(structure != NULLOBJECT)	
		{
			if(structure.x < minx)
			{
				minx = structure.x;	// - 896;
			}
			if(structure.x > maxx)
			{
				maxx = structure.x;	// + 896;	
			}
			if(structure.y < miny)
			{
				miny = structure.y;	// - 896;
			}
			if(structure.y > maxy)
			{
				maxy = structure.y;	// + 896;
			}
			structure = enumStruct();
		}
		count = count + 1;
	}

	//Must be done here, after all structures are checked, otherwise
	//even if structure2.x < structure.x, (structure.x - minx) might be less and minx won't be set to
	//structure2.x, even if (structure2.x < structure.x), base won't expand enough
	//--------------------------------

	temp = 7;
	if(bigMap)
	{
		temp = 11 * 128;
	}

	minx = minx - temp;
	maxx = maxx + temp;
	miny = miny - temp;
	maxy = maxy + temp;

	//minx = minx - 896;
	//maxx = maxx + 896;
	//miny = miny - 896;
	//maxy = maxy + 896;

	//Check everything's within limits
	//--------------------------------
	if(minx < 0)
	{
		minx = 128;
	}
	if(miny < 0)
	{
		miny = 128;
	}
	if(maxx > (mapWidth * 128))
	{
		maxx = (mapWidth * 128) - 128;
	}
	if(maxy > (mapHeight * 128))
	{
		maxy = (mapHeight * 128) - 128;
	}
}


//==============================================================================================
//
//				[Other stuff important for all phases]
//
//==============================================================================================

//------------------------------------------------------
//	Keep track on the other players
//------------------------------------------------------
event keepTrack(keepTrackTr)
{
	numEnemies = 0;
	count = 0;
	while(count < 8)
	{
		allyPlayer[count] = FALSE;
		actPlayer[count] = FALSE;

		if(count != player)	//Not me
		{

			//Check if player has any structures (still alive)
			//------------------------------------------------
			boolResult = FALSE;
			count2 = 0;
			while((count2 < numBaseStructs) and (not boolResult))		//For all base structures
			{
				if(getStructure(baseStructs[count2],count) != NULLOBJECT)
				{
					boolResult = TRUE;
				}
				count2 = count2 + 1;
			}

			if(boolResult)		//If alive
			{
				actPlayer[count] = TRUE;

				//Not enemy
				if(allianceExistsBetween(player,count))
				{
					allyPlayer[count] = TRUE;
				}
				else	//Enemy
				{
					//Find enemy's base by finding its base structures
					Enemies[numEnemies] = count;	//Remember all enemies
					numEnemies = numEnemies + 1;
				}
			}

		}
		count = count + 1;
	}
}

//------------------------------------------------------
//	Deal with a droid being destroyed
//------------------------------------------------------
event droidDestroyed(droidDestroyedTr)
{
	count = 0;	//Do nothing

	//if(droid.droidType == DROID_CONSTRUCT)
	//{
	//	if(droid != outpostDroid)		//If wasn't outpost builder (will outpostDroid be NULLOBJECT already?)
	//	{
	//		numTrucks = numTrucks - 1;
	//	}
	//}
}


//------------------------------------------------------
// 	Build a power gen for every 4 derricks
//------------------------------------------------------
event buildPowerGenerators(buildPowerGeneratorsTr)
{
	count = 0;
	initEnumStruct(FALSE,derrick,player,player);	// count = numderricks
	structure = enumStruct();
	while(structure != NULLOBJECT)	
	{
		count = count + 1;
		structure = enumStruct();
	}

	count2 = 0;	
	initEnumStruct(FALSE,powGen,player,player);	// count2 = numpowgens
	structure= enumStruct();
	while(structure != NULLOBJECT)	
	{
		count2 = count2 + 1;
		structure= enumStruct();
	}
								
	if((count2 * 4) < count)			// if we need powergen
	{
		buildX = baseX;				// try build powergen
		buildY = baseY;
		boolResult = pickStructLocation(powGen, ref buildX, ref buildY,player);
		if(boolResult == TRUE)
		{
			result = 999999;
			tempDroid = NULLOBJECT;

			initIterateGroup(buildGroup);
			droid = iterateGroup(buildGroup);
			while(droid != NULLOBJECT)	//Find truck who is near the oil resource
			{
				if(droid.order == DORDER_NONE)
				{
					result2 = distBetweenTwoPoints(buildX, buildY, droid.x, droid.y);
					if(result2 < result)
					{
						result = result2;
						tempDroid = droid;
					}
				}
				droid = iterateGroup(buildGroup);
			}

			if(tempDroid != NULLOBJECT)
			{
				orderDroidStatsLoc(tempDroid, DORDER_BUILD,powGen, buildX,buildY);
			}
		}
	}
}


//------------------------------------------------------
//	Build trucks if necessary
//------------------------------------------------------
event LegoTrucks(LegoTrucksTr)
{
	initEnumStruct(FALSE,factory,player,player);
	structure = enumStruct();
	if((structure != NULLOBJECT) and (buildGroup.members < maxTrucks))
	{
		if(structureIdle(structure))
		{
			buildDroid(constructor, structure, player, 1);
		}
	}
}


//------------------------------------------------------
//	Deal with a droid being built
//------------------------------------------------------
event droidBuilt(droidBuiltTr)
{

	if(droid.droidType == DROID_CONSTRUCT)		// if constructor droid 
	{	
		groupAddDroid(buildGroup, droid);
	}
	else if((droid.droidType == DROID_CYBORG) or (droid.propulsion == cyborgProp))	//Cyborg or heavy cyborg
	{
		groupAddDroid(transportGr, droid);
	}
	else if(droid.droidType == DROID_TRANSPORTER)
	{
		//if(transportDroid == NULLOBJECT)
		//{
			transportDroid = droid;
			orderDroidLoc(transportDroid, DORDER_MOVE, baseX, baseY);
			//setDroidSecondary(transportDroid, DSO_ATTACK_LEVEL, DSS_ALEV_NEVER);
		//}
		
	}
	else
	{
		setDroidSecondary(droid, DSO_ATTACK_RANGE, DSS_ARANGE_LONG);

		if(isVtol(droid))
		{
			orderDroid(droid, DORDER_RTB);	//Move away

			//Check weapon
			count = 0;
			boolResult = FALSE;
			while((count < numSVtolTemplates) and (not boolResult))
			{
				if(droid.weapon == sVtolWeapon[count])
				{
					//setFogColour(1, 1, random(200) + 50);
					boolResult = TRUE;
					groupAddDroid(sVtolGr, droid);	//Antistructure
					//setFogColour(random(200) + 50, 1, 1);
				}
				count = count + 1;
			}

			//Antitank
			if(not boolResult)
			{
				groupAddDroid(tVtolGr, droid);
			}
		}
		else
		{
			boolResult = TRUE;
			setDroidSecondary(droid, DSO_ATTACK_RANGE, DSS_ARANGE_LONG);	//Was short

			//Repair unit
			//---------------------------
			if(droid.droidType == DROID_REPAIR)
			{
				setDroidSecondary(droid, DSO_REPAIR_LEVEL, DSS_REPLEV_NEVER);	//Perair units never repair

				if(repDefendDroid[0] == NULLOBJECT)
				{
					repDefendDroid[0] = droid;
					boolResult = FALSE;
				}
				else if(repDefendDroid[1] == NULLOBJECT)
				{
					repDefendDroid[1] = droid;
					boolResult = FALSE;
				}
			}

			//Scouts
			//---------------------------
			count = 0;
			while((count < maxScouts) and (boolResult))
			{
				if(scoutGroup[count].members == 0)
				{
					groupAddDroid(scoutGroup[count], droid);
					boolResult = FALSE;
				}
				count = count + 1;
			}

			//Random scout (#3)
			if(boolResult)
			{
				if(scoutGroup[2].members == 0)
				{
					if(((attackGroup.members + sendOutpostGr.members) > numRushers) and (defendGr.members >= maxDefenders))
					{
						groupAddDroid(scoutGroup[2], droid);
						boolResult = FALSE;
					}
				}
			}


			//Defenders
			//---------------------------
			if(boolResult)
			{
				//if((attackPhase > 0) or (alreadyAttacked))	//Send to attack for the first time or not attacking right now, but attacked before (attackState=0, but alreadyAttacked)
				if(alreadyAttacked)		//Already sent units to the outpost
				{
					if(((attackGroup.members > numRushers) and (defendGr.members < maxDefenders)) or (defendGr.members < 7) or (defendingBase))
					{
						if(defendGr.members < maxDefenders)
						{
							groupAddDroid(defendGr, droid);
							boolResult = FALSE;
						}
					}
				}
			}


			//Defenders
			//---------------------------
			//if(boolResult and ((attackGroup.members >= numRushers) or ((attackPhase > 0) and (defendGr.members < 5))))	//If already many rushers or (have already rushed and not enough defenders)
			//{
			//	if(defendGr.members < maxDefenders)
			//	{
			//		if(mainPhase > 0)
			//		{
			//			groupAddDroid(defendGr, droid);
			//			boolResult = FALSE;
			//		}
			//	}
			//}


			//Oil
			//---------------------------
			if(boolResult and (attackGroup.members > numRushers))
			{
				if(oilGr.members < maxOilGr)
				{
					groupAddDroid(oilGr, droid);
					boolResult = FALSE;
				}
			}

			//Attackers
			//---------------------------
			if(boolResult)
			{
				groupAddDroid(collectSendGr, droid);
				boolResult = FALSE;
				//groupAddDroid(sendOutpostGr, droid);
			}

			//Increase number of defenders
			//----------------------------
			if(attackGroup.members > numRushers)
			{
				if((defendGr.members >= maxDefenders) and (maxDefenders < 14) and (alreadyAttacked))	//(attackPhase > 0): if we have already enough attackers and started attacking
				{
					maxDefenders = maxDefenders + 1;
				}
			}
		}
	}
}


//------------------------------------------------------
//	Cheat a bit, like Pumpkin AI, not more
//------------------------------------------------------
event difficultyMod(difficultyModTr)
{
	skDifficultyModifier(player);
	randomiseSeed();		//Will not hurt if done once in a while
}


//------------------------------------------------------
//	Upgrade structures
//------------------------------------------------------
event upgradeStructures(upgradeStructuresTr)
{

	//Find closest truck
	//-------------------
	tempX = baseX;
	tempY = baseY;
	result = 999999;
	tempDroid = NULLOBJECT;
	boolResult = TRUE;

	initIterateGroup(buildGroup);
	droid = iterateGroup(buildGroup);
	while(droid != NULLOBJECT)
	{
		if(droid.order == DORDER_NONE)
		{
			result2 = distBetweenTwoPoints(tempX, tempY, droid.x, droid.y);
			if(result2 < result)
			{
				result = result2;
				tempDroid = droid;
			}
		}
		droid = iterateGroup(buildGroup);
	}

	//------------------
	//	Factory
	//-----------------
	initEnumStruct(FALSE,factory,player,player);
	structure= enumStruct();
	while(structure != NULLOBJECT)	
	{
		if(structureComplete(structure))
		{
			if(isStructureAvailable(facModule,player) and (skGetFactoryCapacity(structure) < 2 ))			
			{
				if((attackPhase > 0) or (skCanBuildTemplate(player,structure, tmpl[0][8])))	//Don't upgrade while preparing the first rush or upgrade if it's necessary to be able to build units in T3
				{
					if(tempDroid != NULLOBJECT)
					{
						boolResult = FALSE;
						orderDroidStatsLoc(tempDroid, DORDER_BUILD,facModule, structure.x,structure.y);
					}
				}
			}
		}
		structure= enumStruct();
	}

	//------------------
	//	Powergen
	//------------------
	initEnumStruct(FALSE,powGen,player,player);
	structure= enumStruct();
	while(structure != NULLOBJECT)
	{
		if(structureComplete(structure))
		{
			if(isStructureAvailable(powModule,player) and (not testStructureModule(player, structure, 0)))			
			{
				if((tempDroid != NULLOBJECT) and (boolResult == TRUE))
				{
					boolResult = FALSE;
					orderDroidStatsLoc(tempDroid,DORDER_BUILD,powModule, structure.x,structure.y);	//Upgrade it.
				}
			}
		}
		structure= enumStruct();
	}

	//-----------------
	//	Research
	//-----------------
	if(not powerSaving)
	{
		initEnumStruct(FALSE,resLab,player,player);
		structure= enumStruct();
		while(structure != NULLOBJECT)	
		{
			if(structureComplete(structure))
			{
				if( isStructureAvailable(resModule,player) and (not testStructureModule(player, structure, 0)))			
				{
					if((tempDroid != NULLOBJECT) and (boolResult == TRUE))
					{
						boolResult = FALSE;
						orderDroidStatsLoc(tempDroid, DORDER_BUILD,resModule, structure.x,structure.y);
					}
				}
			}
			structure= enumStruct();
		}

		//-------------------
		//	VTOL Factory
		//-------------------
		if(not powerSaving)
		{
			initEnumStruct(FALSE,vtolFactory,player,player);
			structure= enumStruct();
			while(structure != NULLOBJECT)	
			{
				if(structureComplete(structure))
				{
					if(isStructureAvailable(facModule,player) and (skGetFactoryCapacity(structure) < 2 ))			
					{
						if((tempDroid != NULLOBJECT) and (boolResult == TRUE))
						{
							boolResult = FALSE;
						orderDroidStatsLoc(tempDroid, DORDER_BUILD,facModule, structure.x,structure.y);
						}	
					}
				}
				structure = enumStruct();
			}
		}
	}
}


//------------------------------------------------------
//	Run for a bit when attacked
//------------------------------------------------------
event moveIfAttacked(moveIfAttackedTr)
{
	//If unit is still alive and is still under attack
	if((droid != NULLOBJECT) and (baseobj != NULLOBJECT))
	{
		//If during the attack
		//if(attackPhase >= 2)
		//{
		//	if(groupMember(attackGroup, droid))
		//	{
		//		if(distBetweenTwoPoints(curEnemyX, curEnemyY, baseobj.x, baseobj.y) < (KeepDist / 2))
		//		{
		//			if(losTwoObjects(droid, baseobj, TRUE))		//Only if we can see the enemy (get out of his range)
		//			{
		//				orderDroidLoc(droid, DORDER_MOVE, curEnEdgeX, curEnEdgeY);	//Retreat
		//			}
		//		}
		//	}
		//}

		if(baseobj.player != player)	//Not attacking itself by an accident or with a mass-weapon
		{

			boolResult = TRUE;
			if(baseobj.type == OBJ_DROID)
			{
				if(isVtol(objToDroid(baseobj)))
				{
					boolResult = FALSE;		//Attacked by a VTOL
				}
			}

			if(droid.type == OBJ_DROID)
			{
				if(isVtol(objToDroid(droid)))
				{
					boolResult = FALSE;		//VTOL was attacked
				}
			}

			//If we have a weapon, then answer
			//--------------------------------
			if(boolResult)		//If a land unit or a defense
			{
				if(droid.droidType == DROID_WEAPON)		//Has a weapon
				{
					if(droid.order == DORDER_NONE)	//Not already attacking
					{
						if(losTwoObjects(droid, baseobj, TRUE))		//If we can see attacker
						{
							//orderDroidObj(droid, DORDER_ATTACK, baseobj);
							orderDroidLoc(droid, DORDER_SCOUT, baseobj.x, baseobj.y);
						}
					}
				}

				//Help a friend if we are near
				//----------------------------
				if(groupMember(attackGroup, droid))
				{
					temp = (7 * 128);
					initIterateGroup(attackGroup);
					tempDroid = iterateGroup(attackGroup);
					while(tempDroid != NULLOBJECT)
					{
						if(tempDroid.order == DORDER_NONE)
						{
							if(distBetweenTwoPoints(tempDroid.x, tempDroid.y, droid.x, droid.y) < temp)
							{
								//if(losTwoObjects(tempDroid, baseobj, TRUE))		//If we can see attacker
								//{
									//orderDroidObj(tempDroid, DORDER_ATTACK, baseobj);
									orderDroidLoc(tempDroid, DORDER_SCOUT, baseobj.x, baseobj.y);
								//}
							}
						}
						tempDroid = iterateGroup(attackGroup);
					}
				}
			}

			//Vtols and trucks run away
			//-------------------------
			if((droid.droidType == DROID_CONSTRUCT) or (isVtol(droid)))	//If a constructor or a VTOL
			{
				if(droid.order == DORDER_NONE)
				{
					temp = (3 * 128);
					temp = random(temp * 2) - temp;
					orderDroidLoc(droid, DORDER_MOVE, droid.x + temp, droid.y + temp);
				}
			}
		}
	}
}

//---------------------------------------------------------------
//	Build an outpost to retreat to and to repair damaged units
//---------------------------------------------------------------
event BuildOutpost(inactive)
{
	//Find trucks to build the outpost
	//--------------------------------
	count2 = (KeepDist / 2);
	
	//Reduce number of defenses temporary if low on power
	temp = 6;
	if(powerSaving)
	{
		temp = 2;
	}

	if(outpostDroid == NULLOBJECT)
	{
		if(not defendingBase)		//Need trucks for base rebuilding now
		{
			initIterateGroup(buildGroup);
			droid = iterateGroup(buildGroup);
			while((droid != NULLOBJECT) and (outpostDroid == NULLOBJECT))
			{
				if(droid.order == DORDER_NONE)
				{
					droidLeaveGroup(droid);
					outpostDroid = droid;
					orderDroidLoc(outpostDroid, DORDER_MOVE, curEnEdgeX, curEnEdgeY);
				}
				droid = iterateGroup(buildGroup);
			}
		}
	}

	//--------------------------------------------------------
	//Check if we have all necessary structures in the outpost
	//--------------------------------------------------------
	if((outpostDroid != NULLOBJECT) and (curEnEdgeX > 0) and (not defendingBase))	//If we have trucks, have outpost coords and don't need money for the base
	{
		boolResult = TRUE;

		//-------------------------
		//Remove old rep facilities
		//-------------------------
		initEnumStruct(FALSE,repairFacility,player,player);
		structure = enumStruct();
		while(structure != NULLOBJECT)
		{
			//Demolish if outside of the new edge
			if(distBetweenTwoPoints(curEnEdgeX, curEnEdgeY, structure.x, structure.y) > count2)
			{
				if((outpostDroid.order == DORDER_NONE) or (outpostDroid.order == DORDER_MOVE))	//Not busy
				{
					orderDroidObj(outpostDroid, DORDER_DEMOLISH, structure);
				}
			}
			structure = enumStruct();
		}

		//-----------------------
		//Check repair facilities
		//-----------------------
		result = numStructsByTypeInArea(player, REF_REPAIR_FACILITY, curEnEdgeX - count2, curEnEdgeY - count2, curEnEdgeX + count2, curEnEdgeY + count2);
		if(result < 1)		//We need repair facilities
		{
			boolResult = FALSE;		//Not done building outpost yet

			buildX = curEnEdgeX;		//Outpost coords = build coords
			buildY = curEnEdgeY;
			boolResult2 = pickStructLocation(repairFacility, ref buildX, ref buildY, player);
			if(boolResult2 == TRUE)		//If we can build
			{
				//Not outside of the outpost
				//--------------------------
				if(distBetweenTwoPoints(curEnEdgeX, curEnEdgeY, buildX, buildY) < count2)
				{
					if((outpostDroid.order == DORDER_NONE) or (outpostDroid.order == DORDER_MOVE))	//Not busy
					{
						orderDroidStatsLoc(outpostDroid, DORDER_BUILD, repairFacility, buildX,buildY);
					}
				}
			}
		}

		//---------------------------------------------------
		//Build some defenses in the outpost if we are idling
		//---------------------------------------------------
		if(outpostDroid.order == DORDER_NONE)	//Not busy
		{
			//Count defenses
			//--------------
			result = 0;
			count = 0;
			while(count < numDefenses)
			{
				initEnumStruct(FALSE,defenses[count],player,player);
				structure = enumStruct();
				while(structure != NULLOBJECT)
				{
					if(distBetweenTwoPoints(structure.x, structure.y, curEnEdgeX, curEnEdgeY) < count2)		//In the outpost
					{
						result = result + 1;
					}
					structure = enumStruct();
				}
				count = count + 1;
			}

			//if(numStructsInArea(player, curEnEdgeX - count2, curEnEdgeY - count2, curEnEdgeX + count2, curEnEdgeY + count2) < count)
			if(result < temp)
			{
				//Choose best defense
				//-------------------
				count = numDefenses - 1;
				boolResult = FALSE;
				while((count >= 0) and (boolResult == FALSE))
				{
					if(isStructureAvailable(defenses[count], player))
					{
						structChoice[0] = defenses[count];
						boolResult = TRUE;			//Stop
					}
					count = count - 1;
				}

				if(boolResult == TRUE)		//If we have a defense we can build
				{
					buildX = curEnEdgeX;
					buildY = curEnEdgeY;
					boolResult = pickStructLocation(powGen, ref buildX, ref buildY, player);
					if(boolResult == TRUE)
					{
						if(distBetweenTwoPoints(buildX, buildY, curEnEdgeX, curEnEdgeY) < count2)
						{
							orderDroidStatsLoc(outpostDroid, DORDER_BUILD, structChoice[0], buildX, buildY);
						}
					}
				}
			}
		}

		//---------------
		//Build some arty
		//---------------
		if(outpostDroid.order == DORDER_NONE)
		{
			//Arty
			if(numStructsByTypeInArea(player, REF_DEFENSE, curEnEdgeX - count2, curEnEdgeY - count2, curEnEdgeX + count2, curEnEdgeY + count2) < (temp + 6))	//Max 5 arty def
			{
				//Check if we have arty tech available
				count = 1;
				boolResult = FALSE;
				while((count >= 0) and (boolResult == FALSE))
				{
					if(isStructureAvailable(arty[count], player))
					{
						structChoice[0] = arty[count];
						boolResult = TRUE;			//Stop
					}
					count = count - 1;
				}

				if(boolResult == TRUE)		//If we have arty tech
				{
					buildX = curEnEdgeX;
					buildY = curEnEdgeY;
					boolResult = pickStructLocation(powGen, ref buildX, ref buildY, player);
					if(boolResult == TRUE)
					{
						if(distBetweenTwoPoints(buildX, buildY, curEnEdgeX, curEnEdgeY) < count2)
						{
							orderDroidStatsLoc(outpostDroid, DORDER_BUILD, structChoice[0], buildX, buildY);
						}
					}
				}
			}

			//-------
			//Sensors
			//-------

			//Count sensors
			//-------------
			result = 0;
			count = 0;
			while(count < 2)
			{
				initEnumStruct(FALSE,sens[count],player,player);
				structure = enumStruct();
				while(structure != NULLOBJECT)
				{
					if(distBetweenTwoPoints(structure.x, structure.y, curEnEdgeX, curEnEdgeY) < count2)		//In the outpost
					{
						result = result + 1;
					}
					structure = enumStruct();
				}
				count = count + 1;
			}

			if(result == 0)
			{
				//Check if we have sensor tech available
				count = 1;
				boolResult = FALSE;
				while((count >= 0) and (boolResult == FALSE))
				{
					if(isStructureAvailable(sens[count], player))
					{
						structChoice[0] = sens[count];
						boolResult = TRUE;			//Stop
					}
					count = count - 1;
				}

				if(boolResult == TRUE)		//If we have sensor tech available
				{
					buildX = curEnEdgeX;
					buildY = curEnEdgeY;
					boolResult = pickStructLocation(powGen, ref buildX, ref buildY, player);
					if(boolResult == TRUE)
					{
						if(distBetweenTwoPoints(buildX, buildY, curEnEdgeX, curEnEdgeY) < count2)
						{
							orderDroidStatsLoc(outpostDroid, DORDER_BUILD, structChoice[0], buildX, buildY);
						}
					}
				}
			}
		}
	}
}

//-------------------------------------------------------------
//	Check for some important details we need for the script
//-------------------------------------------------------------
event updateDetails(updateDetailsTr)
{
	//Decide wheather to drop or not
	//----------------------------------------------------
	if(not dropEnabled)
	{
		if((alreadyAttacked and (playerPower(player) > 500)) or (playerPower(player) > muchoPower))		//Started attacking and enough power
		{
			dropEnabled = TRUE;
		}
	}

	//----------------------------------------------------
	//Count how many attackers are repairing at the moment
	//----------------------------------------------------
	//numRepairing = 0;
	//initIterateGroup(attackGroup);
	//droid = iterateGroup(attackGroup);
	//while(droid != NULLOBJECT)
	//{
	//	if(droid.order == DORDER_RTR)
	//	{
	//		numRepairing = numRepairing + 1;
	//	}
	//	droid = iterateGroup(attackGroup);
	//}

	//------------------------------------------
	//Check if we have an outpost and can repair
	//------------------------------------------
	haveOutpost = FALSE;
	if(curEnEdgeX > 0)
	{
		//Find rep facilities
		//-------------------
		count2 = (KeepDist / 2);
		if(numStructsByTypeInArea(player, REF_REPAIR_FACILITY, curEnEdgeX - count2, curEnEdgeY - count2, curEnEdgeX + count2, curEnEdgeY + count2) > 0)
		{
			haveOutpost = TRUE;
		}
	}

	//Decide how many templates tochoose from
	//---------------------------------------
	structure = getStructure(factory,player);
	if(structure != NULLOBJECT)
	{
		temp = 0;
		TemplDepth = 1;
		if(playerPower(player) > muchoPower)
		{
			temp = 1;
		}

		if(skCanBuildTemplate(player,structure, tmpl[0][8]))	//If we have Trck Python HC
		{
			if(mainPhase == 1)		//If set to 2 too early, then some stuff will not be activated at startup
			{
				mainPhase = 2;
			}
		}

		if(skCanBuildTemplate(player,structure, tmpl[temp][10]))		//If we have A-Mantis-Trk-Lancer then start using 3 templates
		{
			TemplDepth = 3;
		}
		else if(skCanBuildTemplate(player,structure, tmpl[temp][9]))	//If we have A-Python-Trk-Lancer then use A-Python-Trk-Lancer and A-Python-Trk-HC
		{
			TemplDepth = 2;
		}

	}

	//Remember the best cyborg template available
	//-------------------------------------------
	structure = getStructure(cybFactory, player);
	if(structure != NULLOBJECT)
	{
		count = 1;		//numTemplates - 1
		boolResult = TRUE;
		while((count >= 0) and (boolResult))
		{
			if(skCanBuildTemplate(player,structure, cybTmpl[count]) )
			{
				cybTemplate = count;
				boolResult = FALSE;
			}
			count = count - 1;
		}
	}
}

//----------------------------------------
//Power saving
//----------------------------------------
event savePower(inactive)
{
	//------------
	//Power saving
	//------------
	powerSaving = FALSE;
	if((playerPower(player) < 100) or (defendingBase))		//Low on power or need power for fast unit production
	{
		powerSaving = TRUE;
	}
}

//----------------------------------------
//Repair damaged droids using repair units
//----------------------------------------
event repairStuff(repairStuffTr)
{
	//------------------------
	//Defenders
	//------------------------
	result = 2;	//Total number of (repDefendDroid - 1)
	count = 0;	//Current repair unit index
	while(count < result)
	{
		if(repDefendDroid[count] != NULLOBJECT)		//If this repairer exists
		{
			boolResult = FALSE;				//Assume it's still busy right now
			if(toRepDefendDroid[count] == NULLOBJECT)		//Nothing to repair
			{
				boolResult = TRUE;				//Not busy, find a unit to repair
			}
			else					//Damaged unit still exists
			{
				if(toRepDefendDroid[count].health > 95)		//Already repaired
				{
					boolResult = TRUE;			//Find another unit
					toRepDefendDroid[count] = NULLOBJECT;	//'Forget' this unit
				}
			}

			//-------------------
			//Find a damaged unit
			//-------------------
			if(boolResult)					//Have nothing to repair
			{
				initIterateGroup(defendGr);
				droid = iterateGroup(defendGr);
				boolResult = TRUE;
				while((droid != NULLOBJECT) and (boolResult))
				{
					if(droid.health < 90)			//Needs repair
					{
						boolResult = FALSE;		//Busy now, found a unit to repair

						//Make sure this unit is not already get repaired by the second repairer
						//----------------------------------------------------------------------
						if(count == 0)	//For the first repairer
						{
							if(droid == toRepDefendDroid[1])	//If already get repaired
							{
								boolResult = TRUE;	//Don't take this unit
							}
						}
						else if(count == 1)
						{
							if(droid == toRepDefendDroid[0])	//If already get repaired
							{
								boolResult = TRUE;	//Don't take this unit
							}
						}

						if(not boolResult)	//If we did decide to choose this unit for repairing
						{
							toRepDefendDroid[count] = droid;	//Choose it
						}
					}
					droid = iterateGroup(defendGr);
				}

				//---------------------------------------------------------
				//If nothing to repair so far, repair the other repair unit
				//---------------------------------------------------------
				if(boolResult)		//Nothing to repair
				{
					if(count == 0)	//For the first rep unit
					{
						if(repDefendDroid[1] != NULLOBJECT)	//2nd repair unit exists
						{
							if(repDefendDroid[1].health < 90)	//Needs repair
							{
								boolResult = FALSE;			//Busy now
								toRepDefendDroid[count] = repDefendDroid[1];	//Repair it
							}
						}
					}
					else if(count == 1)
					{
						if(repDefendDroid[0] != NULLOBJECT)	//1st repair unit exists
						{
							if(repDefendDroid[0].health < 90)	//Needs repair
							{
								boolResult = FALSE;			//Busy now
								toRepDefendDroid[count] = repDefendDroid[0];	//Repair it
							}
						}
					}
					
				}

				//---------------------------------------------------------
				//If found something to repair, then get closer to the unit
				//---------------------------------------------------------
				if(not boolResult)		//Busy
				{
					if(distBetweenTwoPoints(toRepDefendDroid[count].x, toRepDefendDroid[count].y, repDefendDroid[count].x, repDefendDroid[count].y) > 256)	//If too far away from the damaged unit
					{
						tempX = 128;
						tempY = 128;
						if(repDefendDroid[count].x < toRepDefendDroid[count].x)		//Don't make the unit get out of the way, stop near it
						{
							tempX = -128;
						}

						if(repDefendDroid[count].y < toRepDefendDroid[count].y)
						{
							tempY = -128;
						}
					
						orderDroidLoc(repDefendDroid[count], DORDER_MOVE, toRepDefendDroid[count].x + tempX, toRepDefendDroid[count].y + tempY);
					}
				}
				else	//If still idle, then move closer to the defend group
				{
					tempX = defendGr.x;
					tempY = defendGr.y;

					if(distBetweenTwoPoints(tempX, tempY, repDefendDroid[count].x, repDefendDroid[count].y) > 1024)	//Too far away from defenders
					{
						orderDroidLoc(repDefendDroid[count], DORDER_MOVE, tempX, tempY);	//Move closer to the group
						boolResult = FALSE;
					}
				}
			}
			else if(toRepDefendDroid[count] != NULLOBJECT)		//Has something to repair and not going to repair it
			{
				if(repDefendDroid[count].order == DORDER_NONE)	//Idle
				{
					if(distBetweenTwoPoints(repDefendDroid[count].x, repDefendDroid[count].y, toRepDefendDroid[count].x, toRepDefendDroid[count].y) > (3 * 128))
					{
						orderDroidLoc(repDefendDroid[count], DORDER_MOVE, toRepDefendDroid[count].x, toRepDefendDroid[count].y);
					}
				}
			}
		}
		count = count + 1;
	}


/*
	//------------------------
	//Attackers
	//------------------------
	if(repAttackDroid != NULLOBJECT)
	{
		if(repAttackDroid.order == DORDER_NONE)			//Not busy
		{
			initIterateGroup(attackGroup);
			droid = iterateGroup(attackGroup);
			boolResult = TRUE;				//Send only 1 truck
			while((droid != NULLOBJECT) and (boolResult))
			{
				if(droid.health < 90)			//Needs repair
				{
					if(distBetweenTwoPoints(droid.x, droid.y, repAttackDroid.x, repAttackDroid.y) > 256)
					{
						boolResult = FALSE;
						tempX = 128;
						tempY = 128;
						if(repAttackDroid.x < droid.x)		//Don't make the unit get out of the way, stop near it
						{
							tempX = -128;
						}

						if(repAttackDroid.y < droid.y)
						{
							tempY = -128;
						}
					
						orderDroidLoc(repAttackDroid, DORDER_MOVE, droid.x + tempX, droid.y + tempY);
					}
				}
				droid = iterateGroup(attackGroup);
			}

			tempX = attackGroup.x;
			tempY = attackGroup.y;
			if(not boolResult)
			{
				if(distBetweenTwoPoints(tempX, tempY, repAttackDroid.x, repAttackDroid.y) > 512)	//(6 * 128)
				{
					orderDroidLoc(repDefendDroid, DORDER_MOVE, tempX, tempY);	//Move closer to the group
				}
			}
		}
	}
*/

	//-----------------------
	//Base structures
	//-----------------------
	structure2 = NULLOBJECT;
	initEnumStruct(TRUE,derrick,player,player);		//TRUE: iterate through all structures
	structure = enumStruct();
	while((structure != NULLOBJECT) and (structure2 == NULLOBJECT))
	{
		//if(not structureComplete(structure))		//If structure not finished
		//{
			if(structure.health < 90)
			{
				if((structure.x < maxx) and (structure.x > minx))	//Only base structures
				{
					if((structure.y < maxy) and (structure.y > miny))
					{
						structure2 = structure;
					}
				}
			}
		//}
		structure = enumStruct();
	}

	if(structure2 != NULLOBJECT)
	{
		boolResult = TRUE;
		result = 0;
		tempDroid = NULLOBJECT;

		temp = 45 * 128;
		initIterateGroup(buildGroup);
		droid = iterateGroup(buildGroup);
		while((droid != NULLOBJECT) and (boolResult))
		{
			if(droid.order == DORDER_NONE)	//Make sure there's only one droid repairing at a time
			{
				if(distBetweenTwoPoints(droid.x, droid.y, structure2.x, structure2.y) < temp)	//Not too far away
				{
					tempDroid = droid;
					boolResult = FALSE;		//We found our droid, make iteration stop here
				}
			}
			else		//Max 2 trucks repairing the same structure
			{
				if(droid.order == DORDER_REPAIR)	//If somebody is already repairing something
				{
					if((droid.orderx == structure2.x) and (droid.ordery == structure2.y))
					{
						tempDroid = NULLOBJECT;
						boolResult = FALSE;		//Stop iteration
					}
				}
			}
			droid = iterateGroup(buildGroup);
		}

		if(tempDroid != NULLOBJECT)		//Droid found and nobody already repairing
		{
			orderDroidObj(tempDroid, DORDER_REPAIR, structure2);		//Repair
		}
	}

}

//------------------------------------
//	Units stuck, do something!
//------------------------------------
event stuck(stuckTr)
{
	//Most of them have an order
	if((attackGroup.members > 0) and (idleGroup(attackGroup) < (attackGroup.members / 2)))
	{
		//If we moved
		temp = (7 * 128);

		if(repGr.members > 0)		//Have repGr
		{
			tempX = (attackGroup.x + repGr.x) / 2;		//Attack and rep group stuck often,
			tempY = (attackGroup.y + repGr.y) / 2;		//so use the middle value of the 2 groups
		}
		else
		{
			tempX = attackGroup.x;	
			tempY = attackGroup.y;
		}


		if(distBetweenTwoPoints(tempX, tempY, stuckX, stuckY) > temp)		//Moved
		{
			stuckTimes = 0;
			stuckX = tempX;		//Store new coordinates
			stuckY = tempY;	
		}			//Reset
		else
		{
			stuckTimes = stuckTimes + 1;
		}

		result = 35;
		result2 = result + 15;

		//If they are really stuck
		if((stuckTimes > result) and (stuckTimes < result2))
		{
			showConsoleText(DebugMsg[9], player);		//STUCK: Running a bit

			//count = 0;
			//while(count < 5)
			//{
				//Run a bit
				initIterateGroup(attackGroup);
				droid = iterateGroup(attackGroup);
				while(droid != NULLOBJECT)
				{
					orderDroid(droid, DORDER_RUN);
					droid = iterateGroup(attackGroup);
				}

				//Run a bit
				initIterateGroup(sendOutpostGr);
				droid = iterateGroup(sendOutpostGr);
				while(droid != NULLOBJECT)
				{
					orderDroid(droid, DORDER_RUN);
					droid = iterateGroup(sendOutpostGr);
				}

				//Run a bit
				initIterateGroup(repGr);
				droid = iterateGroup(repGr);
				while(droid != NULLOBJECT)
				{
					orderDroid(droid, DORDER_RUN);
					droid = iterateGroup(repGr);
				}
			//	count = count + 1;
			//}
		}
		else if(stuckTimes >= result2)
		{
			showConsoleText(DebugMsg[10], player);		//STUCK: Removing obstacles

			//Wipe out any structure near the group or some units if there are no structures
			resetStructTargets();
			result = (5 * 128);
			structure = structTargetInArea(player, player, tempX - result, tempY - result, tempX + result, tempY + result);
			if(structure == NULLOBJECT)
			{
				setStructTarPref(ST_WALL);
				structure = structTargetInArea(player, player, tempX - result, tempY - result, tempX + result, tempY + result);
			}

			if(structure != NULLOBJECT)
			{
				orderGroupObj(attackGroup, DORDER_ATTACK, structure);
			}
			else
			{
				resetDroidTargets();
				tempDroid = droidTargetInArea(player, player, tempX - result, tempY - result, tempX + result, tempY + result);
				if(tempDroid != NULLOBJECT)
				{
					orderGroupObj(attackGroup, DORDER_ATTACK, tempDroid);
				}
			}
		}
		else if(stuckTimes > (result2 + 20))	//Destroy 20 objects, then reset
		{
			stuckTimes = 0;			//Try to get out now
		}
	}
}

//=============================================================================================
//							VTOLs
//=============================================================================================
//---------------------
//	Build rearm pads
//---------------------
event buildVtolPads(inactive)
{
	if(getStructure(vtolFactory,player) != NULLOBJECT)	//If we have VTOL factory
	{
		if(alreadyAttacked and (not powerSaving))	//If we already have built an attack force
		{
			//Count rearm pads
			//----------------
			initEnumStruct(FALSE,vtolPad,player,player);
			structure= enumStruct();
			count	 = 0;
			while(structure != NULLOBJECT)
			{
				count = count + 1;
				structure= enumStruct();
			}

			//Do we have enough rearm pads?
			//-----------------------------
			if(count < ((maxTVtols + maxSVtols) / 2))
			{
				//Find nearest truck
				//------------------
				buildX = baseX;
				buildY = baseY;
				result = 99999;
				tempDroid = NULLOBJECT;
				initIterateGroup(buildGroup);
				droid = iterateGroup(buildGroup);
				while(droid != NULLOBJECT)
				{
					if(droid.order == DORDER_NONE)
					{
						result2 = distBetweenTwoPoints(buildX, buildY, droid.x, droid.y);
						if(result2 < result)
						{
							result = result2;
							tempDroid = droid;
						}
					}
					droid = iterateGroup(buildGroup);
				}

				//Build vtol rearm pads
				//---------------------
				boolResult = pickStructLocation(vtolPad, ref buildX, ref buildY,player);
				if((boolResult == TRUE) and (tempDroid != NULLOBJECT))
				{
					orderDroidStatsLoc(tempDroid, DORDER_BUILD, vtolPad, buildX, buildY);
				}
			}
		}
	}
	else if((not powerSaving) and (alreadyAttacked))	//Build VTOL Factory
	{
		if(isStructureAvailable(vtolFactory,player))
		{
			//Find nearest truck
			//------------------
			buildX = baseX;
			buildY = baseY;
			result = 99999;
			tempDroid = NULLOBJECT;
			initIterateGroup(buildGroup);
			droid = iterateGroup(buildGroup);
			while(droid != NULLOBJECT)
			{
				if(droid.order == DORDER_NONE)
				{
					result2 = distBetweenTwoPoints(buildX, buildY, droid.x, droid.y);
					if(result2 < result)
					{
						result = result2;
						tempDroid = droid;
					}
				}
				droid = iterateGroup(buildGroup);
			}

			//Build VTOL Facrory
			//------------------
			boolResult = pickStructLocation(vtolFactory, ref buildX, ref buildY,player);
			if((boolResult == TRUE) and (tempDroid != NULLOBJECT))
			{
				orderDroidStatsLoc(tempDroid, DORDER_BUILD, vtolFactory, buildX, buildY);
			}
		}
	}
}

//----------------------
//	Build VTOLs
//----------------------
event buildVtols(buildVtolsTr)
{
	structure = getStructure(vtolPad,player);			//Got vtol pads?
	if((structure != NULLOBJECT) and (alreadyAttacked) and (not powerSaving))	//Got pads and already have an attack force					
	{
		structure = getStructure(vtolFactory,player);
		if(structure != NULLOBJECT)
		{
			//Check if we can afford heavy templates
			//--------------------------------------
			temp = 0;			//Light templates
			if(playerPower(player) > muchoPower)
			{
				temp = 1;		//Use heavy, expensive templates, if can afford it
			}

			//Check if we have any antitank template
			//--------------------------------------
			boolResult = FALSE;
			count = numTVtolTemplates - 1;
			count2 = 0;
			while((count >= 0) and (boolResult == FALSE))
			{
				if(skCanBuildTemplate(player,structure, tVtols[temp][count]))
				{
					boolResult = TRUE;
				}
				count = count - 1;
			}

			//Check if we have any antistructure template
			//-------------------------------------------
			boolResult2 = FALSE;
			count = numSVtolTemplates - 1;
			count2 = 0;
			while((count >= 0) and (not boolResult2))
			{
				if(skCanBuildTemplate(player,structure, sVtols[temp][count]) )
				{
					boolResult2 = TRUE;
				}
				count = count - 1;
			}

			//Build Cyborg Transport
			//-------------------------------------
			result = 0;
			if((transportDroid == NULLOBJECT) and (dropEnabled) and (transportGr.members > 7))
			{
				result = 3;
			}
			else
			{
				//Decide for which group to build VTOLs
				//-------------------------------------
				if((tVtolGr.members < maxTVtols) and ((tVtolGr.members <= sVtolGr.members) or (not boolResult2)))
				{
					result = 1;	//tVtolGr
				}
				//else if((sVtolGr.members < maxSVtols) and ((sVtolGr.members < tVtolGr.members) or (not boolResult)))
				else if(sVtolGr.members < maxSVtols)
				{
					result = 2;	//sVtolGr
				}
			}

			//Build Vtols
			//-------------------------------------
			if(result > 0)
			{
				if(structureIdle(structure))	// if factory idle
				{
					count2 = 0;
					if(result == 2)		//sVtolGr
					{
						count = numSVtolTemplates - 1;
						while((count2 < numSVtolTemplates) and (count >= 0))
						{
							if(skCanBuildTemplate(player,structure, sVtols[temp][count]) )
							{
								tmplChoice[count2] = sVtols[temp][count];
								count2 = count2 + 1;
							}
							count = count - 1;
						}
					}
					else if(result == 1)				//tVtolGr
					{
						count = numTVtolTemplates - 1;
						while((count2 < numTVtolTemplates) and (count >= 0))
						{
							if(skCanBuildTemplate(player,structure, tVtols[temp][count]) )
							{
								tmplChoice[count2] = tVtols[temp][count];
								count2 = count2 + 1;
							}
							count = count - 1;
						}
					}
					else	//Transport
					{
						count2 = 1;
						tmplChoice[0] = Transport;
					}

					//Build it
					//--------------------
					if(count2 > 0)
					{
						buildDroid(tmplChoice[random(count2)],structure,player,1);
					}
				}
				structure = enumStruct();
			}
		}
	}
}

//----------------------------
// Build VTOL defenses
//----------------------------
event vtolDefend(vtolDefendTr)
{
	if(baseobj != NULLOBJECT)
	{
		if(baseobj.player != player)	//Wasn't our own tank
		{
			//Break alliance if our ally has attacked us
			//------------------------------------------
			if(allianceExistsBetween(player, baseobj.player))	//If we allied
			{
				breakAlliance(player, baseobj.player);		//No backstabbing
			}

			if(baseobj.type == OBJ_DROID)
			{
				if(isVtol(objToDroid(baseobj)))
				{
					if(structure != NULLOBJECT)		//Attacked structure still exists
					{
						buildX = structure.x;
						buildY = structure.y;

						result = 99999;
						tempDroid = NULLOBJECT;
	
						initIterateGroup(buildGroup);
						droid = iterateGroup(buildGroup);
						while(droid != NULLOBJECT)
						{
							if(droid.order == DORDER_NONE)
							{
								result2 = distBetweenTwoPoints(buildX, buildY, droid.x, droid.y);
								if(result2 < result)
								{
									result = result2;
									tempDroid = droid;
								}
							}
							droid = iterateGroup(buildGroup);
						}

						if(tempDroid != NULLOBJECT)		//If we have a truck
						{
							//Find best defense we can build
							//------------------------------
							count = 0;
							count2 = -1;
							while(count < numVtolDefStr)
							{
								if(isStructureAvailable(vtolDefStruct[count],player))
								{
									count2 = count;
								}
								count = count + 1;
							}

							if(count2 != (-1) )	//If we have a structure to build
							{
								boolResult = pickStructLocation(vtolDefStruct[count2], ref buildX, ref buildY,player);
								if(boolResult == TRUE)
								{
									orderDroidStatsLoc(tempDroid, DORDER_BUILD, vtolDefStruct[count2],buildX,buildY);
								}
							}
						}
					}
				}
				else		//Attacked by a tank
				{
					tVtolObject = baseobj;
				}	
			}
			else			//Attacked by a structure
			{
				sVtolObject = baseobj;
			}

			//Remember this attacker
			//if(defendObject == NULLOBJECT)		//Killed last attacker already, remember new one
			//{
				//Defend group
				if(structure != NULLOBJECT)		//Attacked structure still exists
				{
					//If structure is in the base
					if((structure.x > minx) and (structure.x < maxx) and (structure.y > miny) and (structure.y < maxy))
					{
						if(baseobj.type == OBJ_STRUCTURE)
						{
							defendObject = baseobj;
						}
						else if(baseobj.type == OBJ_DROID)
						{
							tempDroid = objToDroid(baseobj);
							//if(not isVtol(tempDroid))
							if(tempDroid.propulsion != vtolProp)
							{
								defendObject = baseobj;
							}
						}
					}
				}
			//}

			//Attack
			if(defendObject != NULLOBJECT)
			{
				if(defendGr.members > 0)
				{
					if(idleGroup(defendGr) >= (defendGr.members / 2))
					{
						showConsoleText(DebugMsg[13], player);		//Base attacked. Defending.

						orderGroupLoc(defendGr, DORDER_SCOUT, defendObject.x, defendObject.y);
					}
				}

				//Use collectSendGr group too, since they are just idling anyway
				if(collectSendGr.members > 0)
				{
					if(idleGroup(collectSendGr) >= (collectSendGr.members / 2))
					{
						orderGroupLoc(collectSendGr, DORDER_SCOUT, defendObject.x, defendObject.y);
					}
				}
				defendObject = NULLOBJECT;	//Reset
			}
		}

	}
}


//----------------------------------
//Build min number of VTOL defenses
//----------------------------------
event additVTOLDefenses(additVTOLDefensesTr)
{
	if((not defendingBase) and (alreadyAttacked))
	{
		//Count VTOL defenses
		//-------------------
		result = 0;
		count = 0;
		while(count < numVtolDefStr)
		{
			initEnumStruct(FALSE,vtolDefStruct[count],player,player);
			structure = enumStruct();
			while(structure != NULLOBJECT)
			{
				if((structure.x > minx) and (structure.y > miny) and (structure.x < maxx) and (structure.y < maxy))	//If in the base
				{
					result = result + 1;
				}
				structure = enumStruct();
			}
			count = count + 1;
		}

		temp = 16;	//Min number of VTOL defenses
		if(powerSaving)
		{
			temp = 7;	//Don't buld too many if not enough power
		}

		if(result < temp)
		{
			//Find the best VTOL defense available
			//------------------------------------
			count = 0;
			temp = -1;
			while(count < numVtolDefStr)
			{
				if(isStructureAvailable(vtolDefStruct[count],player))
				{
					temp = count;
				}
				count = count + 1;
			}

			if(temp != (-1) )	//If we have a structure to build
			{
				buildX = baseX;
				buildY = baseY;

				boolResult = pickStructLocation(vtolDefStruct[temp], ref buildX, ref buildY,player);
				if(boolResult == TRUE)
				{
					//Find closest droid
					//------------------------------------
					result = 99999;
					tempDroid = NULLOBJECT;

					initIterateGroup(buildGroup);
					droid = iterateGroup(buildGroup);
					while(droid != NULLOBJECT)
					{
						if(droid.order == DORDER_NONE)
						{
							result2 = distBetweenTwoPoints(buildX, buildY, droid.x, droid.y);
							if(result2 < result)
							{
								result = result2;
								tempDroid = droid;
							}
						}
						droid = iterateGroup(buildGroup);
					}

					if(tempDroid != NULLOBJECT)		//If we have a truck
					{
						orderDroidStatsLoc(tempDroid, DORDER_BUILD, vtolDefStruct[temp],buildX,buildY);
					}
				}
			}

		}
	}
}

//------------------------------------------
//Attack enemy objects in the base
//------------------------------------------
event agressiveDefence(agressiveDefenceTr)
{
	//If defenders got carried away from the base, make them return
	if((defendGr.x < minx) or (defendGr.y < miny) or (defendGr.x > maxx) or (defendGr.y > maxy))
	{
		buildX = baseX;
		buildY = baseY;
		if(pickStructLocation(factory, ref buildX, ref buildY, player))		//Find an open spot
		{
			orderGroupLoc(defendGr, DORDER_SCOUT, buildX, buildY);		//Send back
			orderGroupLoc(collectSendGr, DORDER_SCOUT, buildX, buildY);	//Send back
		}
	}

	result = defendGr.members + collectSendGr.members;
	if(result > 3)		//Have defenders
	{
		if((idleGroup(defendGr) + idleGroup(collectSendGr)) > (result / 2))	//Not busy
		{
			//Find enemy droids in the base
			//-----------------------------
			resetDroidTargets();
			setDroidTarPref(DT_WEAP_GROUND);	//Ignore VTOLs, tanks only
			setDroidTarIgnore(DT_VTOL);

			tempDroid = NULLOBJECT;
			count = 0;
			while((count < numEnemies) and (tempDroid == NULLOBJECT))
			{
				tempDroid = droidTargetInArea(Enemies[count], player, minx, miny, maxx, maxy);	//Droid
				count = count + 1;
			}

			if(tempDroid != NULLOBJECT)
			{
				//Check if we are following our own tank
				//--------------------------------------
				if((tempDroid.player == player) or (isVtol(tempDroid)))
				{
					tempDroid = NULLOBJECT;
				}

			}

			//Still have an attacker
			if(tempDroid != NULLOBJECT)
			{
				showConsoleText(DebugMsg[14], player);		//Agressive defence
				orderGroupLoc(defendGr, DORDER_SCOUT, tempDroid.x, tempDroid.y);
				orderGroupLoc(collectSendGr, DORDER_SCOUT, tempDroid.x, tempDroid.y);

				if(idleGroup(sVtolGr) == sVtolGr.members)
				{
					orderGroupObj(sVtolGr, DORDER_ATTACK, tempDroid);
				}

				if(idleGroup(tVtolGr) == tVtolGr.members)
				{
					orderGroupObj(tVtolGr, DORDER_ATTACK, tempDroid);
				}

			}

		}
	}
}

//-------------------------
//	Attack with VTOLs
//-------------------------
event vtolAttack(vtolAttackTr)
{
	temp = (KeepDist / 2);			//Enemy base range
	//if(attackPhase > 1)
	if(curEnemy != -1)
	{
		//-------------------------
		//Attack with anitank VTOLs
		//-------------------------
		boolResult = FALSE;
		if(tVtolObject == NULLOBJECT)		//No target
		{
			boolResult = TRUE;
		}
		//else if(tVtolObject.player != curEnemy)		//Attacking another player
		//{
		//	boolResult = TRUE;
		//}

		//If we can attack
		if(boolResult)
		{
			resetDroidTargets();
			setDroidTarPref(DT_CONSTRUCT);			//Find truck to attack
			//tempDroid = droidTargetInArea(curEnemy, -1, curEnemyX - temp, curEnemyY - temp, curEnemyX + temp, curEnemyY + temp);

			//if(tempDroid == NULLOBJECT)
			//{
				tempDroid = droidTargetOnMap(curEnemy, -1);
			//}

			if(tempDroid == NULLOBJECT)				//No truck, find another unit
			{
				resetDroidTargets();
				setDroidTarPref(DT_WEAP_GROUND);		//Ground,air,idf units
				setDroidTarIgnore(DT_LEGS);			//Ignore cyborgs
				setDroidTarIgnore(DT_LIGHT);			//Ignore light units
				tempDroid = droidTargetOnMap(curEnemy, curEnemy);
				//tempDroid = droidTargetInArea(curEnemy, curEnemy, curEnemyX - temp, curEnemyY - temp, curEnemyX + temp, curEnemyY + temp);
			}


			if(tempDroid != NULLOBJECT)				//Attack
			{
				tVtolObject = tempDroid;			//Remember
			}
		}

		//-------------------------------
		//Attack with antistructure VTOLs
		//-------------------------------
		boolResult = FALSE;
		if(sVtolObject == NULLOBJECT)		//No target
		{
			boolResult = TRUE;
		}
		//else if(sVtolObject.player != curEnemy)		//Attacking another player
		//{
		//	boolResult = TRUE;
		//}

		//If we can attack
		if(boolResult)
		{
			count = 0;
			structure = NULLOBJECT;
			while((count < 6) and (structure == NULLOBJECT))
			{
				resetStructTargets();
				setStructTarPref(sPref[count]);			//Find structure to attack
				structure = structTargetInArea(curEnemy, -1, curEnemyX - temp, curEnemyY - temp, curEnemyX + temp, curEnemyY + temp);
				count = count + 1;
			}

			if(structure == NULLOBJECT)				//No structure, find another structure
			{
				resetStructTargets();
				setStructTarPref(ST_DEF_ALL);			//Ground,air,idf
				structure = structTargetOnMap(curEnemy, -1);
			}

			if(structure != NULLOBJECT)				//Attack
			{
				sVtolObject = structure;			//Remember
			}
		}
	}
	else
	{
		//-------------------------
		//Attack with anitank VTOLs
		//-------------------------
		if(tVtolObject == NULLOBJECT)
		{
			//Find truck
			resetDroidTargets();
			setDroidTarPref(DT_CONSTRUCT);

			count = 0;
			droid = NULLOBJECT;
			while((count < numEnemies) and (droid == NULLOBJECT))
			{
				droid = droidTargetOnMap(Enemies[count], Enemies[count]);
				count = count + 1;
			}

			//No truck, find another unit
			if(droid == NULLOBJECT)
			{
				resetDroidTargets();
				setDroidTarPref(DT_WEAP_ALL);		//Any weapon unit

				count = 0;
				droid = NULLOBJECT;
				while((count < numEnemies) and (droid == NULLOBJECT))
				{
					droid = droidTargetOnMap(Enemies[count], Enemies[count]);
					count = count + 1;
				}
			}

			if(droid != NULLOBJECT)
			{
				tVtolObject = droid;
			}
		}

		//-------------------------------
		//Attack with antistructure VTOLs
		//-------------------------------
		if(sVtolObject == NULLOBJECT)
		{
			//Find structure
			count = 0;
			structure = NULLOBJECT;
			while((count < numEnemies) and (structure == NULLOBJECT))
			{
				count2 = 0;
				while((count2 < 6) and (structure == NULLOBJECT))
				{
					resetStructTargets();
					setStructTarPref(sPref[count2]);			//Find structure to attack
					structure = structTargetOnMap(Enemies[count], Enemies[count]);
					count2 = count2 + 1;
				}
				count = count + 1;
			}

			if(structure != NULLOBJECT)
			{
				sVtolObject = structure;
			}
		}
	}


	//------
	//Attack
	//------

	//Antitank
	if(tVtolObject != NULLOBJECT)
	{
		if((idleGroup(tVtolGr) >= (tVtolGr.members - 1)) and (tVtolGr.members >= maxTVtols))		//Enough VTOLs?
		{
			orderGroupObj(tVtolGr, DORDER_ATTACK, tVtolObject);		//Attack
		}
		else if((idleGroup(tVtolGr) <= (tVtolGr.members / 2)) and (tVtolGr.members <= (maxTVtols / 2)))
		{
			orderGroup(tVtolGr, DORDER_RTB);
		}
	}

	//Antistructure
	if(sVtolObject != NULLOBJECT)
	{
		if((idleGroup(sVtolGr) >= (sVtolGr.members - 1)) and (sVtolGr.members >= maxSVtols))		//Enough VTOLs?
		{
			orderGroupObj(sVtolGr, DORDER_ATTACK, sVtolObject);		//Attack
		}
		else if((idleGroup(sVtolGr) <= (sVtolGr.members / 2)) and (sVtolGr.members <= (maxSVtols / 2)))		//Return home
		{
			orderGroup(sVtolGr, DORDER_RTB);
		}
	}
}

//-------------------------
//Form alliances
//-------------------------
event formAllianceEvent(formAllianceEventTr)
{
	count = 0;
	while(count<8)
	{
		if(count != player )								// if not the only other player and rand2
		{
			if((getDroidCount(player) > 1) and (getDroidCount(count) > 1) )	// not dead
			{
				if(random(28) == 1)							// bit random
				{
					if(not isHumanPlayer(count))				// not human
					{
						createAlliance(player,count);
					}
				}
			}
		}
		count = count + 1;	
	}
}

//--------------------
//Human alliances
//--------------------
event formHumanAlliances(humanAllianceTr)
{
	if(count2 == player) //If offered to me
	{
		randomiseSeed();
		if(random(2) == 1)
		{
			showConsoleText(ai_ally_msg[random(4)],count);
		}
	}
}

//=====================================================================================================
//					CYBORG TRANSPORT
//=====================================================================================================
event cyborgDrop(cyborgDropTr)
{
	/********************************
		dropPhase:
		0 - idle
		1 - loading
		2 - on the way to lz
		3 - landing
		4 - landed and released cyborgs, transport returning home
	********************************/

	//Wait until all droids are loaded
	//--------------------------------
	if(dropPhase == 1)		//Loading
	{
		boolResult = TRUE;
		if(transportDroid == NULLOBJECT)		//Was destroyed
		{
			boolResult = FALSE;
			dropPhase = 0;			//Stop
		}

		if(boolResult)		//If transport is still there
		{
			

			//Check if all droids are idle (loaded into transport)
			//----------------------------------------------------
			boolResult = TRUE;
			initIterateGroup(transportGr);
			droid = iterateGroup(transportGr);
			while(droid != NULLOBJECT)
			{
				if(distBetweenTwoPoints(droid.x, droid.y, transportDroid.x, transportDroid.y) > 256)
				{
					boolResult = FALSE;
					if((droid.orderx != transportDroid.x) or (droid.ordery != transportDroid.y))		//Not going to the transport
					{
						orderDroidLoc(droid, DORDER_MOVE, transportDroid.x, transportDroid.y);		//Go to the transport
					}
				}
				else		//Load
				{
					vanishUnit(droid);
				}

				droid = iterateGroup(transportGr);
			}

			//Order transport to fly to the enemy to unload the units
			//-------------------------------------------------------
			if((boolResult) and (curEnemy >= 0) and (curEnemyX > 0))			//If all loaded
			{
				//Find an enemy base structure that is far away from the tank attack point
				//------------------------------------------------------------------------
				count = 0;
				boolResult = FALSE;
				temp = (30 * 128);		//Enemy base radius
				result = 0;
				while(count < numBaseStructs)
				{
					initEnumStruct(FALSE,baseStructs[count],curEnemy,player);		//Find visible in-base structure that is far away from the attack point (more efficient)
					structure = enumStruct();
					while(structure != NULLOBJECT)
					{
						//if(losTwoObjects(transportDroid, structure, FALSE))	//If can see enemy base structure
						//{
							
							result2 = distBetweenTwoPoints(curEnemyX,curEnemyY, structure.x, structure.y);
							if(result2 < temp)		//In the enemy base
							{
								//setFogColour(1, random(200) + 50, 1);
								if(result2 > result)	//Further away
								{
									//setFogColour(1, 1, random(200) + 50);
									result = result2;
									LZ_X = structure.x;
									LZ_Y = structure.y;
								}
							}
						//}
						structure = enumStruct();
					}
					count = count + 1;
				}

				//setFogColour(random(200) + 50, 1, 1);

				if(result == 0)
				{
					temp = (7 * 128);	//temp / 2;
					resetStructTargets();
					structure = structTargetInArea(curEnemy, player, curEnemyX - temp, curEnemyY - temp, curEnemyX + temp, curEnemyY + temp);
					if(structure != NULLOBJECT)
					{
						//setFogColour(1, random(200) + 50, random(200) + 50);
						LZ_X = structure.x;
						LZ_Y = structure.y;
						result = 1;
					}
				}

				if(result > 0)	//Found a structure
				{
					temp = (7 * 128);
					//resetStructTargets();
					//setStructTarPref(ST_DEF_AIR);		//Make sure no AA
					//structure = structTargetInArea(curEnemy, curEnemy, LZ_X - temp, LZ_Y - temp, LZ_X + temp, LZ_Y + temp);
					//if(structure == NULLOBJECT)	//No AA
					//{
						boolResult = pickStructLocation(wall, ref LZ_X, ref LZ_Y,player);
						if(boolResult)
						{
							//centreViewPos(LZ_X, LZ_Y);
							//setFogColour(random(200) + 50, 1, random(200) + 50);
							orderDroidLoc(transportDroid, DORDER_MOVE, LZ_X, LZ_Y);

							if(transportDroid.order != DORDER_NONE)
							{
								dropPhase = 2;
							}
							else
							{
								resetPlayerVisibility(player);		//Reset structures which were discovered and *are not visible anymore*
							}
						}
					//}
				}

				//orderDroidLoc(transportDroid, DORDER_SCOUT, LZ_X, LZ_Y);		//Take off
			}
		}
	}
	else if(dropPhase == 2)		//On the way to LZ
	{
		

		if(transportDroid != NULLOBJECT)
		{
			if(transportDroid.order == DORDER_NONE)		//If reached LZ and is landing
			{
				dropPhase = 3;
				transportZ = -1;		//Remember current height of the transport
			}
		}
		else		//Transport destroyed
		{
			dropPhase = 0;
		}
	}
	else if(dropPhase == 3)		//Landing on LZ
	{
		

		//Release cyborgs if stopped landiong
		//-----------------------------------
		if(transportDroid != NULLOBJECT)
		{
			if(transportZ == transportDroid.z)	//If stopped landing
			{
				//setFogColour(random(200) + 50, 1, 1);

				//'Unload' best cyborgs with best templates available
				//---------------------------------------------------
				structure = getStructure(cybFactory,player);
				if(structure != NULLOBJECT)
				{
					if(cybTemplate > -1)
					{
						//setFogColour(random(200) + 50, random(200) + 50, 1);

						//Cyborgs with weapons
						//--------------------
						result = 0;
						while(result < 8)		//Unload 8 weapon cyborgs
						{
							
							droid = addDroid(cybTmpl[cybTemplate], transportDroid.x, transportDroid.y, player);
							if(droid != NULLOBJECT)
							{
								//orderDroid(droid, DORDER_RUN);		//Don't stay too compact
								//groupAddDroid(attackGroup, droid);
								groupAddDroid(dropGr, droid);
							}
							result = result + 1;
						}

						//Mechanics
						//--------------------
						result = 0;
						while(result < 2)		//Unload 2 mechanics
						{
							droid = addDroid(cybMechanic, transportDroid.x, transportDroid.y, player);	//Add mechanic
							//groupAddDroid(attackGroup,droid);
							groupAddDroid(dropGr, droid);
							result = result + 1;
						}
						
					}
				}


				orderDroid(transportDroid, DORDER_RTB);
				//orderDroidLoc(transportDroid, DORDER_MOVE, baseX, baseY);	//Send transport back to the base
				dropPhase = 4;
			}
		}
		else	//Transport destroyed
		{
			dropPhase = 0;
		}

		transportZ = transportDroid.z;
	}
	else if(dropPhase == 4)		//Transport returning to the base
	{

		if(transportDroid != NULLOBJECT)
		{
			if(transportDroid.order == DORDER_NONE)		//If reached LZ and is landing
			{
				dropPhase = 0;
			}
		}
		else
		{
			dropPhase = 0;
		}
	}

	if((attackPhase > 2) and (dropPhase == 0))	//Attacking enemy base and not already transporting
	//if(dropPhase == 0)	//Attacking enemy base and not already transporting
	{
		if((transportDroid != NULLOBJECT) and (curEnemyX > 0))
		{
			if((transportGr.members >= 10) and (transportDroid.order == DORDER_NONE))
			{
				showConsoleText(DebugMsg[8], player);		//Initializing drop

				//Load transport
				//----------------------------
				initIterateGroup(transportGr);
				droid = iterateGroup(transportGr);
				while(droid != NULLOBJECT)
				{
					orderDroidLoc(droid, DORDER_MOVE, transportDroid.x, transportDroid.y);
					//setDroidSecondary(droid, DSO_RETURN_TO_LOC, DSS_RTL_TRANSPORT);
					//orderDroidObj(droid, DORDER_EMBARK, transportDroid);
					droid = iterateGroup(transportGr);
				}

				//LZ_X = curEnemyX;
				//LZ_Y = curEnemyY;

				dropPhase = 1;		//Loading Transport
			}
		}
	}
}

//---------------------------------------------
//Attack with cyborgs
//---------------------------------------------
event manageDropAttacks(manageDropAttacksTr)
{
	if(dropGr.members > 0)
	{
		if(idleGroup(dropGr) >= (dropGr.members / 2))
		{
			if((curEnemyX > 0) and (curEnemy > -1))
			{
				//Find a target
				//-------------
				tempX = dropGr.x;
				tempY = dropGr.y;
				temp = (15 * 128);
				count = 0;		//Attack base structures
				while(count < numBaseStructs)
				{
					initEnumStruct(FALSE,baseStructs[count],curEnemy,player);			
					structure = enumStruct();
					while(structure != NULLOBJECT)
					{
						if(distBetweenTwoPoints(tempX, tempY, structure.x, structure.y) < temp)		//If in the enemy base
						{
							boolResult = TRUE;
							initIterateGroup(dropGr);
							droid = iterateGroup(dropGr);
							while(droid != NULLOBJECT)
							{
								//if(droid.droidType != DROID_REPAIR)		//Mechanics stay near the group
								//{
									if(droid.order != DORDER_ATTACK)	//Not already attacking
									{
										if(losTwoObjects(droid, structure, FALSE))	//If can see this structure
										{
											orderDroidObj(droid, DORDER_ATTACK, structure);
											//sVtolObject = structure;
										}
									}
								//}
								droid = iterateGroup(dropGr);
							}
						}
						structure = enumStruct();
					}
					count = count + 1;
				}

				//Still no target, attack the base
				//--------------------------------
				if(idleGroup(dropGr) >= (dropGr.members / 2))
				{
					orderGroupLoc(dropGr, DORDER_SCOUT, curEnemyX, curEnemyY);
				}
			}
		}
	}
}

//------------------------------------------------------
//Make attackers return to the base if base is in danger
//------------------------------------------------------
event WatchDefendBase(WatchDefendBaseTr)
{
	//temp = 20 * 128;	//Search radius

	//if(bigMap)
	//{
	//	temp = 12 * 128;
	//}
	//else
	//{
	//	temp = 0;
	//}

	//tempX = minx - temp;
	//tempY = miny - temp;
	//buildX = maxx + temp;
	//buildY = maxy + temp;

	tempX = minx;
	tempY = miny;
	buildX = maxx;
	buildY = maxy;

	//Check everything's within limits
	//--------------------------------
	if(tempX < 0)			{	tempX = 128;	}
	if(tempY < 0)			{	tempY = 128;	}
	if(buildX > (mapWidth * 128))	{	buildX = (mapWidth * 128) - 128;	}
	if(buildY > (mapHeight * 128))	{	buildY = (mapHeight * 128) - 128;	}

	//Count enemies
	//--------------------------
	resetDroidTargets();
	setDroidTarPref(DT_WEAP_GROUND);	//Tanks only, ignore VTOLs
	result = 0;
	count = 0;
	while(count < numEnemies)
	{
		result = numDroidsInArea(Enemies[count], tempX, tempY, buildX, buildY) + result;	//Count enemy units
		count = count + 1;
	}


	//---------------------------
	//If not defending right now
	//---------------------------
	if(not defendingBase)
	{
		//If too many enemies
		//---------------------------------
		if(result > (defendGr.members + collectSendGr.members + 5))	//collectSendGr is also in the base
		{
			defendingBase = TRUE;
			powerSaving = TRUE;		//Save some power
			attackPhase = 1;		//Re-initialize attack later

			showConsoleText(DebugMsg[0], player);	//Base defence active

			NumOldDefenders = defendGr.members;	//Revert to this number after threat is gone

			//Order back to the base (before addign to defeners, so that defenders wouldn't cancel defending, if they already are)
			orderGroupLoc(sendOutpostGr, DORDER_MOVE, baseX, baseY);
			orderGroupLoc(collectSendGr, DORDER_MOVE, baseX, baseY);
			orderGroupLoc(attackGroup, DORDER_MOVE, baseX, baseY);
			orderGroupLoc(oilGr, DORDER_MOVE, baseX, baseY);
			orderGroupLoc(repairedGroup, DORDER_MOVE, baseX, baseY);

			//Add to defenders now
			groupAddGroup(defendGr, sendOutpostGr);
			groupAddGroup(defendGr, repairedGroup);
			groupAddGroup(defendGr, collectSendGr);
			groupAddGroup(defendGr, attackGroup);
			groupAddGroup(defendGr, oilGr);

			setGroupSecondary(defendGr, DSO_REPAIR_LEVEL, DSS_REPLEV_NEVER);	//Don't return to the outpost for repair
		}
	}
	else		//If defending and no threat, then cancel defend state
	{
		boolResult = FALSE;
		if(result < 2)		//Almost all kiled
		{
			boolResult = TRUE;
		}
		//else			//Compare number of enemy and friendly units in the base
		//{
		//	result2 = numDroidsInArea(player, tempX, tempY, buildX, buildY);
		//	if(result2 > (result + 8))
		//	{
		//		boolResult = TRUE;
		//	}
		//}

		if(boolResult)		//Can stop defending
		{
			showConsoleText(DebugMsg[1], player);	//Base defence off
			defendingBase = FALSE;

			if(NumOldDefenders < 8)		//Leave enough defenders
			{
				NumOldDefenders = 8;
			}

			//Add defenders back to attackers
			//-------------------------------
			count = defendGr.members;
			initIterateGroup(defendGr);
			droid = iterateGroup(defendGr);
			while((droid != NULLOBJECT) and (count > NumOldDefenders))		//While there are now more defenders that there were
			{
				if(droid.droidType != DROID_REPAIR)		//Leave repair unit for the defenders
				{
					orderDroid(droid, DORDER_STOP);		//Make idle
					groupAddDroid(sendOutpostGr, droid);	//Add back to attackers
					count = count - 1;	
				}
				droid = iterateGroup(defendGr);
			}

			toRepDefendDroid[0] = NULLOBJECT;		//Make repairer stop following this unit if it became an attacker
			toRepDefendDroid[1] = NULLOBJECT;

			NumOldDefenders = 0;

		}
	}
}

//-------------------------------------
//Help an ally if he's in trouble
//-------------------------------------
event WatchHelpAlly(WatchHelpAllyTr)
{
	temp = (12 * 128);	//Base radius around the found structure

	if((not defendingBase) and (helpAllyPlayer < 0))	//Not busy
	{
		if(attackGroup.members > 5)
		{
			count = 0;
			while((count < 8) and (helpAllyPlayer < 0))	//For all 8 players and while haven't started helping to defend yet
			{
				if(allyPlayer[count])
				{
					//Find ally base
					//--------------------------------------
					boolResult2 = FALSE;
					count2 = 0;
					while((count2 < numBaseStructs) and (not boolResult2))	//For all base structures
					{
						structure = getStructure(baseStructs[count2], count);	//Find Ally's base structure
						if(structure != NULLOBJECT)
						{
							tempX = structure.x;
							tempY = structure.y;
							boolResult2 = TRUE;		//Found base
						}
						count2 = count2 + 1;
					}

					if(boolResult2)	//If base found
					{
						temp = 12 * 128;	//Search radius

						result = numDroidsInArea(count, tempX - temp, tempY - temp, tempX + temp, tempY + temp);	//Count Ally's units

						//Count number of enemies in ally's base
						//--------------------------------------
						result2 = 0;
						count2 = 0;
						while(count2 < numEnemies)
						{
							result2 = numDroidsInArea(Enemies[count2], tempX - temp, tempY - temp, tempX + temp, tempY + temp) + result2;	//Count enemy units
							count2 = count2 + 1;
						}

						if(result2 > (result + 7))	//If many more enemy than ally units in ally's base
						{
							showConsoleText(DebugMsg[12], player);		//Helping ally's base

							//Collect attackers
							groupAddGroup(attackGroup, sendOutpostGr);
							groupAddGroup(attackGroup, repairedGroup);
							groupAddGroup(attackGroup, oilGr);
							//groupAddGroup(attackGroup, collectSendGr);

							setGroupSecondary(attackGroup, DSO_REPAIR_LEVEL, DSS_REPLEV_NEVER);	//Don't return to the outpost for repair
							attackPhase = 1;		//Re-initialize attack later
							helpAllyPlayer = count;
						}
					}
				}
				count = count + 1;
			}
		}
	}
	else if(helpAllyPlayer > (-1))	//Helping an ally already
	{
		if((helpAllyPlayerX > (-1)) and (helpAllyPlayerY > (-1)))	//Help coords exist
		{
			//Check if threat is gone now
			//---------------------------
			result = numDroidsInArea(helpAllyPlayer, helpAllyPlayerX - temp, helpAllyPlayerY - temp, helpAllyPlayerX + temp, helpAllyPlayerY + temp);	//Count Ally's units

			//Count number of enemies in ally's base
			//--------------------------------------
			result2 = 0;
			count2 = 0;
			while(count2 < numEnemies)
			{
				result2 = numDroidsInArea(Enemies[count2], helpAllyPlayerX - temp, helpAllyPlayerY - temp, helpAllyPlayerX + temp, helpAllyPlayerY + temp) + result2;	//Count enemy units
				count2 = count2 + 1;
			}

			if((result > (result2 + 6)) or (result2 == 0))	//If ally has more units than enemy or no enemy units at all
			{
				showConsoleText(DebugMsg[13], player);		//Ally's base is safe. Returning.

				helpAllyPlayer = -1;		//Cancel 'help AI base' state
				helpAllyPlayerX = -1;
				helpAllyPlayerY = -1;
			}

		}
	}
}

event deactivate(CALL_GAMEINIT)
{
	debugMode = FALSE;
	if( (not debugMode) and ((player == selectedPlayer) or (not myResponsibility(player))) )
	{
		setEventTrigger(StartGame,inactive);
		setEventTrigger(LegoBuild,inactive);
		setEventTrigger(Rush,inactive);
		setEventTrigger(chooseEnemy,inactive);
		setEventTrigger(BuildAttackForce,inactive);
		setEventTrigger(doResearch,inactive);
		setEventTrigger(basedetails,inactive);
		setEventTrigger(keepTrack,inactive);
		setEventTrigger(droidDestroyed,inactive);
		setEventTrigger(buildPowerGenerators,inactive);
		setEventTrigger(LegoTrucks,inactive);
		setEventTrigger(droidBuilt,inactive);
		setEventTrigger(difficultyMod,inactive);
		setEventTrigger(upgradeStructures,inactive);
		setEventTrigger(moveIfAttacked,inactive);
		setEventTrigger(stuck,inactive);
		setEventTrigger(buildVtols,inactive);
		setEventTrigger(vtolDefend,inactive);
		setEventTrigger(vtolAttack,inactive);
		setEventTrigger(formAllianceEvent,inactive);
		setEventTrigger(formHumanAlliances,inactive);
		setEventTrigger(updateDetails,inactive);
		setEventTrigger(repairStuff,inactive);
		setEventTrigger(FinishStructures,inactive);
		setEventTrigger(buildCyborgs,inactive);
		setEventTrigger(cyborgDrop,inactive);
		setEventTrigger(manageDropAttacks,inactive);
		setEventTrigger(WatchDefendBase,inactive);
		setEventTrigger(WatchHelpAlly,inactive);
		setEventTrigger(sendScouts,inactive);
		setEventTrigger(agressiveDefence,inactive);
		setEventTrigger(additVTOLDefenses,inactive);
	}
}

