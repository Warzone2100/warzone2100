/* General stuff */
#define	MAX_PLAYERS						8
#define	TILE							128
#define	MAX_UNITS						110

/* Should be used with GAME_TIME_IN_SECS, not with gameTime */
#define	SECOND							1
#define	MINUTE							(SECOND * 60)

/* How many seconds it takes to cross a tile */
#define	TILE_TRAVEL_TIME				1

/* Defines for debug watch window */
#define	WATCH_DEBUG_REINF				0
#define	WATCH_DEBUG_RESEARCH			1
#define	WATCH_DEBUG_CMDS				2

/* 10 secs are equivalent to 1 droid */
#define	SECONDS_PER_DROID				10

/* Max AA defenses to build on base perimeter, when enemy base location is known */
#define	MAX_BASE_PERIM_AA_DEF			6
#define	MAX_BASE_PERIM_AA_DEF			(TILE * 6)

/* Max AA defenses to build near loc attacked by enemy vtols, when enemy base location is unknown */
#define	MAX_INBASE_AA_DEF				6
#define	INBASE_AA_DEF_MAX_RANGE			(TILE * 4)

/* Max game time when we build scouts, stop afterwards */
#define	SCOUT_BUILD_TIME				(MINUTE * 8)

/* How much time to wait until we start building tanks */
#define	MIN_DELAY_INITIAL_TANKS			(MINUTE * 2)
#define	MAX_DELAY_INITIAL_TANKS			(MINUTE * 8)

/* How fast a single unit costing 215 power kills another single unit with the same cost - 1 per minute - rough approxomation */
#define	DEFAULT_KILLER_COST				215
#define	UNIT_KILL_RATE					(1 / MINUTE)
#define	DEFAULT_UNITS_PTS				130

/* min number of reinforcements to use when helping ally */
#define	MIN_HELPING_ALLY_REINF			5

#define	MIN_COUNTERATTACKERS			6
#define	MIN_OIL_DEFENDERS				8

/* Commanders stuff */
#define	MAX_COMMANDERS					10
#define CMD_INIT_CAPACITY				6
#define	MAX_CMD_ASSIGN_DIST				(TILE * 25)

/* How many repairs to build for repairing attack units */
#define	NUM_REPAIRS_FOR_CMD				5
#define	MAX_CMD_REPAIRERS				(MAX_COMMANDERS * NUM_REPAIRS_FOR_CMD)

#define	MAX_DEFEND_REPAIRERS			7

/* Max distance a repair unit can stay away from the commander it is assigned to */
#define MAX_REP_DIST_FROM_CMD			(TILE * 4)

/* Max distance a repair unit can stay away from the commander while it is repairing some droid */
#define MAX_REP_DIST_FROM_CMD_WHILE_REP	(TILE * 12)

/* How many defenders are rapired by a single repair unit */
#define	NUM_DEFENDERS_PER_REPAIRER		4

/* Choose randomly from this number of available templates */
#define	MAX_CHOICE_DROIDS				3

/* All objects inside this base range are treated as if they were belonging to the base */
#define	COUNT_BASE_OBJECTS_RANGE		max((35 * TILE), (baseRange + defendCorridor))

/* How useless a base defense is compared to a normal unit */
#define	STR_UNIT_DEFENSE_FACTOR			4

/* Whether to leave additional base defenders when attacking */
#define	NO_BASE_DEFENDERS				false
#define	PROGRESSIVE_DEFENDERS			(!NO_BASE_DEFENDERS)
#define	MIN_DEFENDERS					3

/* For minDefenders calculation: how many seconds a defender single unit can hold on, before main force comes back to the base to help defending it */
#define	UNIT_HOLD_SECS					8

/* Max number of group iteration thet can take place at the same time */
#define	MAX_GROUP_ITERATE_BUCKET		5

/* How many trucks to use when upgrading certain structures */
#define	MAX_POWGEN_UPGRADE_TRUCKS		2
#define	MAX_FACTORY_UPGRADE_TRUCKS		3

			/* Research stuff */

/* Min research facilities to use when researching */
#define	F_MIN_ACTIVE_RES_FAC			(2.5)

#define	GAME_TIME_IN_SECS				(gameTime / 10)

/* in secs */
#define LEGO_PHASE_LEN					(MINUTE * 5)
#define STARTUP_PHASE_LEN				(SECOND * 4)

#define MIN_DEF_OIL_TIME				(MINUTE * 4)

// hardcoded amyway
#define	MAX_BUILDERS					15

#define	CHECK_OIL_THREAT_RANGE			(TILE * 12)

// time to wait until derrick is recognized being under siege
#define	MIN_TIME_OIL_ATTACKED_DELAY		(SECOND * 8)
#define	MAX_TIME_OIL_NOT_ATTACKED		(MIN_TIME_OIL_ATTACKED_DELAY  + (SECOND * 15))

#define	THROW_DICE						random(100)

/* Reinforcements: What range to use when counting enemies for threat assessing */
#define	REINF_ENEMY_COUNT_RANGE			(TILE * 12)

				/* Oil building */

// max range to look for further oil when finished building an oil derrick
#define	NEXT_OIL_RANGE					(TILE * 11)

				/* Oil defense */

/* Chance to start attacking enemy oil after finished defending own oil derrick */
#define	CHANCE_COUNTER_OIL				40
#define	MAX_COUNTER_OIL_DISTANCE		(TILE * 12)

/* How many remembered oil defense location to use for a single oil derrick */
#define	MAX_OIL_DEFENSES_SIDES			3
#define	MIN_OIL_RECALL_PRIORITY			3
#define	DEFENSE_DIST_FROM_OIL			(TILE * 3)

/* Max/min number of oil defenses for a single stored defense location */
#define	MAX_OIL_DEFENSES_PER_LOC		8
#define	MIN_OIL_DEFENSES_PER_LOC		5

// range of oil defenses for a single stored oil defense location
#define	OIL_DEFENSES_RANGE				(TILE * 5)

// try to cover all oil defenses with this range
#define	RANGE_ALL_OIL_DEFENSES			(OIL_DEFENSES_RANGE + DEFENSE_DIST_FROM_OIL)

//max number of trucks that can build defenses for a single oi lderrick
#define	MAX_TRUCKS_PER_OIL_DEFENSE		1

// Whether to build defenses for derricks located in the base
#define DEFEND_BASE_DERRICKS			false

				/* Base defense */

// range of base defenses
#define	BASE_DEFENSES_RANGE				(TILE * 5)

//max number of recalled base defend locations to build defenses at
#define	MAX_BASE_DEFENSE_LOCATIONS		5

#define	MIN_BASE_RECALL_PRIORITY		1

#define	MAX_BASE_DEFEND_LOCS			7

#define	MAX_BASE_DEFENSES_PER_LOC		7
#define	MIN_BASE_DEFENSES_PER_LOC		5

#define	NUM_BASE_DEF_LOC_TRUCKS			1

// trucks to use for the same location when base is in danger
#define	MAX_BASE_DEF_LOC_TRUCKS			3


#define	REACHED_DEST_RANGE				(TILE * 17)
#define	REACHED_DEF_OIL_RANGE			(TILE * 10)

/* Weights for choose an enemy */
#define W_LOST_UNITS		0.6
//Weight per tile
#define W_BASE_DISTANCE		0.4
#define	AVERAGE_UNIT_COST	250

//2 units for 50 tiles
#define TILE_TRAVEL_COST	10.0

				/* Scouts */
/* (inverted) Add every nth tank to a scout group, lowest priority when a lot of map is revealed already */
#define	MIN_SCOUTS_PRIORITY				7
#define	MAX_SCOUTS_PRIORITY				1

/* Number of oil scouts */
#define	MIN_OIL_SCOUTS					0
#define	MAX_OIL_SCOUTS					5

/* Use MAX_SCOUTS_PRIORITY when SCOUT_MIN_OIL_RES are visible and
 * MIN_SCOUTS_PRIORITY when SCOUT_MAX_OIL_RES are visible, interpolate between
 */
#define	MAP_REVEAL_FAC_LBOUND			0.0
#define	MAP_REVEAL_FAC_UBOUND			1.0
#define	MAP_REVEAL_MIN_OIL_RES			0.0
#define	MAP_REVEAL_MAX_OIL_RES			16.0

#define	TAUNT_SUCCESS					0
#define	TAUNT_FAILURE					1
#define	TAUNT_POSSESSION_LOSS			2
#define	TAUNT_GAME_LOSS					3
#define	TAUNT_BASE_DEFENSE				4
#define	TAUNT_BASE_OK					5
#define	TAUNT_REDISCOVERED_BASE			6
#define	TAUNT_LOST_BASE					7

#define	NONE							(-1)


public	int				player,numLego,numTemplates[2],numBaseStructs,numDef,numRes[2],
						numGatewayDef,numAA,numRepairTmpl,maxDamageLevels,damageLevel[4],
						numBranches,techTanks,techAir,numVtolTemplates,numVitalStructs,
						numMinimalStruct[10],maxVitalBuilders[10],numCmdTmpl,numTruckTmpl,
						numBBTempl;
public	TEMPLATE		truck[3],tmpl[2][40],tmplOK[8],tmplBB[3],tmplRep[5],
						vtoltmpl[2][5],tmplCmd[4],cybEngineer,cybMechanic;
public	STRUCTURESTAT	fac,derrick,powGen,vtolfac,resFac,powMod,facMod,resMod,cmdCenter,
						baseStructs[10],def[10],gatewayDef[6],wall,AA[5],HQ,uplink,lasSat,
						minimalStruct[10],cybfac;
public	STRUCTURESTAT	ArgStrStat0;	//is private
public	FEATURESTAT		oilRes,ArgFeatStat0;

public	RESEARCHSTAT	research[3][60],resBB,resCmd;
public	BODY			viperBody;
public	WEAPON			weaponBB;
public	BRAIN			cmdTurret;

//-----------------------
// private vars
private	TEMPLATE	tempTmpl;
private	int		count,count2,count3,count4,result,result2,result3,result4,ArgInt0,ArgInt1,ArgInt2,
				ArgInt3,retInt,retInt2,_retInt,scoutX,scoutY,range,x,y;
private	int		temp,temp2,temp3,temp4,temp5,temp6,enemyScoutStep,enemyScoutX,enemyScoutY,
				enemyScoutRange,maxEnemyScouts,minEnemyScouts,numOilDef,minOilDef,
				tempX,tempY,numEnemyScouts,intOK[10],best,maxBaseDef,minBaseDef,
				numBaseDef,reinfTime,maxReinfTime,sendForceX,sendForceY,helpTime,
				maxHelpTime,state,stNone,stAttacking,stDefending,stHelpingAlly,stJoiningForces,
				stTakingOil,stDefendingOil,tState,timeGuardPos,maxTimeGuardPos,numOilAttackers,
				collectX,collectY,minOilAttackers,
				collectTime,maxCollectTime,stCollecting,numTakeOil,maxTakeOil,countTakeOil,
				lastState,lastEnemy,lastStateTemp,lastEnemyTemp,maxBaseEnemies,defendX,defendY,timeSaveExperience,
				maxTimeSaveExperience,tempResult,tempResult2,dist,dist2,dist3,defWeight,
				weightDistFactor,_dist,_dist2,tLastBaseDefense,maxInitialBaseDef,curInitialBaseDef,maxInitialDefSites,
				vstate,lastvState,counterEnemy,maxStateTime,maxBaseDefendDefLocTrucks,
				realEnemyScoutX,realEnemyScoutY;
private	bool	bResult,bResult2,bResult3,bTempResult,alert,bigMap,ally[8],
				bTemp,bTemp2,bEnemyScoutHor,bEnemyScoutToRight,
				bEnemyScoutToBottom,seeBase[8],noBaseTargets,haveBB,haveCommandTech,bCanUseCommanders,
				bLearn,knowBase[8],lowMilitary,DEBUG_ALL,DEBUG_MSG,DEBUG_OBSERVE,modifierOn,bNotifiedReadyAttack,
				ArgBool0,ArgBool1,hasVTOLs[8],_bResult,_bResult2,
				DEBUG_POWER,DEBUG_COMMANDS,dead[8],killedBase[8],bDummy,initialDefensesFinished,
				bFirstTimeDefenders,ghostDead[120],debugMenuUp,bRunning,bIterateNonCommanders[MAX_GROUP_ITERATE_BUCKET],
				bIterateCommanders[MAX_GROUP_ITERATE_BUCKET],bIterateCmdAssignedDroids[MAX_GROUP_ITERATE_BUCKET],
				bToEnemyScoutGr;

private	int		me,baseX,baseY,maxTrucks,minTrucks,buildX,buildY,maxBuildOilTrucks,
				unitLimit,maxResearch,noPower,lowPower,minFacs,minResFacs,
				minx,miny,maxx,maxy,baseSq,scoutRange,scoutStep,maxOilScouts,
				maxOilDef,base[8][2],enemy,numAttackers,maxAttackers,minAttackers,
				numDefenders,threatRange,minReinforcements,curBase[8][2],numOilScouts,maxBB,
				numBB,minBB,addScout,addScoutInterval,baseRange,highPower,muchoPower,requestHelpTime,maxRequestHelpTime,
				notifyReadyAttackTime,maxNotifyReadyAttackTime,oilDefensesRange,
				minOilRecallPrior,defendCorridor,allyOfferTime[8],maxAllyOfferTime,
				aaRange,maxOilDefenseTrucks,timeNotifyEnemyInBase,maxTimeNotifyEnemyInBase,
				attackedCount,allyState[8],allyPhase[8],allyEnemy[8],minAllyHelpers,
				minDefenders,maxBaseDefenseLoc,maxBaseDefenseTrucks,
				lasSatState[8],lasSatEnemy,tLasSat,tLasSatReady,tLasSatCountdown,
				tLasSatReplyMax,tLasSatWaitAlliesMax,lsNone,lsRecharging,
				lsReady,lsRequesterWaitingRecharging,lsWaitingReply,
				lsDelayedFiring,lsWaitingForRequester,lsWaiting,lsFiring;

private	int		phase,phNone,phMoveToLoc,phAttackingLoc,phSearchingForBase,phCollecting,
				phGuardingPos,phLostBase,phRTB,storeOilDefTime[8],storeBaseDefTime[8],
				storeTime,none,off,allyInThreat,msgPlayer,msgPlayer2,offeredEnemy,
				phGettingTech,phGettingUnits,phWaitAllies,phLoadingTransport,
				phSendDrop,phTransportDone,tWaitAlliesDrop,tMaxWaitAlliesDrop,tWaitLoadDrop,
				tMaxWaitLoadDrop,numDroppers,numTransporters,stDrop,maxTransporters,
				transportX,transportY,savedState,savedPhase,savedEnemy,stTransporting,
				reinfCount[8],tRequestStatus[8],tMaxRequestStatus,tWaitPlayerReply[8],tMaxWaitPlayerReply,
				maxDroppers,medDroppers,minDroppers,tSyncDrop,tMaxSyncDrop,dropStartTime,phSync,maxAllyDroppers,
				attacked[8],minReinfCount,maxReinfCount,tempReinfCount[8],
				maxDefendRepairers,_x,_y,_result,_result2,tTakeOil,tMaxTakeOil,tech,tLastResearch,
				tMaxResearchIdle,numCriticalResearch,sendHelpRange,groupIterateBucket,
				numPlayerAttackers[MAX_PLAYERS],attackersIncrease;
private	int		tOilAttackBegin,tLastOilAttack,lastOilAttackedX,lastOilAttackedY,watchWindowDebug;
private	int		_temp,_temp2,_temp3,_temp4,_range,lostDroids[MAX_PLAYERS],lostStructs[MAX_PLAYERS];
private	int		beaconX[8],beaconY[8],tBeacon[8],curHelpX[8],curHelpY[8],tBeaconTimeout,maxGhosts,
				ghostx[120],ghosty[120],tResUrgencyTrackInterval,
				structNoLiveHealth,iterateCommanderIndex[MAX_GROUP_ITERATE_BUCKET],
				iterateStage[MAX_GROUP_ITERATE_BUCKET],dice;
private	float	fCurResUrgency,fMaxResUrgency,fMinResUrgency,fNumDefaultResearch,
				fMinResearch,fMaxResHold,fMapRevealFactor;


private DROID			droid,droid2,droid3,tempDroid,tempDroid2,ArgDroid0,retDroid,transporter[10],
						_droid,_droid2,initialDefensesTruck,commander,cmds[MAX_COMMANDERS],
						iterateGroupDroid[MAX_GROUP_ITERATE_BUCKET];
private	STRUCTURE		structure,structure2,tempStruct,ArgStruct0,retStruct,_structure,_structure2,
						lasSatTarget;
private GROUP			buildGr,defendGr,vtolGr,sendAttackGr,attackGr,scoutGr,enemyScoutGr,
						tempGr,ArgGr,ArgGr2,transportGr,defendRepairGr,cmdGr[MAX_COMMANDERS],cmdRepGr[MAX_COMMANDERS],
						groupToIterate[MAX_GROUP_ITERATE_BUCKET],iterateCmdGroup[MAX_GROUP_ITERATE_BUCKET];
private FEATURE			feature,feature2,retFeature,tempFeature;
private BASEOBJ			obj,obj2,tempObj,retObj,baseDefendObj;
private string			cstr,sVer,myName;
private	RESEARCHSTAT	newResearch;

private	STRUCTURESTAT	ghostStat[120];

trigger selftestTr			(every, 50);
trigger	doScoutTr			(every, 40);
trigger droidBuiltTr		(CALL_NEWDROID,me, ref droid,ref structure);
trigger	structBuiltTr		(CALL_STRUCTBUILT, me, ref droid, ref structure);
trigger structureAttackedTr	(CALL_STRUCT_ATTACKED, me, ref structure, ref obj);
trigger droidAttackedTr		(CALL_DROID_ATTACKED, me, ref droid, ref obj);
trigger	objectAttackedTr	(CALL_ATTACKED, me, ref obj, ref obj2);
trigger consoleTr			(CALL_CONSOLE, ref msgPlayer2, ref cstr);
trigger multiMsgTr			(CALL_AI_MSG, me, ref msgPlayer, ref cstr);
trigger transLandedTr		(CALL_TRANSPORTER_LANDED_B, tempGr, me, ref droid);
trigger beaconTr			(CALL_BEACON, me, ref msgPlayer, ref x, ref y, ref cstr);
trigger	droidTakeOverTr		(CALL_UNITTAKEOVER, ref droid);
trigger	defendBaseTr		(every, 42);
trigger	doResearchTr		(every, 52);
trigger	defendOilTr			(every, 60);
trigger	buildNormalOilDefensesTr	(every, 80);
trigger	scoutForEnemyTr			(every, 56);
trigger	everySecTr				(every, 10);
trigger	coordinatePhasesTr		(every, 56);
trigger	repairDefendDroidsTr	(every, 54);
trigger	manageCMDRepairsTr		(every, 45);
trigger	diffModTr				(every,600);
trigger allianceOfferedTr		(CALL_ALLIANCEOFFER,ref temp, ref temp2);
trigger droidSeenTr				(CALL_DROID_SEEN, me, ref droid, ref obj);
trigger objectSeenTr			(CALL_OBJ_SEEN, me, ref obj, ref obj2);
trigger	checkLostTr				(every, 70);
trigger structDestroyedTr		(CALL_STRUCT_DESTROYED, me, ref structure);
trigger droidDestroyedTr		(CALL_DROID_DESTROYED, me, ref droid);
trigger	buildStructureModelTr	(wait, 10);
trigger	researchCompleteTr		(CALL_RESEARCHCOMPLETED, ref newResearch, ref structure, me);
trigger	startAllResearchTr		(wait, 10);
trigger	updateMapRevealFactorTr	(every, 100);
//=====================================================================
//	event declarations
//=====================================================================
event	selftest;
event	doScout;
event	droidBuilt;
event	structBuilt;
event	structDestroyed;
event	structureAttacked;
event	droidAttacked;
event	objectAttacked;
event	everySecEv;
event	consoleEv;
event	multiMsgEv;
event	beaconEv;
event	droidTakeOverEv;
event	transLanded;
event	defendBase;
event	doResearchEv;
event	defendOil;
event	buildNormalOilDefenses;
event	scoutForEnemy;
event	coordinatePhases;
event	manageCMDRepairsEv;
event	repairDefendDroids;
event	diffMod;
event	allianceOffered;
event	droidSeen;
event	objectSeen;
event	checkLost;
event	buildStructureModel;
event	startNewResearch;
event	startAllResearch;
event	evUpdateMapRevealFactor;

//=====================================================================
//	function declarations
//=====================================================================
function void	reInitialize();
function void	showVersion();
function void	mainInitialize();
function void	storeBase();
function void	unassignedDroids(GROUP defendersGr, GROUP buildersGr);
function void	fixGroups();


function void	doEconomy();
function void	doEconomyMisc();
function void	doMilitary();
function void	doMilitaryMisc();
function void	updateMaxTrucks();
function void	updateLasSat();
function void	resetLasSat();
function bool	allyLasSatReady();
function STRUCTURE	findLasSatTarget(int _prefferedEnemy);
function STRUCTURE	mostDamagedBaseStructure(int _targetPlayer);
function void	notifyLassat(STRUCTURE _targetStructure);
//function void	fireLasSat(STRUCTURE _targetStructure);
function bool	pendingLasSatStrike();
function void	economySelftest();
function void	baseDetails();
function void	militarySelftest();
function bool	needTrucks();
function int	numNeedRepairers();
function void	buildTrucks();
function void	buildBaseStructs();

function void	checkPowerGen();
function void	buildOil(bool _bInBaseOnly);
function bool	buildNextOil(DROID _truck, int _maxRange, bool _bClosestOil);
function void	buildMoreOil();
function bool	manageOilSite(DROID _truck, STRUCTURE _derrick);
function bool	repairDamagedDefenses(int _repairx, int _repairy, DROID _truck, int _minDamage, int _maxRange);
function bool	finishDefenses(DROID _truck, int _repairx, int _repairy, int _maxRange);
function void 	initializeStartDefeindingOil(int _oilx, int _oily);
function bool	checkOilThreat(int _oilx, int _oily);
function void	dealWithOilAttacked(int _oilx, int _oily);
function void	upgradeFac();
function void	upgradePow();
function void	upgradeVtolFac();
function void	upgradeResFac();
function void	finishStructures();
function void	repairStructures();
function void	groupRepairGroup(GROUP _damagedGr, GROUP _repairerGr);
function int	totalRepairersInProduction();
function int	numCybRepairsInProd();
function int	numNonCybRepairsInProd();

function void	startEnemyScout();
function void	getNextScoutCoord(int _lastX, int _lastY);
function void	closerTruck();

function bool	buildInBase(STRUCTURESTAT _statToBuild, int _maxTrucks);
function void	buildOnMap(STRUCTURESTAT _statToBuild, int _buildX, int _buildY, int _maxTrucks);
function DROID	closestIdleTruck(int _x, int _y);
function bool	buildUsingClosestTruck(STRUCTURESTAT _statToBuild, int _buildX, int _buildY, int _maxTrucks);
function FEATURE	findBestOilToBuildOn(int _lookx, int _looky, int _maxRange);
function STRUCTURE	findBestEnemyDerrick(int _targetPlayer, int _numAttackers, int _centerx, int _centery, int _maxRange);
function int	posWeight(int _owner, int _x, int _y, int _range, int _centerx, int _centery);
function int	oilWeight(int _owner, int _oilx, int _oily, int _centerx, int _centery);

//Functions

function int	numStatBusy(STRUCTURESTAT _structureToCheck, bool _bExcludeAlreadyBuilding);	//On the way or already a certain building type
function int	numStatMoveBusy(STRUCTURESTAT _structStatToCheck);	//On the way
function int	numTrucksBuilding();		//Number of trucks currently building something
function int	numBusyByType(STRUCTURESTAT _busyStructType);			//Num of certain structures busy
function int	numBuildSameBuilding(STRUCTURESTAT _checkStat, int _x, int _y);
function int	numTrucksSameOrderLoc(int _x, int _y, int _orderIndex);
function int	numTrucksOrderInRange(int _rangex, int _rangey, int _range, int _order);		//How many are building near this loc
function int	numTrucksSameOrder(int _orderIndex);
function int	numBuildingDefenses();		//How many building defenses
function int	numBuildingBaseDefenses();
function int	numBuildingNoBaseDefenses();
function int	numVisibleOilResInRange(int _x, int _y, int _range);
function int	numTotalOilInRange(int _x, int _y, int _range);
function int	numDerricksInRange(int _targetPlayer, int _x, int _y, int _range);
function bool	buildingSiteBlocked(DROID _truck, int _radius, int _x, int _y, bool _bAllOrders);
function int	numDefenses();
function int	numBaseDefenses();
function bool	isInMyBase(int _checkX, int _checkY);	//tests if x,y coords are in the base
function bool	isNearAnyBase(int _x, int _y);			//check if point is near someone's base
function bool	isNearEnemyBase(int _x, int _y);
function bool	isNearOil(int _x, int _y);
function bool	isBaseStruct(STRUCTURE _checkStruct);			//TRUE if one of the base structure types (like factory)
function int	findResearch(int _searchStart, int _techTree);
function int	calcNeededRes();
function void	doResearchAll();
function int	doResearch(STRUCTURE _resFac, int _resIndex);
function void	getClosestCorner(int _x, int _y);		//corner, closest to x,y
function STRUCTURE	closestDerrick(int _x, int _y);
function FEATURE	closestOilResource(int _x, int _y);
function void	findFreeSpot(int _x, int _y);
function void	findFreeSpotSmall(int _x, int _y);
function void	findFreeSpotMedium(int _x, int _y);
function int	repairStructure(STRUCTURE _damagedStruct, int _maxRepairers);

function bool	needStartupScouts();
function bool	canBuildTanks();
function void	buildTanks();
function void	buildVTOLs();
function void	buildBaseDefenses();
function void	buildInitialDefenses(bool _bForceBuild);
function void	stopInitialDefenses();
function void	buildAA();
function void	gatewayDefenses();

function void	checkBase(int _player);
function bool	findBase(int _targetPlayer);
function bool	canSeePlayer(int _player);
function bool	checkPlayerDead(int _player);
function void	findAlternateTarget();
function void	updateMilitaryStatus();
function int	chooseEnemy();

function void	resetOilDefendCoords();
function bool	canStartDefendingOil();
function bool	canStartAttack(int _enemy);
function bool	canTheoreticallyStartAttack();		//count current attackers as well
function bool	haveTheoretilcallyMinAttackers(bool _bSafeToSendLittleAttackers);		// have *any* attackers? (count current attackers as well)
function int	numAvailableAttackers();
function int 	totalWeapUnits();
function bool	checkFollowAttackRequest(int _attackRequester, bool _bHighPriorityTask);
function int	groupSizeCmds(GROUP _groupToCount, bool _bIncludeUnassigned,
					bool _bIncludeCmds, bool _bInclDroidsAssignedToCmds);

function void	checkStopAttack();
function void	doAttack();
function void	prepareAttackers(bool _bHighPriorityTask);
function void	startAttack(int _enemy, int _x, int _y);
function void	vStartAttackBase(int _enemy);
//function void	vAttackBase(int _enemy);
function int	sortOutBBs();
function void	checkBaseThreat();
function int	checkAllyThreat();
function int	findAllyInTrouble();
function void	startHelpAlly(int _allyToHelp, int _helpx, int _helpy);
function void	startDefending(int _counterEnemy);
function void	startTakingOil(STRUCTURE _enemyDerrick);
function bool	initializeStartTakingOil(int _oilx, int _oily, int _maxRange);
function bool	canStartTakingOil();
function void	startDefendingOil(int _derrickX, int _derrickY, int _maxTime);
function STRUCTURE	findEnemyDerrick(int _targetPlayer);
function void	manageHelpAlly();
function void	fillAttackers(int _numAttackers);
function int	numAttackersFromPriorty(bool _highPriorityTask);
function void	fillReinforcements(bool _bHelping);

function void	fillHelpers();

function int	findBestAA();
function int	findBestDefense();

function void	setCollectingLoc();
function void	startCollectingPhase();		//gather together
function void	startCollecting();		//gather together

function bool	canSendReinf(bool _forHelping);		//have enough units tosend reinf?
function void	coordinateSendMovement(int _sendX, int _sendY, int _range, int _order, GROUP _coordinateGr);
function bool	checkReachedDestination(int _destX, int _destY, GROUP _toCheckGr, GROUP _toAddToGr, int _range);

function void	updateTransport();
function void	updateDropPhase();

function void	startMovePhase();
function void	startTransportState(GROUP _groupToTransport, int _destinationX, int _destinationY);

function void	stopState();
function void	stopJoiningForces();
function void	stopDefending();
function void	stopTakingOil();
function void	stopDefendingOil();
function void	stopAttack();
function void	stopCollecting();
function void	stopAllyDefense();
function void	stopTransportState();
function void	stopDropState();

function void	cancelState();
function void	cancelJoiningForces();
function void	cancelDefending();
function void	cancelTakingOil();
function void	cancelDefendingOil();
function void	cancelAttack();
function void	cancelCollecting();
function void	cancelAllyDefense();
function void	cancelTransportState();
function void	cancelDropState();

function void	endJoiningForces();
function void	endDefending();
function void	endTakingOil();
function void	endDefendingOil();
function void	endAttack();
function void	endAllyDefense();
function void	endTransportState();
function void	endDropState();

function void	pauseState();
function void	resumeState();
function void	erasePausedState();
function void	resetSendForceCoords();

function void	loadSavedState();
function void	saveCurrentState();
function void	eraseLoadSavedState();

function bool	canStopCollecting();	//finished gathering or time is up
function bool	finishedCollecting();	//finished gathering

function void	doAlly(int _playerOffered);

function void	requestHelp();
function void	requestStatus(int _player);
function void	checkRequestStatus();
function void	requestStartAttack(int _enemy, int _x, int _y);
function void	requestPrepareDrop();
function void	dropAllyBeacon(STRING _cstr, int _x, int _y);

function void	notifyAllies(STRING _cstr, bool _bUpdateRadar);
function void	notifyAll(STRING _cstr);
function void	notifyReadyAttack();
function void	notifyIdle(bool bAfterFailure);
function void	notifyTakeOil(int _enemy, int _x, int _y);
function void	taunt(int targetPlayer, int type, int tauntProbability);
function void	notifyStatus(int _playerToNotify);
function void	notifyStatusAll();
function void	notifyPower(int _targetPlayer);
function void	notifyPlayerHasVTOLs(int _playerWithVTOLs);
function void	notifyEnemyAtBase();
function void	notifyPlayerDead(int deadPlayer);
function void	notifyPlayerBaseDestroyed(int _destroyedPlayer);
function void	notifyPlayerAlive(int _alivePlayer);
function void	notifyPrepareDrop();
function void	notifyStartDrop();
function void	notifyCantDrop();
function void	notifyLost();

function void	refreshAllyRadar();
function void	rememberPlayerIsAlive(int _alivePlayer);

function int	bestAlliancePlayer();
function void	makeAlliances();
function bool	canAlly(int _player);
function void	doOfferAlliance(int _alliancePlayer);

function void	findAttackBaseTarget(DROID _looker, int _x, int _y, int _radius);
function void	findBBAttackBaseTarget(DROID _looker);

function void	storeBaseDefLocEv();
function void	storeOilDefLocEv();

function void	deselectAllDroids();
function void	goRTB();
function void	saveExperience();

function bool	alliesReadyToDrop();
function bool	timeToDrop();
function int	numAlliesDroppingPlayer(int _player);
function int	numActiveEnemyDrop(int _enemyToCheck);
function int	getNumTransporters();
function bool	enoughTransporters();
function void	buildTransporters();
function bool	enoughDroppers();
function void	dropLoadTransport();
function void	orderTranspDisembark(DROID _transporter, int _coordx, int _coordy);
function int	chooseEnemyToDrop();
function void	fillDroppers();
function bool	transporterLoaded();
function bool	checkTransportersLanded();
function void	doDrop();
function void	startDropPhase();
function void	prepareTransporters();
function int	setNumDroppers();
function int	calcNumRequiredTransporters(int _numUnits);
function int	numDroidsLoaded();
function void	joinForces(int _joinPlayer, int _x, int _y);
function void	requestEnemy(int _toAskPlayer);
//function void	processCommand(int _msgPlayer, STRING _cstr, bool _bBlipMessage, string _processedString, int _targetPlayers);
function void	processCommand(string _message, int _sender, bool _bBlipMessage);
function void	processDebugCommand(int _msgPlayer, STRING _cstr);
function void	assignDroid(DROID _droid);
function bool	beaconTimeout(int _player);
function bool	haveBeacon(int _player);
function void	updateBeacons();
function bool	isCurrentOrder(int _state, int _enemy);
function void	updateStateCoord(int _newx, int _newy);
function void 	defendArea(GROUP	_defendGr, int _range, int _defendX, int _defendY, int _defendCorridor, int _minDefenders);
function void	cleanBaseCenter(GROUP _group, int _range, int _defendX, int _defendY, int _edgeX, int _edgeY, int _defendCorridor);
function DROID	getTruckByTarget(BASEOBJ _target);
function int	numBuildersInProduction(int _player);
function int	numBBsInProduction(int _player);
function bool 	lowOnPower();
function void 	setState(int _newState);
function void	vsetState(int _newState);
function void	toggleDebugMenu();
function void	shutDown();
function void	oneTimeInitialize(bool bAIControlled);
function bool	haveMinimalStructures();
function void	checkMinimalStructures();
function void	updateNumDefenders();

function bool	canUseCommanders();
function int	getNumCommanders();
function int	getTotalCmdsCapacity(GROUP _group, bool _bIncludeInProduction);
function int	getFreeCmdsCapacityInGroup(GROUP _group);
function void	assignCommander(DROID _newCommander, GROUP _group);
function int	numCommandersInProduction();
function void	fillCommanderGroup(DROID _commander, GROUP _fillFromGroup);
function DROID	closestDroidByGroup(GROUP _group, int _x, int _y, bool _bIncludeCommanders);
function void	orderGroupLocCmd(GROUP _groupToOrder, int _order, int _x, int _y);
function void	groupAddGroupCmd(GROUP _groupTo, GROUP _groupFrom);
function int	initIterateGroupCmd(GROUP _groupToIterate, bool _bReturnNonCmds, bool _bReturnCmds, bool _bReturnCmdAssignedDroids);
function DROID	iterateGroupCmd(GROUP _groupToIterate, int _bucket);
function int	idleGroupCmd(GROUP _idleGroup, bool _bIncludeNonCmds, bool _bIncludeCmds);
function int	cmdToIndex(DROID _commander);
function int	groupCMD_x(GROUP _group);
function int	groupCMD_y(GROUP _group);
function void	groupAddCmd(GROUP _group, DROID _commander);
function void	assignDroidToBestCommander(DROID _droid, GROUP _group);
function void	unassignAllDroidsFromCMDsFromGroup(GROUP _unassignGroup, GROUP _toGroup);
function void	unassignAllDroidsFromCMD(DROID _commander, GROUP _toGroup);
function void	assignDroidsToBestCommandersFromGroup(GROUP _fromGroup, GROUP _toGroup);
function void	fillBestCommandersCapacity(int _maxCapacity, GROUP _newGroup, GROUP _oldGroup);

// commander repairs functions
function int	numMissingCmdRepairers(int _groupIndex, bool _bIncludeDeadCmds);
function DROID	bestCommanderWithoutRepairer();
function void	repairCMDGroup();
function DROID	findCMDGroupObjectToRepair(int _cmdIndex, DROID _repairer);

function void	setTechBranch();

function string	groupToString(GROUP _group);
function string	droidToGroupName(DROID _droid);

function void	goToPerim(int _centerX, int _centerY, int _fromX, int _fromY, int _perimRange, int _order, DROID _droid);

function bool	droidOrderIdle(DROID _droid);
function bool	droidActionAttacking(DROID _droid);
function bool	droidActionDroidRepair(DROID _repairer);
function bool	defending();
function bool	helpingAlly();
function bool	defendingOil();
function bool	legoPhase();
function bool	startupPhase();
function bool	haveMinTrucks();
function bool	gettingMinTrucks();
function BASEOBJ	closerObject(BASEOBJ _obj1, BASEOBJ _obj2, int _x, int _y);
function float	secondLanchasterLaw(float _fAllyStartForce, float _fEnemyStartForce, int _time, float _allyEffectiveness, float _enemyEffectiveness);
function bool	LanchasterVictory(float _fStartForceA, float _fStartForceB, float _fKillRateA, float _fKillRateB);
function int	LanchasterTimeToWin(float _fStartForceA, float _fStartForceB, float _fKillRateA, float _fKillRateB);
function float	objBaseDamagePerSec(BASEOBJ _obj);
function float	enemyFirepowerInRange(int _x, int _y, int _range);
function float	friendlyFirepowerInRange(int _x, int _y, int _range);
function float	groupFirepower(GROUP _group);
function float	groupHP(GROUP _group);
function float	playerFirepowerInRange(int _player, int _x, int _y, int _range);
function int	totalPlayerWeapObjHPInRange(int _player, int _x, int _y, int _range, bool _bVtols);
function int	totalEnemyWeapObjHPInRange(int _x, int _y, int _range, bool _bVtols);
function int	totalFriendlyWeapObjHPInRange(int _x, int _y, int _range, bool _bVtols);
function bool	isTankTemplate(TEMPLATE _tmpl);
function void	updateMaxScouts();
function void	updateMapRevealFactor();
function bool	buildOilDefenseFromExperience(int _index, DROID _truck);
function bool	buildOilDefense(int _buildX, int _buildY, int _oilx, int _oily, DROID _truck);
function DROID	closestEnemyDroidByType(int _x, int _y, int _range, int _type);

//=====================================================================
//	Events
//=====================================================================
//event powerup(CALL_GAMEINIT)
event powerup(wait, 5)
{
	local bool bMyRespons,bNotLost;

	DEBUG_ALL = FALSE;

	DEBUG_MSG = DEBUG_ALL;		//isHumanPlayer(player);
								/*%!	ID="DEBUG_MSG",
								MainDesc="DEBUG messages",
								type="asn",		//Assign
								tmpl="YesNo"	*/
	DEBUG_OBSERVE = DEBUG_ALL;	/*%!	ID="DEBUG_OBSERVE",
								MainDesc="DEBUG observe mode",
								type="asn",		//Assign
								tmpl="YesNo"	*/
	DEBUG_POWER = FALSE;		/*%!	ID="DEBUG_POWER",
								MainDesc="DEBUG power",
								type="asn",		//Assign
								tmpl="YesNo"	*/

	DEBUG_COMMANDS = DEBUG_ALL;		/*%!	ID="DEBUG_COMMANDS",
								MainDesc="DEBUG commands",
								type="asn",		//Assign
								tmpl="YesNo"	*/

	modifierOn = TRUE;

	bLearn = TRUE;		//Use experience?
	sVer = "1.4";

	bRunning = FALSE;	//remember this AI is inactive

	me = player;

	myName = getPlayerColourName(me) & "-Aiv";

	dbgMsgOn(me, DEBUG_MSG);


	/* Check if this AI is inactive */
	groupAddArea(tempGr, player, 0, 0, (mapWidth*128), (mapHeight*128));
	structure = getStructure(fac, me);

	bNotLost = TRUE;
	if((tempGr.members == 0) and (structure == NULLOBJECT))
	{
		bNotLost = FALSE;
	}

	//find out if this player is controlled by AI
	bMyRespons = FALSE;
	if(myResponsibility(me) and ((me != selectedPlayer) or DEBUG_OBSERVE))
	{
		if(bNotLost){	//alive?
			bMyRespons = TRUE;
		}else{
			dbg("deactivated", me);
		}
	}
	else
	{
		dbg("not my responsibility", me);
	}

	//do common one-time initialization only if this player is loaded
	if(bNotLost){
		oneTimeInitialize(bMyRespons);
	}

	//only load if AI is active
	if(bMyRespons)
	{
		mainInitialize();
	}
}

/* Initialization for both AI and human player, to be performed once only */
function void oneTimeInitialize(bool bAIControlled)
{
	local int loadExperienceStatus;

	/* Decide what debug info to output to the watch window */
	watchWindowDebug = WATCH_DEBUG_REINF;

	bigMap = false;
	if((mapWidth * mapHeight) > (125 * 125))		// > 125*125
	{
		bigMap = true;
	}

	/* only change name if not human */
	if(not isHumanPlayer(me))
	{
		setPlayerName(me, myName);
	}

	fixGroups();

	//assign all dorids to an approriate group
	unassignedDroids(defendGr, buildGr);

	// remember base location
	storeBase();

	if(bLearn and bAIControlled)
	{
		loadExperienceStatus = loadPlayerAIExperience(me);

		if(DEBUG_MSG)
		{
			if(loadExperienceStatus == 0)		//loaded successfully
			{
				dbg("Experience loaded successfully for player " & me, me);
			}
			else if(loadExperienceStatus < 0)
			{
				dbg("No saved experience found for player " & me, me);
			}
			else // any error
			{
				dbg("Error while loading experience for player " & me, me);
			}
		}
	}

	/* Initialize ghost structures data */
	maxGhosts = 120;
	count = 0;
	while(count < maxGhosts)
	{
		ghostStat[count] = NULLSTRUCTURESTAT;
		ghostx[count] = -1;
		ghosty[count] = -1;
		ghostDead[count] = TRUE;
		count  = count + 1 ;
	}

	groupIterateBucket = (-1);

	maxBaseEnemies = 22;
	storeTime = 120;	//in seconds, how long to wait until next store if the same function void can be triggered

	reinfTime = 0;		//last time we send reinforcements
	maxReinfTime = 420;	// > 6 min

	helpTime = 0;		//last time we send reinforcements
	maxHelpTime = 400;	// > 6 min

	timeGuardPos = 0;
	maxTimeGuardPos = 180;	//attackers wait at current pos

	tTakeOil = 0;
	tMaxTakeOil = 400;

	requestHelpTime = 0;
	maxRequestHelpTime = 180;	//3 min

	collectTime = 0;
	maxCollectTime = 150;

	timeNotifyEnemyInBase = 0;
	maxTimeNotifyEnemyInBase = 300;	//5 mins

	maxTimeSaveExperience = 120;	//2 mins
	timeSaveExperience = maxTimeSaveExperience;	//skip first time

	maxAllyOfferTime = 500;		//>7 min

	tWaitAlliesDrop = 0;
	tMaxWaitAlliesDrop = 420;	//7 mins

	tSyncDrop = 0;
	tMaxSyncDrop = 300;		//in secs

	tWaitLoadDrop = 0;
	tMaxWaitLoadDrop = 150;		//in secs

	tMaxRequestStatus = 550;	//randomized after every execution of requestStatus()

	tMaxWaitPlayerReply = 30;	//in secs

	tLastBaseDefense = 0;	//when started to build a base defense last time

	dropStartTime = none;

	minReinfCount = 3;		//accept drop request if send minReinfToDrop reinforcements to this enemy and he's still alive
	maxReinfCount = minReinfCount + random(4) + 2;		//consider dropping an enemy if can't get him by land

	maxTakeOil = 6;		//max take oil reids we can make
	countTakeOil = 0;
	numTakeOil = random(maxTakeOil);

	// For the oil defense routine
	resetOilDefendCoords();

	maxDefendRepairers = MAX_DEFEND_REPAIRERS;

	defWeight = 18;		//defense weight for distance calculation
	weightDistFactor = 250;	//factor for derrick weight calculation (divided by distance)

	notifyReadyAttackTime = 0;
	maxNotifyReadyAttackTime = 8 + random(12);	//should be different for each AI
	bNotifiedReadyAttack = FALSE;

	maxTransporters = 9;


	count = 0;
	while(count < MAX_PLAYERS)
	{
		storeOilDefTime[count] = 0;
		storeBaseDefTime[count] = 0;
		allyOfferTime[count] = 0;
		lostDroids[count] = 0;
		lostStructs[count] = 0;

		count++;
	}

	/* Decide how many trucks we need */
	updateMaxTrucks();

	/* Total Unit limit */
	unitLimit = MAX_UNITS; //getUnitLimit(me);

	/* Set research limits */
	maxResearch = getStructureLimit(resFac, me);	//use all we can
	fMinResearch = F_MIN_ACTIVE_RES_FAC;

	if(maxResearch <= 0){
		dbg("*************maxResearch = 0 *************", me);
	}

	//fNumDefaultResearch = fMinResearch;
	fNumDefaultResearch = fMinResearch;
	fMinResearch = 2.5;

	/* Research urgency - controls how many research facilities are put to work */
	tResUrgencyTrackInterval = (MINUTE * 7);	//How 'deep' our memory frame is, in secs - trimmed after tResUrgencyTrackInterval secs
	//it will take tResUrgencyTrackInterval seconds for maxResearch idle research facilities to reach highestResearchUrgency value
	fMaxResUrgency = (float)tResUrgencyTrackInterval * fNumDefaultResearch;	// We haven't done much research lately, but trim it to some max value
	fMinResUrgency = (-fMaxResUrgency);		//We've done alot research lately, can't go lower than this though
	fMaxResHold = (float)(MINUTE * 4) * fNumDefaultResearch;	//Max time to hold all research, until it can be forced, in secs (fNumDefaultResearch num of res facs can wait 4 mins)
	fCurResUrgency = fMaxResHold;	//(float)(MINUTE * 8) + fMaxResHold;		//In 'secs', Increases with time when research is idle - make urgent at the beginning

	structNoLiveHealth = 9;	//When to demolish structure if it's low on hitpoints, in %

	offeredEnemy = none;	//last player an ally offered us to attack

	counterEnemy = none;		//enemy that currently attacked us (used for counter attacks)

	noPower = 70;
	lowPower = 200;
	highPower = 900;
	muchoPower = 2600;
	alert = FALSE;		//Emergency
	lowMilitary = FALSE;
	minFacs = 3;
	minResFacs = 2;

	baseSq = 0;			//base square
	baseRange = 0;
	aaRange = 0;			//prim where to build base aa

	oilDefensesRange = OIL_DEFENSES_RANGE;

	// Initialize scout variables
	updateMaxScouts();

	maxOilDef = MAX_OIL_DEFENSES_PER_LOC;		/*%!	ID="maxOilDef",
						MainDesc="max oil defenses",
						type="asn",		//Assign
						val="5",
						ArgDesc="5 (Default)",
						val="0",
						ArgDesc="0",
						val="3",
						ArgDesc="3",
						val="7",
						ArgDesc="7",
						val="10",
						ArgDesc="10"	*/

	numOilDef = maxOilDef;
	minOilDef = MIN_OIL_DEFENSES_PER_LOC;	/*%!	ID="minOilDef",
						MainDesc="min oil defenses",
						type="asn",		//Assign
						val="3",
						ArgDesc="3 (Default)",
						val="0",
						ArgDesc="0",
						val="5",
						ArgDesc="5",
						val="7",
						ArgDesc="7",
						val="10",
						ArgDesc="10"	*/


	minOilRecallPrior = MIN_OIL_RECALL_PRIORITY;		//ignore derricks with lower defend priority

	maxInitialBaseDef = 2;		//max defenses per defend site
	curInitialBaseDef = 1;		//current number of defenses per defend site (rises slowly with time)
	maxInitialDefSites = 4;

	/* Base defenses */
	maxBaseDef = MAX_BASE_DEFENSES_PER_LOC;
	minBaseDef = MIN_BASE_DEFENSES_PER_LOC;
	numBaseDef = maxBaseDef;
	maxBaseDefenseLoc = MAX_BASE_DEFEND_LOCS;			//build at max 6 locations
	maxBaseDefendDefLocTrucks = NUM_BASE_DEF_LOC_TRUCKS;

	scoutX = 0;
	scoutY = 0;

	phNone				= 0;
	phCollecting		= 1;
	phMoveToLoc			= 2;
	phAttackingLoc		= 3;
	phSearchingForBase	= 4;
	phGuardingPos		= 5;
	phLostBase			= 6;
	phRTB				= 7;
	phGettingTech		= 8;
	phGettingUnits		= 9;
	phWaitAllies		= 10;
	phLoadingTransport	= 11;
	phSync				= 12;	//Synchronizing with allies
	phSendDrop			= 13;
	phTransportDone		= 14;	//signal for drop phase that transport phase is done successfully


	stNone			= 0;
	stAttacking		= 1;
	stDefending		= 2;
	stDefendingOil	= 3;
	stHelpingAlly	= 4;
	stJoiningForces	= 5;
	stTakingOil		= 6;
	stCollecting	= 7;
	stDrop			= 8;
	stTransporting	= 9;


	threatRange = (TILE * 10);

	tBeaconTimeout = 30;	//in secs

	tLastResearch = 0;					//when we did last research
	tMaxResearchIdle = 2 * 60;	//max time to suspend research for, 2 mins, in secs
	numCriticalResearch = 1;	//min research facilities to put to work if we did no research for long time

	initialDefensesFinished = false;	//if finished building anti-rush defenses

	bFirstTimeDefenders = TRUE;

	tech = none;

	lsNone = 0;
	lsRecharging = 1;
	lsReady = 2;			//recharged
	//lsFinishingRecharging = 3;	//will finish recharging lassat soon
	lsRequesterWaitingRecharging = 4;	//someone requested a lassat strike and is waiting for us to finish recharging lassat
	lsWaitingReply = 5;		//wait to find out if anyone wants to join
	lsWaitingForRequester = 6;	//we finished recharging our lassat and are now waiting for the requester to start the strike
	lsDelayedFiring = 7;	//requester firedand we are about to do a delayed fire
	lsWaiting = 8;			//waiting for allies to fire
	lsFiring = 9;

	tLasSat = 0;			//how much time left till tLasSatReady (till recharged)
	tLasSatReady = 300;	//300;		//how long takes to recharge (in secs)
	tLasSatCountdown = off;	//used for misc stuff
	tLasSatReplyMax = 6;
	tLasSatWaitAlliesMax = 45;	//wait max x secs for allies' lasSat to fully recharge

	//initialize enemy and ally information
	count = 0;
	while(count < 8)	//multiPlayerMaxPlayers)
	{
		/* las sat */
		lasSatState[count] = lsNone;	//finished charging etc

		base[count][0] = none;		//x
		base[count][1] = none;		//y

		curBase[count][0] = none;		//x
		curBase[count][1] = none;		//y

		hasVTOLs[count] = FALSE;

		knowBase[count]= FALSE;
		seeBase[count] = FALSE;

		ally[count] = FALSE;
		dead[count] = (not playerLoaded(count));	//FALSE;

		if(dead[count])
		{
			dbg(getPlayerName(count) & " (" & count & ") is not loaded", me);
		}

		killedBase[count] = FALSE;

		attacked[count] = 0;		//num times attacked by this player
		reinfCount[count] = 0;
		tempReinfCount[count] = 0;	//how many times we sent reinfs after the last time we dropped this enemy (tempReinfCount is reset everytime AI does a drop on a certain player and starts over)

		tRequestStatus[count] = tMaxRequestStatus + random(700);
		tWaitPlayerReply[count] = 0;

		allyState[count] = stNone;
		allyPhase[count] = phNone;
		allyEnemy[count] = none;

		curHelpX[count] = -1;
		curHelpY[count] = -1;

		//init beacon stuff
		beaconX[count] = -1;
		beaconY[count] = -1;
		tBeacon[count] = -1;	//time of the last beacon msg

		//recall players base location
		if(bLearn)
		{
			if(recallPlayerBaseLoc(me, count, ref x, ref y))	//if this location stored
			{
				if(x <= 0 or y <= 0)
				{
					MsgBox("x or y <= 0");
				}
				base[count][0] = x;		//x
				base[count][1] = y;		//y

				curBase[count][0] = x;		//x
				curBase[count][1] = y;		//y

				curHelpX[count] = curBase[count][0];	//where to go help
				curHelpY[count] = curBase[count][1];

				knowBase[count] = TRUE;

				dbg("recalled base location for " & getPlayerName(count), me);
			}
		}

		count = count + 1;
	}

	base[me][0] = baseX;
	base[me][1] = baseY;

	minAllyHelpers = 5;

	numOilAttackers = 5;	//num units required before can start taking oil
	minOilAttackers = 3;	//min units required before can start taking oil

	minDefenders = MIN_DEFENDERS;	//min defenders to leave in base

	//attack stuff
	numDefenders = 0;	//set in updateNumDefenders() now

	defendCorridor = (5 * 128);	//range which defenders can stay in (baseRange)

	minAttackers = 5;
	maxAttackers = 90;	//(unitLimit - maxTrucks - numDefenders) * 3 / 4;
	numAttackers = 5 + random(17) + minAttackers;

	attackersIncrease = 4;		// by how many units to increase number of attackers vs a certain player when attack fails

	// set initial number of attackers to use vs. all players
	count = 0;
	while(count < MAX_PLAYERS)
	{
		numPlayerAttackers[count] = numAttackers;
		count++;
	}

	minReinforcements =  5; //13 + random(8);

	//drop stuff
	maxDroppers = 40;
	if(random(2) == 0)
	{
		maxDroppers = maxDroppers + 10;
	}
	medDroppers = max(maxDroppers / 2, minDroppers);
	minDroppers = 10;					//1 transporter

	maxAllyDroppers = 3 + random(2);		//no more than x players

	//Bunker Buster
	minBB = 1;
	maxBB = 8;
	numBB = maxBB;

	haveBB = FALSE;

	attackedCount = 0;		// how many times was attacked

	//Commanders belong to the defend group on start up
	count = 0;
	while(count < MAX_COMMANDERS)
	{
		cmds[count] = NULLOBJECT;
		cmdGr[count] = defendGr;
		count++;
	}

	//adapt for big maps
	if(bigMap)
	{
		minReinforcements = minReinforcements + random(2) + 3;
	}
}

function void mainInitialize()
{
	bRunning = TRUE;	//remember this AI is active

	reInitialize();		//assign variables
	showVersion();
	startEnemyScout();
	selftest();			//Misc stuff

	setEventTrigger(selftest, selftestTr);	//Start
	setEventTrigger(doScout, doScoutTr);
	setEventTrigger(doResearchEv, doResearchTr);
	setEventTrigger(defendOil, defendOilTr);
	setEventTrigger(buildNormalOilDefenses, buildNormalOilDefensesTr);

	setEventTrigger(defendBase, defendBaseTr);
	setEventTrigger(structureAttacked, structureAttackedTr);
	setEventTrigger(droidAttacked, droidAttackedTr);
	setEventTrigger(everySecEv, everySecTr);
	//setEventTrigger(consoleEv, consoleTr);
	setEventTrigger(multiMsgEv, multiMsgTr);
	setEventTrigger(beaconEv, beaconTr);
	setEventTrigger(droidTakeOverEv, droidTakeOverTr);



	setEventTrigger(objectAttacked, objectAttackedTr);
	setEventTrigger(coordinatePhases, coordinatePhasesTr);

	setEventTrigger(allianceOffered, allianceOfferedTr);
	setEventTrigger(droidSeen, droidSeenTr);
	setEventTrigger(objectSeen, objectSeenTr);
	setEventTrigger(structBuilt, structBuiltTr);
	setEventTrigger(structDestroyed, structDestroyedTr);
	setEventTrigger(checkLost, checkLostTr);
	setEventTrigger(transLanded, transLandedTr);
	setEventTrigger(repairDefendDroids, repairDefendDroidsTr);
	setEventTrigger(manageCMDRepairsEv, manageCMDRepairsTr);
	setEventTrigger(droidBuilt, droidBuiltTr);
	setEventTrigger(buildStructureModel, buildStructureModelTr);
	setEventTrigger(startNewResearch, researchCompleteTr);
	setEventTrigger(startAllResearch, startAllResearchTr);
	setEventTrigger(evUpdateMapRevealFactor, updateMapRevealFactorTr);

	//if(me != selectedPlayer)
	if(modifierOn)
	{
		setEventTrigger(diffMod, diffModTr);
	}
}

//---------------------------------------------------------
//	Initializations
//---------------------------------------------------------
function void reInitialize()
{
	//if(IGNORE_MESSAGES)
	//{
	//	console("multiplayer mode on for Aivolution " & me & " (cooperation off)");
	//}

	dbg("ACTIVE!!!", me);

	unassignedDroids(defendGr, buildGr);		//assign all dorids to an approriate group

	cstr = "empty";
	baseDefendObj = NULLOBJECT;

	none = (-1);
	off = (-1);

	debugMenuUp = FALSE;

	phase = phNone;


	setState(stNone);
	lastState = stNone;

	vsetState(stNone);		//vtol state
	lastvState = stNone;

	/* las sat stuff */
	lasSatEnemy = none;

	curBase[me][0] = baseX;
	curBase[me][1] = baseY;
	curHelpX[me] = curBase[me][0];	//where to go help
	curHelpY[me] = curBase[me][1];

	enemy = none;
	lastEnemy = none;

	noBaseTargets = TRUE;		//didn't find any targets yet

	resetSendForceCoords();		//where to send the sendAttackGr units

	transportX = none;
	transportY = none;

	defendX = none;
	defendY = none;

	collectX = none;		//where to gather forces
	collectY = none;

	//help ally stuff
	allyInThreat = none;		//what ally is in danger now?
	sendHelpRange = 18 * TILE;	//range units should stay inside when helping ally in his base

	//dbg(" " & me & ")  Num attackers: " & numAttackers);
}

//if we have no trucks and no facs, deactivate events
event checkLost(inactive)
{
	/* any base structures left? */
	temp = 0;
	while(temp < numBaseStructs)
	{
		tempStruct = getStructureVis(baseStructs[temp], me, me);
		if(tempStruct != NULLOBJECT)
		{
			exit;		//yes, have a base structure
		}
		temp = temp + 1;
	}

	// FIXME: might consider reactivating
	//if((getDroidCount(me) == 0) and
	//	not (multiPlayerGameType == SKIRMISH and multiPlayerAlliancesType == ALLIANCES_TEAMS))

	if(getDroidCount(me) == 0)
	{
		taunt(NONE, TAUNT_GAME_LOSS, 60);
		shutDown();
	}
}

/*
 * Deactivete this AI
  */
function void shutDown()
{
	bRunning = FALSE;	//remember this AI is inactive

	notifyPlayerDead(me);

	setEventTrigger(selftest, inactive);	//Start
	setEventTrigger(doScout, inactive);
	setEventTrigger(doResearchEv, inactive);
	setEventTrigger(defendOil, inactive);
	setEventTrigger(buildNormalOilDefenses, inactive);
	setEventTrigger(defendBase, inactive);
	setEventTrigger(structureAttacked, inactive);
	setEventTrigger(droidAttacked, inactive);
	setEventTrigger(everySecEv, inactive);
	//setEventTrigger(consoleEv, inactive);				//allow AI to re-activate itself again
	setEventTrigger(multiMsgEv, inactive);
	setEventTrigger(beaconEv, inactive);
	setEventTrigger(droidTakeOverEv, inactive);


	setEventTrigger(objectAttacked, inactive);
	setEventTrigger(coordinatePhases, inactive);

	setEventTrigger(allianceOffered, inactive);
	setEventTrigger(droidSeen, inactive);
	setEventTrigger(objectSeen, inactive);
	setEventTrigger(structBuilt, inactive);
	setEventTrigger(structDestroyed, inactive);
	setEventTrigger(checkLost, inactive);
	setEventTrigger(transLanded, inactive);
	setEventTrigger(repairDefendDroids, inactive);
	setEventTrigger(manageCMDRepairsEv, inactive);
	setEventTrigger(droidBuilt, inactive);
	setEventTrigger(startNewResearch, inactive);
	setEventTrigger(startAllResearch, inactive);
	setEventTrigger(evUpdateMapRevealFactor, inactive);

	dbg("DEACTIVATED SCRIPT!!!!!!!!!!!!!!!!!!", me);
}

//---------------------------------------------------------
//	Deal with basic stuff
//---------------------------------------------------------
event selftest(inactive)
{
	baseDetails();
	updateBeacons();

	doEconomyMisc();	/* should be done before any other economy tasks */
	doEconomy();

	doMilitaryMisc();	/* should be done before any other military tasks */
	doMilitary();
}

//---------------------------------------------------------
//	Deal with basic military stuff
//---------------------------------------------------------
function void doMilitary()
{
	updateMaxScouts();

	/* build anti-rush defenses */
	if(!initialDefensesFinished)
	{
		//dbg("buildInitialDefenses() - doMilitary()", me);
		buildInitialDefenses(FALSE);
	}

	if(!initialDefensesFinished and (gameTime >= 9000))	//max 15 mins
	{
		stopInitialDefenses();	//enough
	}

	/* manage helping ally process */
	if(state == stHelpingAlly)		//did we choose to defend him?
	{
		/* if checkAllyThreat detected that no enemies left and were helping ally, retreat back to base */
		//if(defendingAlly)
		//{

		if(helpTime > 0)	//help didn't timeout yet
		{
			manageHelpAlly();
		}
		else
		{
			dbg("DEFEND ALLY: time out, rtb!!!!!!!!!!!!!!!!!", me);
			notifyAllies(getPlayerName(enemy) & ", retreating for now, call me if you need me again" , false);	//allyInThreat
			stopAllyDefense();
		}
	}
	else if(defendingOil())
	{
		if(tState >= maxStateTime)
		{
			stopDefendingOil();
		}
	}

	/* build units */
	if((tech == techAir) or (playerPower(me) > muchoPower))
	{
		buildVTOLs();
	}

	if((tech == techTanks) or (playerPower(me) > muchoPower))
	{
		// if(canBuildTanks())
		// {
			buildTanks();
		// }
	}


	/* Build base defenses */
	if( ((GAME_TIME_IN_SECS - tLastBaseDefense) >  (SECOND * 30)) or defending())	//wait at least 30 secs
	{
		// if(not((playerPower(me) <= lowPower) and defending()))		//build defenses only if not low on power and not defending
		// {
			buildBaseDefenses();
		// }
	}

	/* build AA defenses */
/* 	if((!alert and !defending()) or (playerPower(me) > highPower))
	{
		buildAA();
	} */

	/* build gateway defenses if enough power */
	if(!alert and (playerPower(me) > highPower) and (GAME_TIME_IN_SECS > (MINUTE * 20)))	//don't waste too much power on it; don't waste startup power
	{
		gatewayDefenses();
	}

	/* check if tired attacking an enemy and want to try to drop him instead */
	if(state == stAttacking)
	{
		if((tempReinfCount[enemy] >= maxReinfCount) and (groupSizeCmds(attackGr,true,false,true) <= 1))		//if we attacked too many times and current attack failed too
		{
			result2 = random(3);

			/* do drop */
/*
			if(result2 == 1)
			{
				result = numResearchLeft(me, resUnitTransporter);
				if(result <= 3)		//won't take too long
				{
					dbg("ATTACKED ENEMY TOO MANY TIMES: drop instead!!!", me);

					result = enemy;

					pauseState();

					enemy = result;		//same enemy
					requestPrepareDrop();
					startDropPhase();
				}
			}
*/
			/* wipe out some derricks */
			if(result2 == 0)
			{
				// make sure we have enough units
				if(canStartTakingOil())
				{
					structure = findEnemyDerrick(enemy);

					if(structure != NULLOBJECT)
					{
						dbg("ATTACKED ENEMY TOO MANY TIMES: wipeout oil instead!!!", me);
						pauseState();		//resume when done hunting enemy derricks

						startTakingOil(structure);
						notifyTakeOil(structure.player, structure.x, structure.y);
					}
				}
			}
		}
	}

	/* see if we want to drop someone ... just out of fun */
//todo: fix
/*
	if((state == stNone) and (random(10) > 6))
	{
		if((notifyReadyAttackTime <= 0) and (bNotifiedReadyAttack == FALSE))	//make sure not about to start attack
		{
			//result = enoughDroppers();
			if(enoughDroppers())
			{
				result = numResearchLeft(me, resUnitTransporter);
				if(result <= 6)		//won't take too long
				{
					result = chooseEnemyToDrop();
					if(result != none)		//found any enemy targets?
					{
						enemy = result;
						requestPrepareDrop();
						startDropPhase();
					}
				}
			}
		}
	}
*/

	/* build transporters if gonna drop */
/*
	if((state == stDrop) and researchFinished(resUnitTransporter, me))	//gonna drop and got unit transporter tech
	{
		//temp = enoughTransporters();
		if((not alert) and (not enoughTransporters()))
		{
			buildTransporters();
		}
	}
*/
	/* see if we want to blow up some enemy derricks */
	if(countTakeOil < numTakeOil)	//don't do too often
	{
		if((state == stNone) and (notifyReadyAttackTime <= 0) and (bNotifiedReadyAttack == FALSE))	//not busy and not about to start attack
		{
			result = numAvailableAttackers();
			if((random(10) < 7) and (result >= numOilAttackers))
			{
				structure = findEnemyDerrick(none);	//any player
				//structure = retStruct;

				if(structure != NULLOBJECT)
				{
					startTakingOil(structure);
					notifyTakeOil(structure.player, structure.x, structure.y);
				}
			}
		}
	}


	/* start land attack */
	if(state == stNone)
	{
		//result = canTheoreticallyStartAttack();	//enough units in total
/* 		if(canTheoreticallyStartAttack())					//we can start
		{ */
			if(noBaseTargets)	//if couldn't find any enemy main bases
			{
				findAlternateTarget();	//find any other visible target
			}

			if(not noBaseTargets)	//notify only if can actually start attacking someone
			{
				if(bNotifiedReadyAttack or (not playerInAlliance(me)))	//already notified or no allies
				{
					result = chooseEnemy();	//should be able to find enemy if (not noBaseTargets)
					if(result != none)		//found any enemy targets?
					{
						if(canStartAttack(result))
						{
							//enemy = result;
							startAttack(result, curBase[result][0], curBase[result][1]);
							requestStartAttack(result, curBase[result][0], curBase[result][1]);
						}
					}
					else
					{
						dbg("ATTACK: failed to find an enemy", me);
					}
				}
				else if(notifyReadyAttackTime <= 0)	//haven't started countdown already
				{
					if(haveTheoretilcallyMinAttackers(false))
					{
						notifyReadyAttack();		//notify allies and wait for orders
					}
				}
			}
		/* } */
	}

	/* Continue military actions if we are attacking */
	if(state == stAttacking)
	{
		doAttack();
		checkStopAttack();
	}

	/* remind allies we are in trouble */
	if(defending())
	{
		if(requestHelpTime <= 0)
		{
			requestHelp();	//do once in a while
		}
	}

	/* use lasSat */
	updateLasSat();
}

function void doMilitaryMisc()
{
	militarySelftest();		//misc stuff

	/* set tech branch */
	if((tech == none) and (gameTime > 100))
	{
		setTechBranch();	// decide what we will research
	}

	/* create alliances */
	if(not alliancesLocked() and (gameTime > 100))
	{
		if(numAllies(me) < (multiPlayerMaxPlayers / 2))	//not allied to too many players already
		{
			if(random(5) == 1)
			{
				makeAlliances();
			}
		}
	}

	/* Make sure we are not under heavy attack */
	if(gameTime > 1800)		//3 mins, in case bases are close to each other
	{
		checkBaseThreat();	//set or cancel base threat alert
	}


	/* find enemies and allies and their bases (targets) */
	updateMilitaryStatus();

	/* if we haven't heard anything from our allies for a long time, ask what they are doing */
	checkRequestStatus();

	/* Update minimum number of defender units to use */
	updateNumDefenders();
}

//---------------------------------------------------------
//	Deal with basic economy stuff
//---------------------------------------------------------
function void doEconomyMisc()
{
	updateMaxTrucks();
}

/* Returns true if it's the beginning of the game */
function bool legoPhase()
{
	if(GAME_TIME_IN_SECS <= LEGO_PHASE_LEN){
		return true;
	}

	return false;
}

/* Returns true the game has just started */
function bool startupPhase()
{
	if(GAME_TIME_IN_SECS <= STARTUP_PHASE_LEN){
		return true;
	}

	return false;
}

function bool haveMinTrucks()
{
	if(groupSizeCmds(buildGr,true,false,true) >= minTrucks){
		return true;
	}

	return false;
}

// have trucks + num building
function bool gettingMinTrucks()
{
	if((groupSizeCmds(buildGr,true,false,true) +
		numBuildersInProduction(me)) >= minTrucks)
	{
		return true;
	}

	return false;
}

function void buildMoreOil()
{
	local	int			_maxRange;
	local	DROID		_truck;
	local	FEATURE		_oil;

	_maxRange = TILE * 50;

	if(numStatBusy(derrick, true) < maxBuildOilTrucks)
	{
		_oil = findBestOilToBuildOn(-1, -1, -1);	//just find the best oil on the map
		if(_oil != NULLOBJECT)
		{
			_truck = closestIdleTruck(_oil.x, _oil.y);

			if(_truck != NULLOBJECT)
			{
				orderDroidStatsLoc(_truck, DORDER_BUILD, derrick, _oil.x, _oil.y);
			}
		}
	}
}

function void doEconomy()
{
	local	int		_numBuilders;
	local	bool	_bBaseHasHighPriority;

	economySelftest();

	/* build AA defenses */
	if(!defending() or (playerPower(me) > muchoPower))
	{
		buildAA();
	}

	//dbg(" " & me & ")  doEconomy");
	if(DEBUG_POWER and (playerPower(me) <= lowPower)){
		addPower(highPower - 300, me);
	}

	// send a droid to build oil if we have just started or we are not low on trucks and there are many unoccupied oil resources
	if((numVisibleOilResInRange(-1,-1,-1) >= 4) or legoPhase())
	{
		buildMoreOil();

		if(startupPhase()){
			dbg(numVisibleOilResInRange(-1,-1,-1) & " oil resources are visible", me);
		}
	}

	closerTruck();

	//dbg(" " & me & ")  buildTrucks");

	if(needTrucks()){
		// dbg("NEED TRUCKS", me);

		buildTrucks();
	}
	// else
	// {
		// dbg("DON'T NEED TRUCKS", me);
	// }
		//dbg(" " & me & ")  checkPowerGen");

	//Make sure we have all vital base structures (factory, power getm etc)
	if(!haveMinimalStructures()){
		checkMinimalStructures();
	}

	checkPowerGen();

	//dbg(" " & me & ")  repair");

	// see if we have to repair base structure before some other tasks
	_bBaseHasHighPriority = defending();
	if(_bBaseHasHighPriority and (haveMinTrucks() or !needTrucks()))		//don't send if low on trucks
	{
		repairStructures();
		finishStructures();
	}

	// don't update factories while we building initial trucks, to get them faster (5 mins max)
	_numBuilders = groupSizeCmds(buildGr,true,false,true);
	if(! (!haveMinTrucks() and legoPhase()) )
	{
		upgradeFac();
	}

	// upgrade power generators
	upgradePow();

	if(state == stDrop)		//give it a higher priority if going to drop
	{
		upgradeVtolFac();
	}

	//dbg(" " & me & ")  buildOil");

	/* Build derricks */
	if(not structureLimitReached(derrick, me))	//don't try if can't
	{
		buildOil( defending() );	//don't go away from base if in danger and low on trucks
	}

	/* Build factories and research facilities */
	buildBaseStructs();

	if(!_bBaseHasHighPriority and (haveMinTrucks() or !needTrucks()) )
	{
		repairStructures();
		finishStructures();
	}

	if(!alert and (state != stDrop)){
		upgradeVtolFac();
	}

	if(not alert){
		upgradeResFac();
	}
		//dbg(" " & me & ")  END doEconomy()");
}

function void economySelftest()
{
	if(gameTime < 30)
		exit;	//wait until power is initialized

	bResult = alert;		//remember last state

	/* if base is in danger ignore anything else */
	if((playerPower(me) <= highPower) and (groupSizeCmds(defendGr,true,false,true) < numDefenders))
	{
		if(gameTime > 4200)
		{
			if(not bResult){dbg("economy - not enough defenders       (!!!!!)", me);}

			alert = TRUE;
			lowMilitary = TRUE;
		}
	}

	/* restet lowMilitary */
	if(lowMilitary)
	{
		if(groupSizeCmds(defendGr,true,false,true) >= numDefenders)
		{
			lowMilitary = FALSE;		//reset here
			alert = FALSE;
			dbg("lowMilitary back to normal (!!!!!)", me);
		}
	}

	if(lowMilitary)
		exit;		//don't reset alert until lowMilitary is back to normal

	/* set numOilDef */
	if(playerPower(me) >= lowPower)
	{
		numOilDef = maxOilDef;
		numBaseDef = maxBaseDef;
	}
	else if(playerPower(me) <= noPower)		//no power
	{
		numOilDef = minOilDef;
		numBaseDef = minBaseDef;
	}

	/* set alert and lowMilitary */
	if(playerPower(me) >= lowPower)			//high power, back to normal
	{
		alert = FALSE;
	}
	else if(playerPower(me) <= noPower)		//no power
	{
		if(!haveMinTrucks() and needTrucks())
		{
			alert = TRUE;
			if(not bResult){dbg("economy low on trucks       (!!!!!)", me);}
		}

		if(not alert)
		{
			if((getNumStructures(fac,me) < minFacs) or (getNumStructures(powGen,me) == 0))
			{
				alert = TRUE;
				if(not bResult){dbg("economy low on vital structures       (!!!!!)", me);}
			}
		}

		//if(not alert)
		//{
			if((gameTime > 4200) and (groupSizeCmds(defendGr,true,false,true) < numDefenders))
			{
				alert = TRUE;
				lowMilitary = TRUE;
				if(not bResult){dbg("economy - not enough defenders       (!!!!!)", me);}
			}
		//}
	}

	if(bResult and (not alert))
	{
		dbg("Economy back to normal         !!!!!!", me);
	}
}

function void updateMaxTrucks()
{
	local	int		_numHaveTrucks;

	minTrucks = 6;				//Critical number

	maxTrucks = 8;

	// we need more at startup
	if(legoPhase()){
		maxTrucks = maxTrucks + 4;
	}

	// we need more trucks if there's a lot of defences to build
	if(getBaseDefendLocCount() > 0){
		maxTrucks++;
	}

	// the more unoccupied oil we have the more trucks we need
	maxTrucks = maxTrucks + numVisibleOilResInRange(-1,-1,-1) / 4;
	minTrucks = minTrucks + numVisibleOilResInRange(-1,-1,-1) / 4;

	if(bigMap)
	{
		maxTrucks = maxTrucks + 3;
		minTrucks = minTrucks + 1;
	}

	_numHaveTrucks = groupSizeCmds(buildGr,true,false,true);

	// decide how many trucks are allowed to be building derricks at a time (used to be 7)
	maxBuildOilTrucks = (_numHaveTrucks + 1) / 2;

	// max trucks building defenses at a time
	if(!haveMinTrucks()){
		maxBaseDefenseTrucks = 1;
		maxOilDefenseTrucks = max(1,_numHaveTrucks / 3);
	}else{
		maxBaseDefenseTrucks = max(2, _numHaveTrucks / 4);
		maxOilDefenseTrucks = max(1, (int)((float)_numHaveTrucks / 1.9));
	}

	if(bigMap)
	{
		if(haveMinTrucks()){
			maxOilDefenseTrucks++;
		}
	}

	// how many trucks to use for a single base defense location
	maxBaseDefendDefLocTrucks = NUM_BASE_DEF_LOC_TRUCKS;
	if(defending()){
		maxBaseDefendDefLocTrucks = MAX_BASE_DEF_LOC_TRUCKS;
	}
}

function void showVersion()
{
	dbg("Aivolution AI active for player " & me & " (version " & sVer & ")", me);	//show to the local player
}

function void storeBase()
{
	local	STRUCTURE	_structure;
	local	DROID		_truck;
	local	bool		_bHaveBaseStructs;
	local	int			_index,_baseX,_baseY,_numBaseStructs,_bucket;


	_bHaveBaseStructs = FALSE;

	//Go through all structures
	_index = 0;
	_numBaseStructs = 0;
	_baseX = 0;
	_baseY = 0;
	while(_index < numBaseStructs)
	{
		initEnumStruct(FALSE,baseStructs[_index],me,me);
		_structure = enumStruct();
		while(_structure != NULLOBJECT)
		{
			_baseX = _baseX + _structure.x / TILE;
			_baseY = _baseY + _structure.y / TILE;

			_numBaseStructs++;
			_structure = enumStruct();
		}
		_index++;
	}

	if(_numBaseStructs > 0)
	{
		baseX = (_baseX / _numBaseStructs) * TILE;
		baseY = (_baseY / _numBaseStructs) * TILE;
	}
	else
	{
		_bucket = initIterateGroupCmd(buildGr,true,false,true);		// find idle droids in build group.
		_truck = iterateGroupCmd(buildGr, _bucket);

		if(_truck != NULLOBJECT){
			baseX = _truck.x;
			baseY = _truck.y;
		}else{
			baseX = (TILE * mapWidth) / 2;
			baseY = (TILE * mapHeight) / 2;

			console("Couldn't find base location for " & getPlayerName(me));
		}
	}
}

function void fixGroups()
{
	InitEnumDroids(me,me);
	tempDroid = EnumDroid();
	while(tempDroid != NULLOBJECT)
	{
		droidLeaveGroup(tempDroid);
		tempDroid = EnumDroid();
	}
}

event diffMod(inactive)
{
	skDifficultyModifier(me);
}

function void goRTB()
{
	local int _x, _y,_index;

	dbg("Going back to base", me);

	ASSERT(sendForceX != none and sendForceY != none, "goRTB: sendForceX < 0", me);

	groupAddGroupCmd(sendAttackGr, attackGr);

	// send to the base perimeter
	_x = sendForceX;
	_y = sendForceY;

	circlePerimPoint(baseX, baseY, ref _x, ref _y, baseRange);	//move locations to the derrick perimeter

	// find a place with enough space
	pickStructLocation(powGen, ref _x, ref _y, me);

	//Order droids and commanders
	orderGroupLocCmd(sendAttackGr, DORDER_MOVE, _x, _y);

	//Move all droids and commanders to defend group
	groupAddGroupCmd(defendGr, sendAttackGr);
}

event buildStructureModel(inactive)
{
	local	STRUCTURE		_structure;
	local	int				i,j;

	i = 0;

	initEnumStruct(TRUE,wall,me,me);
	_structure = enumStruct();
	while((_structure != NULLOBJECT) and (i < maxGhosts))
	{
		/* Remember initial walls and defenses */
		if((_structure.stat == wall) or (_structure.stattype == REF_DEFENSE))
		{
			ghostStat[i] = _structure.stat;
			ghostx[i] = _structure.x;
			ghosty[i] = _structure.y;
			ghostDead[i] = FALSE;
			i = i + 1;
		}

		_structure = enumStruct();
	}

	dbg("Model saved (" & i  & ")", me);
}

function void updateBeacons()
{
	count = 0;
	while(count < 8)
	{
		if(beaconTimeout(count))	//last beacon timed out
		{
			dbg("beacon timeout for " & count, me);

			tBeacon[count] = -1;

			beaconX[count] = -1;
			beaconY[count] = -1;

			curHelpX[count] = curBase[count][0];	//restore base and help location
			curHelpY[count] = curBase[count][1];
		}
		count = count + 1;
	}
}

//---------------------------------------------------------
//	Base size
//---------------------------------------------------------
function void baseDetails()
{
	maxy = 0; maxx = 0;
	miny = (mapHeight*128); minx = (mapWidth*128);

	baseRange = 1;	//avoid possible div by 0
	aaRange = 1;

	count = 0;
	while(count < numBaseStructs)
	{
		initEnumStruct(FALSE,baseStructs[count],me,me);
		structure = enumStruct();
		while(structure != NULLOBJECT)
		{
			if(structure.x < minx){minx = structure.x;}
			if(structure.x > maxx){maxx = structure.x;}
			if(structure.y < miny){miny = structure.y;}
			if(structure.y > maxy){maxy = structure.y;}

			result = distBetweenTwoPoints(baseX, baseY, structure.x, structure.y);
			if(result > baseRange){baseRange = result;}

			structure = enumStruct();
		}
		count = count + 1;
	}

	result = 7 * 128;

	minx = minx - result; maxx = maxx + result;
	miny = miny - result; maxy = maxy + result;

	if(minx < 0){minx = 128;}
	if(miny < 0){miny = 128;}
	if(maxx > (mapWidth * 128)){maxx = (mapWidth * 128) - 128;}
	if(maxy > (mapHeight * 128)){maxy = (mapHeight * 128) - 128;}

	aaRange = baseRange + 128;		//between the base and baseRange

	baseRange = baseRange + (5 * 128);


	//baseSq = ((maxx - minx) / 128) * ((maxy - miny) / 128);
}

//---------------------------------------------------------
//	Prepare scouting routines
//---------------------------------------------------------
function void startEnemyScout()
{
	bEnemyScoutHor	= TRUE;

	//only one of these is actually used, depending on bEnemyScoutHor
	bEnemyScoutToBottom = TRUE;
	bEnemyScoutToRight = TRUE;

	getClosestCorner(baseX, baseY);			//find corner we are closest to
	x = retInt;
	y = retInt2;

	if(not mapRevealedInRange(x,y,enemyScoutRange,me))
	{
		//make this the first place scouts will visit
		enemyScoutX = x;
		enemyScoutY = y;
		//dbg("can visit corner", me);
	}
	else
	{
		dbg("can't visit corner", me);
	}

	setEventTrigger(scoutForEnemy, scoutForEnemyTr);
}

function bool finishDefenses(DROID _truck, int _repairx, int _repairy, int _maxRange)
{
	local	int			_def;
	local	STRUCTURE	_defense;
	local	bool		_bOK;

	_def = numDef - 1;
	while(!_bOK and (_def >= 0))
	{
		initEnumStruct(FALSE,def[_def],me,me);
		_defense = enumStruct();
		while(!_bOK and (_defense != NULLOBJECT))
		{
			if(!structureComplete(_defense))
			{
				if(distBetweenTwoPoints(_repairx, _repairy, _defense.x, _defense.y) < _maxRange)
				{
					if(!buildingSiteBlocked(_truck, _maxRange, _defense.x, _defense.y, true))
					{
						orderDroidStatsLoc(_truck, DORDER_BUILD, def[_def], _defense.x, _defense.y);
						dbg("finishing defense at " & (_defense.x / TILE) & "-" & (_defense.y / TILE), me);
						return true;
					}
				}
			}
			_defense = enumStruct();
		}

		_def--;
	}

	return false;
}

function void finishStructures()
{
	initIterateGroupB(buildGr, me);
	droid = iterateGroupB(buildGr, me);
	while(droid != NULLOBJECT)
	{
		if((droid.order == DORDER_NONE) or (droid.order == DORDER_RTB))
		{
			//Check all base structures first
			//-------------------------------------
			result = 99999;
			structure2 = NULLOBJECT;

			count = 0;
			while(count < numBaseStructs)
			{
				initEnumStruct(FALSE,baseStructs[count],me,me);
				structure = enumStruct();
				while(structure != NULLOBJECT)
				{
					if(not structureComplete(structure))
					{
						//Find closest one
						result3 = distBetweenTwoPoints(baseX, baseY, structure.x, structure.y);
						if(result3 < result)
						{
							//Make sure no one's building already
							//result2 = buildingSiteBlocked(NULLOBJECT, 128, structure.x, structure.y);
							//if(result2 == 0)
							if(not buildingSiteBlocked(NULLOBJECT, 128, structure.x, structure.y, false))
							{
								structure2 = structure;
								result = result3;
							}
						}
					}
					structure = enumStruct();
				}
				count = count + 1;
			}

			//Check all
			//------------------------------
			if(structure2 == NULLOBJECT)
			{
				initEnumStruct(TRUE,fac,me,me);	//all
				structure = enumStruct();
				while(structure != NULLOBJECT)
				{
					if(not structureComplete(structure))
					{
						//Find closest one
						result3 = distBetweenTwoPoints(baseX, baseY, structure.x, structure.y);
						if(result3 < result)
						{
							//Make sure no one's building already
							//result2 = buildingSiteBlocked(NULLOBJECT, 128, structure.x, structure.y);
							//if(result2 == 0)
							if(not buildingSiteBlocked(NULLOBJECT, 128, structure.x, structure.y, false))
							{
								//check for threat, since can be far from the base
								if(not threatInRange(me, structure.x, structure.y, threatRange, FALSE))
								{
									structure2 = structure;
									result = result3;
								}
							}
						}
					}
					structure = enumStruct();
				}
			}

			//Build it
			if(structure2 != NULLOBJECT)
			{
				bDummy = buildUsingClosestTruck(structure2.stat, structure2.x, structure2.y, 1);
			}


		}
		droid = iterateGroupB(buildGr, me);
	}
}

function bool canSendReinf(bool _forHelping)
{
	local	int 	_numAvailable, _minSendUnits,
					_fightRange,_numAllies,_enemyHP,_friendlyHP;
	local	int		_travelTime,_travelDist,
					_predictedEnemyReinf,_minTravelingUnits,
					_sentReinfTravelTime,_numEnemies,_sentReinfTravDist,_sendRange,
					_numReinfOnTheWay,_timeToWin,_timeToLose,
					_reinfLoseTime,_reinfWinTime;
	local	float	_enemyKillRate,_allyKillRate,_fFriendlyAvUnitFirepower,_fEnemyAvUnitFirepower,
					_fEnemyHPFactor,_fFriendlyHPFactor,_fEnemyAvUnitStrength,
					_fFriendlyAvUnitStrength,_fFriendlyFirepower,_fEnemyFirepower,
					_fNumAttackersLeft,_fNumEnemiesLeft,_fNumEffectiveReinf,
					_fNumReinfAttackersLeft,_fNumReinfEnemiesLeft,_fNumReinfLeft,
					_fReinfAvUnitStrength,_fReinfAvKillRate,_fReinfEnAvKillRate,
					_fReinfAvFirepower,_fAllyCompoundKillRate,_fEnemyCompoundKillRate,
					_fTotalAllyUnits;
	local	bool	_bWin,_bWinWithSentReinf;

	// Calculate how many units we have available
	_numAvailable = groupSizeCmds(defendGr,true,false,true) - numDefenders;	//use less units
	if(_forHelping)	//use more units if helping
	{
		_numAvailable = groupSizeCmds(defendGr,true,false,true) -
					min(minDefenders, numDefenders);	//leave only minimal number of derenders
	}

	_numAvailable = max(0,_numAvailable);

	// if(_numAvailable > 0)
	// {
		_fightRange = REINF_ENEMY_COUNT_RANGE;

		// range when sendAttackGr units get added to attackGr
		if(helpingAlly()){
			_sendRange = sendHelpRange;
		}else if(defendingOil()){
			_sendRange = REACHED_DEF_OIL_RANGE;
		}else{
			_sendRange = REACHED_DEST_RANGE;
		}

		// Calculate travel distance of the reinforcements
		_travelDist = ( max(0, distBetweenTwoPoints(sendForceX, sendForceY, baseX, baseY) -
						baseRange - defendCorridor)) / TILE;

		// Calculate travel time of the reinforcements
		_travelTime = TILE_TRAVEL_TIME * _travelDist;

		_numReinfOnTheWay = groupSizeCmds(sendAttackGr,true,false,true);

		// If there are already old reinforcements on the way to the attack location, calc how long they need to arrive
		_sentReinfTravDist = 0;
		_sentReinfTravelTime = 0;
		if(_numReinfOnTheWay > 0)
		{
			_sentReinfTravDist = distBetweenTwoPoints(sendForceX, sendForceY, groupCMD_x(sendAttackGr), groupCMD_y(sendAttackGr)) / TILE;
			if(_sentReinfTravDist > _sendRange)		//make sure won't count sendAttackGr members twice
			{
				_sentReinfTravelTime = TILE_TRAVEL_TIME * _sentReinfTravDist;
			}
		}

		// Determine number of enemy and friendly units in range
		_numEnemies = numEnemyWeapObjInRange(me, sendForceX, sendForceY, _fightRange, false, true);
		_numAllies = numFriendlyWeapObjInRange(me, sendForceX, sendForceY, _fightRange, false, true);

		// Calculate enemy and friendly strengths
		_fNumAttackersLeft = (float)_numAllies;
		_fNumEnemiesLeft = (float)_numEnemies;

		// if(_numEnemies > 0 and _numAllies > 0)
		// {
			// Calculate total hp of the weapon objects
			if(_numAllies > 0){
				_friendlyHP = totalFriendlyWeapObjHPInRange(sendForceX, sendForceY, _fightRange, false);
			}

			if(_numEnemies > 0){
				_enemyHP = totalEnemyWeapObjHPInRange(sendForceX, sendForceY, _fightRange, false);
			}

			// Find out how much stronger friendly/enemy units are compared
			// to the default unit hp used to measure default kill rate
			_fFriendlyAvUnitStrength = 0.0;
			if(_friendlyHP > 0 and _numAllies > 0){
				_fFriendlyAvUnitStrength = (float)_friendlyHP / (float)_numAllies;
			}

			_fEnemyAvUnitStrength = 0.0;
			if(_enemyHP > 0 and _numEnemies > 0){
				_fEnemyAvUnitStrength = (float)_enemyHP / (float)_numEnemies;
			}

			// _fEnemyAvUnitFirepower = _enemyPower / _numEnemies;
			// _fFriendlyAvUnitFirepower = _friendlyPower / _numAllies;

			_fFriendlyFirepower = friendlyFirepowerInRange(sendForceX, sendForceY, _fightRange);
			if(_numAllies > 0){
				_fFriendlyAvUnitFirepower = _fFriendlyFirepower / (float)_numAllies;	//can't use group here because of possible ally units
			}

			_fEnemyFirepower = enemyFirepowerInRange(sendForceX, sendForceY, _fightRange);
			if(_numEnemies > 0){
				_fEnemyAvUnitFirepower = _fEnemyFirepower / (float)_numEnemies;
			}

			// Calculate how fast units kill each other (one unit vs one enemy unit)
			if(_fEnemyAvUnitStrength > 0.0){
				_allyKillRate = _fFriendlyAvUnitFirepower / _fEnemyAvUnitStrength;
			}

			if(_fFriendlyAvUnitStrength > 0.0){
				_enemyKillRate = _fEnemyAvUnitFirepower / _fFriendlyAvUnitStrength;
			}

			// Calculate predicted number of attackers left in the attackGr when reinforcements will arrive
			_fNumAttackersLeft = (float)_numAllies;
			_fNumEnemiesLeft = (float)_numEnemies;

			_fNumAttackersLeft = secondLanchasterLaw((float)_numAllies,(float)_numEnemies,_travelTime,_allyKillRate,_enemyKillRate);
			_fNumEnemiesLeft = secondLanchasterLaw((float)_numEnemies,(float)_numAllies,_travelTime,_enemyKillRate,_allyKillRate);

			_bWin = LanchasterVictory((float)_numAllies, (float)_numEnemies, _allyKillRate, _enemyKillRate);

			// calculate how much time it will take for us to win
			if(_bWin){
				_timeToWin = LanchasterTimeToWin((float)_numAllies, (float)_numEnemies, _allyKillRate, _enemyKillRate);

				// if(_timeToWin < _travelTime)
				// {
					_fNumAttackersLeft = secondLanchasterLaw((float)_numAllies,(float)_numEnemies,_timeToWin,_allyKillRate,_enemyKillRate);
					_fNumEnemiesLeft = 0.0;
				// }
			}else{
				_timeToLose = LanchasterTimeToWin((float)_numEnemies, (float)_numAllies, _enemyKillRate, _allyKillRate);

				// if(_timeToWin < _travelTime)
				// {
					_fNumAttackersLeft = 0.0;
					_fNumEnemiesLeft = secondLanchasterLaw((float)_numEnemies,(float)_numAllies,_timeToLose,_enemyKillRate,_allyKillRate);
				// }
			}

			// How many reinforcements do we have considering their number and distance to the battlefield
			_fNumEffectiveReinf = fmax(0.0, (float)_numReinfOnTheWay - (float)_sentReinfTravelTime / (float)SECONDS_PER_DROID);

			// if we are going to lose see if reinforcements that are already on the way (!) will make it in time
			_bWinWithSentReinf = true;

			// Reinforcements vs Enemy
			//------------------------------------------
			_fReinfAvUnitStrength = 0.0;
			_fReinfAvFirepower = 0.0;
			_fReinfAvKillRate = 0.0;
			if(_numReinfOnTheWay > 0)
			{
				_fReinfAvUnitStrength = groupHP(sendAttackGr) / (float)_numReinfOnTheWay;
				_fReinfAvFirepower = groupFirepower(sendAttackGr) / (float)_numReinfOnTheWay;

				// kill rate our reinforcements vs the original enemy force
				if(_fEnemyAvUnitStrength > 0.0){
					_fReinfAvKillRate = _fReinfAvFirepower / _fEnemyAvUnitStrength;
				}

				// kill rate of the riginal enemy force vs our reinforcements
				if(_fReinfAvUnitStrength > 0.0){
					_fReinfEnAvKillRate = _fEnemyAvUnitFirepower / _fReinfAvUnitStrength;
				}
			}


			// check if reinforcements will be able to win against the enemy force
			if(!_bWin and _numReinfOnTheWay > 0)	// will lose and have reinforcements that are already on the way to the battlefield
			{
				// check if reinf will be there before we lose
				if(_sentReinfTravelTime < _timeToLose)
				{
					// calc how many units will be left when sent reinf will arrive
					_fNumReinfAttackersLeft = secondLanchasterLaw((float)_numAllies,(float)_numEnemies,_timeToLose,_allyKillRate,_enemyKillRate);
					_fNumReinfEnemiesLeft = secondLanchasterLaw((float)_numEnemies,(float)_numAllies,_timeToLose,_enemyKillRate,_allyKillRate);

					// Original attackForce + old reinforcements
					_fTotalAllyUnits = (float)_numReinfOnTheWay + _fNumReinfAttackersLeft;

					// kill rate of original attackers and reinforcements
					_fAllyCompoundKillRate = (( (float)_numReinfOnTheWay * _fReinfAvKillRate +
										_fNumReinfAttackersLeft * _allyKillRate)) / _fTotalAllyUnits;

					// kill rate of original enemy force against original ally force and reinforcements
					_fEnemyCompoundKillRate = _fEnemyAvUnitFirepower /
									(( (float)_numReinfOnTheWay * _fReinfAvUnitStrength +
										_fNumReinfAttackersLeft * _fFriendlyAvUnitStrength) / _fTotalAllyUnits);


					// try again
					_bWinWithSentReinf = LanchasterVictory(_fTotalAllyUnits, _fNumReinfEnemiesLeft,
														_fAllyCompoundKillRate, _fEnemyCompoundKillRate);

					// if we are going to lose even with reinforcements, see how many enemies will be left
					if(!_bWinWithSentReinf){
						_reinfLoseTime = 		LanchasterTimeToWin(_fNumReinfEnemiesLeft, _fTotalAllyUnits, _fEnemyCompoundKillRate, _fAllyCompoundKillRate);
						_fNumReinfEnemiesLeft = secondLanchasterLaw(_fNumReinfEnemiesLeft, _fTotalAllyUnits, _reinfLoseTime, _fEnemyCompoundKillRate, _fAllyCompoundKillRate);
					}else{
						// calc how many reinf will be left
						_reinfWinTime =  LanchasterTimeToWin(_fTotalAllyUnits, _fNumReinfEnemiesLeft, _fAllyCompoundKillRate, _fEnemyCompoundKillRate);
						_fNumReinfLeft = secondLanchasterLaw(_fTotalAllyUnits, _fNumReinfEnemiesLeft, _reinfWinTime, _fAllyCompoundKillRate, _fEnemyCompoundKillRate);
					}
				}
				else	// sent reinf will arrive after attackers are killed
				{
					// calc how many enemies will be left
					_fNumReinfEnemiesLeft = secondLanchasterLaw((float)_numEnemies,(float)_numAllies,_timeToLose,_enemyKillRate,_allyKillRate);
					_fNumReinfAttackersLeft = 0.0;

					// see if our reinfrcements will be able to win against remaining enemy troops, use corrected kill rates
					_bWinWithSentReinf = LanchasterVictory((float)_numReinfOnTheWay, _fNumReinfEnemiesLeft, _fReinfAvKillRate, _fReinfEnAvKillRate);

					// if we are going to lose even with reinforcements, see how many enemies will be left
					if(!_bWinWithSentReinf){
						_reinfLoseTime = LanchasterTimeToWin(_fNumReinfEnemiesLeft, (float)_numReinfOnTheWay, _fReinfEnAvKillRate, _fReinfAvKillRate);
						_fNumReinfEnemiesLeft = secondLanchasterLaw(_fNumReinfEnemiesLeft,(float)_numReinfOnTheWay,_reinfLoseTime,_fReinfEnAvKillRate,_fReinfAvKillRate);
					}else{
						// calc how many reinf will be left
						_reinfWinTime =  LanchasterTimeToWin((float)_numReinfOnTheWay,_fNumReinfEnemiesLeft, _fReinfAvKillRate, _fReinfEnAvKillRate);
						_fNumReinfLeft = secondLanchasterLaw((float)_numReinfOnTheWay,_fNumReinfEnemiesLeft,_reinfWinTime,_fReinfAvKillRate,_fReinfEnAvKillRate);
					}
				}
			}

		// }

		// The longer the travel distance, the more units must be sent, 1 additional unit per 10 secs
		_minTravelingUnits = _travelTime / SECONDS_PER_DROID;

		// how many enemy reinforcements must arrive - we need additional firepower to counter them
		_predictedEnemyReinf = 1;

		// we should only send more units if we are going to lose
		if(_bWin){
			_minSendUnits = _predictedEnemyReinf + _minTravelingUnits;
		}else if(!_bWin and _bWinWithSentReinf){
			_minSendUnits = _predictedEnemyReinf + _minTravelingUnits;
		}else{		// going to lose no matter what, send at least as many as they will have
			_minSendUnits = _predictedEnemyReinf +
							max(_minTravelingUnits, (int)_fNumReinfEnemiesLeft);
		}

		//_minSendUnits = _predictedEnemyReinf + max(0, (int)_fNumEnemiesLeft - (int)_fNumAttackersLeft);

		// Take old reinforcements into account
		// TODO: need a better way to model this
		// if(_numReinfOnTheWay > 0)
		// {
			// _minSendUnits = _minSendUnits - (int)_fNumEffectiveReinf;
		// }

		// Make sure there is a min number of reinforcements available
		// if(_minSendUnits < _minTravelingUnits)
		// {
			// _minSendUnits = _minTravelingUnits;
		// }
	// }

	if(watchWindowDebug == WATCH_DEBUG_REINF)
	{
		setDebugMenuEntry("time/min trav:" & _travelTime & "/" & _minTravelingUnits, 0);
		setDebugMenuEntry("# (left): " & _numAllies & "(" & _fNumAttackersLeft &  ")/" & _numEnemies & "(" & _fNumEnemiesLeft & ")", 1);

		setDebugMenuEntry("hp:" & (int)_fFriendlyAvUnitStrength & " (" & _friendlyHP &
						") / " & (int)_fEnemyAvUnitStrength & " (" & _enemyHP & ")" , 2);

		setDebugMenuEntry("dam:" & _fFriendlyAvUnitFirepower & " (" &
						(int)_fFriendlyFirepower & ") / " & _fEnemyAvUnitFirepower &
						" (" & (int)_fEnemyFirepower & ")" , 3);

		setDebugMenuEntry("kill rate: " & _allyKillRate & " / " & _enemyKillRate , 4);

		setDebugMenuEntry("old r/time: " & _numReinfOnTheWay & "(" & _sentReinfTravelTime & ")" , 5);
		setDebugMenuEntry("o r kill rate: " & _fReinfAvKillRate & "/" & _fReinfEnAvKillRate, 6);
		setDebugMenuEntry("*min send*/avail: " & _minSendUnits & " (" & _numAvailable & ")", 7);

		if(_bWin){
			setDebugMenuEntry("win in " & ((float)_timeToWin / (float)MINUTE) & " mins", 8);
			setDebugMenuEntry("left: " & _fNumAttackersLeft, 9);
		}else if(!_bWin and _bWinWithSentReinf){
			//will reinf arrive before al lattackers are lost?
			if(_sentReinfTravelTime < _timeToLose){
				setDebugMenuEntry("reinf win+:" & ((float)_timeToLose / (float)MINUTE) & "+" & ((float)_reinfWinTime / (float)MINUTE), 8);
				setDebugMenuEntry("left:" & _fNumReinfLeft & "+" & _fNumReinfAttackersLeft & "(" & _fAllyCompoundKillRate & "/" & _fEnemyCompoundKillRate & ")", 9);
			}else{
				setDebugMenuEntry("reinf win-:" & ((float)_timeToLose / (float)MINUTE) & "+" & ((float)_reinfWinTime / (float)MINUTE), 8);
				setDebugMenuEntry("reinf left:" & _fNumReinfLeft & "(" & _fNumReinfEnemiesLeft & ")", 9);
			}
		}else{
			//will reinf arrive before al lattackers are lost?
			if(_sentReinfTravelTime < _timeToLose){
				setDebugMenuEntry("no chance+:" & ((float)(_timeToLose - _sentReinfTravelTime) / (float)MINUTE) & "+" & ((float)_reinfLoseTime / (float)MINUTE), 8);
			}else{
				setDebugMenuEntry("no chance-:" & ((float)_timeToLose / (float)MINUTE) & "+" & ((float)_reinfLoseTime / (float)MINUTE), 8);
			}
			setDebugMenuEntry("en left: " & _fNumReinfEnemiesLeft, 9);
		}


	}


	// make sure there will be any attackers left when reinforcements will arrive
/* 	if(_fNumAttackersLeft <= 0.0)
	{
		return false;
	} */

	if(_numAvailable < _minSendUnits)
	{
		return false;
	}

	return true;

/* 	_numAvailable = groupSizeCmds(defendGr,true,false,true) - numDefenders;	//use less units
	if(_forHelping)	//use more units if helping
	{
		_numAvailable = groupSizeCmds(defendGr,true,false,true) -
					min(minDefenders, numDefenders);	//leave only minimal number of derenders
	}

	_minSendUnits = minReinforcements;
	if(_forHelping)
	{
		// if we wait for more units ally can get killed
		_minSendUnits = min(MIN_HELPING_ALLY_REINF, minReinforcements);
	}

	if((_numAvailable >= _minSendUnits) or
		((_numAvailable >= (_minSendUnits / 2)) and
		(groupSizeCmds(attackGr,true,false,true) >= (numAttackers / 2))) )	//enough reinf, or still many attackers and some reinf
	{
		return TRUE;
	}

	return FALSE; */
}

//----------------------------------------------------------
//			stop state
//----------------------------------------------------------
function void stopState()
{
	if(state == stAttacking)
	{
		stopAttack();
	}
	else if(defending())
	{
		stopDefending();
	}
	else if(defendingOil())
	{
		stopDefendingOil();
	}
	else if(helpingAlly())
	{
		stopAllyDefense();
	}
	else if(state == stJoiningForces)
	{
		stopJoiningForces();
	}
	else if(state == stTakingOil)
	{
		stopTakingOil();
	}
	else if(state == stCollecting)
	{
		stopCollecting();
	}
	else if(state == stTransporting)
	{
		stopTransportState();
	}
	else if(state == stDrop)
	{
		stopDropState();
	}
	else if(state != stNone)
	{
		MsgBox("stopState() - unknown state");
	}
}

function void cancelState()
{
	if(state == stAttacking)
	{
		cancelAttack();
	}
	else if(state == stDefending)
	{
		cancelDefending();
	}
	else if(defendingOil())
	{
		cancelDefendingOil();
	}
	else if(state == stHelpingAlly)
	{
		cancelAllyDefense();
	}
	else if(state == stJoiningForces)
	{
		cancelJoiningForces();
	}
	else if(state == stTakingOil)
	{
		cancelTakingOil();
	}
	else if(state == stCollecting)
	{
		cancelCollecting();
	}
	else if(state == stTransporting)
	{
		cancelTransportState();
	}
	else if(state == stDrop)
	{
		cancelDropState();
	}
	else if(state != stNone)
	{
		MsgBox("cancelState() - unknown state");
	}
}

function void endState()
{
	if(state == stAttacking)
	{
		endAttack();
	}
	else if(state == stDefending)
	{
		endDefending();
	}
	else if(defendingOil())
	{
		endDefendingOil();
	}
	else if(state == stHelpingAlly)
	{
		endAllyDefense();
	}
	else if(state == stJoiningForces)
	{
		endJoiningForces();
	}
	else if(state == stTakingOil)
	{
		endTakingOil();
	}
	else if(state == stTransporting)
	{
		endTransportState();
	}
	else if(state == stDrop)
	{
		endDropState();
	}
	else if(state != stNone)
	{
		MsgBox("endState() - unknown state");
	}
}


function void pauseState()
{
	if(state == stNone){exit;}

	/* only stAttacking is paused, otherwise just stop doing what we were doing */
	if(state != stAttacking)
	{
		cancelState();
		exit;
	}		//only stAttacking for now

	dbg("PAUSING CURRENT STATE!!!!!!!!!!!!!!!!!!", me);

	/* cancelState() will reset enemy and stat, so remember now */
	lastStateTemp = state;
	lastEnemyTemp = enemy;

	cancelState();

	lastState = lastStateTemp;
	lastEnemy = lastEnemyTemp;
}

function void resumeState()
{
	if(lastState == stAttacking)
	{
		if((not allianceExistsBetween(lastEnemy ,me)) and knowBase[lastEnemy])
		{
			dbg("Resuming attack: at enemy: " & lastEnemy, me);

			groupAddGroupCmd(defendGr, attackGr);
			groupAddGroupCmd(defendGr, sendAttackGr);

			setState(lastState);

			//HACK: resume with curBase[], actually must remember last attack x and y
			if(knowBase[lastEnemy])
			{
				startAttack(lastEnemy, curBase[lastEnemy][0], curBase[lastEnemy][1]);
				requestStartAttack(lastEnemy, curBase[lastEnemy][0], curBase[lastEnemy][1]);
			}
		}
	}

	/* clear vars */
	erasePausedState();
}

function void erasePausedState()
{
	lastState = stNone;
	lastEnemy = none;
}

function int findAllyInTrouble()
{
	_temp = 0;
	_temp2 = 99999;
	_temp4 = none;	//ally in trouble
	while(_temp < multiPlayerMaxPlayers)
	{
		if(ally[_temp] and (not dead[_temp]) and (allyState[_temp] == stDefending))
		{
			//if(knowBase[_temp])
			if(curHelpX[_temp] > 0)	//have help location
			{
				//_temp3 = distBetweenTwoPoints(baseX, baseY, curBase[_temp][0], curBase[_temp][1]);
				_temp3 = distBetweenTwoPoints(baseX, baseY, curHelpX[_temp], curHelpY[_temp]);
				if(_temp3 < _temp2)		//this ally is closer
				{
					_temp4 = _temp;
					_temp2 = _temp3;
				}
			}
		}
		_temp = _temp + 1;
	}

	return(_temp4);
}

//----------------------------------------------------------
//			stop defending
//----------------------------------------------------------
function void stopDefending()
{
	local	bool	_busy;

	_busy = FALSE;

	endDefending();

	dbg("DEFEND: stopped", me);

	/* If we were doing something before defending, resume it */
	if(lastState != stNone)
	{
		_busy = TRUE;
		resumeState();
	}

	/* now that we are ok, check if can help our ally, if someone's in trouble */
	if(not _busy)	//didn't resume state
	{
		temp = totalWeapUnits();
		if(temp > minAllyHelpers)
		{
			temp = findAllyInTrouble();		//see if any of our allies is in trouble
			if(temp != none)
			{
				notifyAllies(getPlayerName(temp) & ", coming now, hold on", false);

				_busy = TRUE;

				startHelpAlly(temp,curHelpX[temp],curHelpY[temp]);
			}
		}
	}

	/* Return to base if idle */
	if(not _busy)
	{
		goRTB();
		resetSendForceCoords();
	}

	/* play cool
	if(random(2) == 0)
	{
		if(random(2) == 0){notifyAllies("they suck", TRUE);}
		else{notifyAllies("bwuhaha", TRUE);}
	}*/

	/* Check ally status */
	checkRequestStatus();
}

function void cancelDefending()
{
	erasePausedState();		//don't resume since cancelled

	endDefending();

	goRTB();

	resetSendForceCoords();

	dbg("DEFEND: cancelled defending", me);
}

function void endDefending()
{
	deselectAllDroids();

	setState(stNone);

	phase = phNone;
	enemy = none;
	counterEnemy = none;

	requestHelpTime = 0;

	/* reset notification stuff */
	bNotifiedReadyAttack = FALSE;
	notifyReadyAttackTime = 0;
}


//----------------------------------------------------------
//			stop taking oil
//----------------------------------------------------------
function void stopTakingOil()
{
	dbg("TAKE OIL: stopped", me);

	endTakingOil();

	/* If we were doing something before helping ally, resume it */
	if(lastState != stNone)
	{
		resumeState();
	}
	else
	{
		goRTB();
		resetSendForceCoords();
		checkRequestStatus();
	}
}

function void cancelTakingOil()
{
	erasePausedState();		//don't resume since cancelled

	endTakingOil();

	goRTB();

	resetSendForceCoords();

	dbg("TAKE OIL: cancelled", me);
}

function void endTakingOil()
{
	deselectAllDroids();

	setState(stNone);

	phase = phNone;
	enemy = none;

	timeGuardPos = 0;
	tTakeOil = 0;

	/* reset notification stuff */
	bNotifiedReadyAttack = FALSE;
	notifyReadyAttackTime = 0;
}

//----------------------------------------------------------
//			stop defending oil
//----------------------------------------------------------
function void stopDefendingOil()
{
	dbg("DEFENDING OIL: stopped", me);

	endDefendingOil();

	/* If we were doing something before helping ally, resume it */
	if(lastState != stNone)
	{
		resumeState();
	}
	else
	{
		goRTB();
		resetSendForceCoords();
		checkRequestStatus();
	}
}

function void endDefendingOil()
{
	deselectAllDroids();

	setState(stNone);

	phase = phNone;
	enemy = none;

	// reset coordinates of the attacked derrick
	resetOilDefendCoords();
}

function void cancelDefendingOil()
{
	erasePausedState();		//don't resume since cancelled

	endDefendingOil();

	goRTB();

	resetSendForceCoords();

	dbg("DEFENDING OIL: cancelled", me);
}

//----------------------------------------------------------
//			stop joining forces
//----------------------------------------------------------
function void stopJoiningForces()
{
	dbg("JOINING FORCES: stopped", me);

	endJoiningForces();

	/* If we were doing something before defending, resume it */
	if(lastState != stNone)
	{
		resumeState();
	}
	else
	{
		goRTB();
		resetSendForceCoords();
	}
}

function void cancelJoiningForces()
{
	erasePausedState();		//don't resume since cancelled

	goRTB();

	resetSendForceCoords();

	endJoiningForces();

	dbg("JOINING FORCES: cancelled", me);
}

function void endJoiningForces()
{
	deselectAllDroids();

	setState(stNone);

	phase = phNone;
	enemy = none;

	timeGuardPos = 0;	//reset

	/* reset notification stuff */
	bNotifiedReadyAttack = FALSE;
	notifyReadyAttackTime = 0;
}

//----------------------------------------------------------
//			stop ally defense
//----------------------------------------------------------
function void stopAllyDefense()
{
	endAllyDefense();

	dbg("stopped helping ally !!!!!!!!!!!!!!!!!!!!!!!!", me);

	/* If we were doing something before helping ally, resume it */
	if(lastState != stNone)
	{
		resumeState();
	}
	else
	{
		goRTB();

		resetSendForceCoords();
	}
}

function void cancelAllyDefense()
{
	erasePausedState();		//don't resume since cancelled

	endAllyDefense();

	goRTB();

	resetSendForceCoords();

	dbg("ALLY DEFENSE: cancelled", me);
}

function void endAllyDefense()
{
	deselectAllDroids();

	enemy = none;			//allyInThreat

	helpTime = 0;

	/* reset notification stuff */
	bNotifiedReadyAttack = FALSE;
	notifyReadyAttackTime = 0;

	setState(stNone);

	phase = phNone; //phRTB;
}

//----------------------------------------------------------
//			stop attack
//----------------------------------------------------------
function void stopAttack()
{
	endAttack();

	dbg("ATTACK: stopped", me);

	/* If we were doing something before attacking, resume it */
	if(lastState != stNone)
	{
		resumeState();
	}
	else
	{
		goRTB();
		resetSendForceCoords();
		checkRequestStatus();
	}
}

function void cancelAttack()
{
	erasePausedState();		//don't resume since cancelled

	endAttack();

	goRTB();

	resetSendForceCoords();

	dbg("ATTACK: cancelled", me);
}

function void endAttack()
{
	deselectAllDroids();

	setState(stNone);

	enemy = none;

	phase = phNone; //phRTB

	reinfTime = 0;	//timer

	countTakeOil = 0;		//allow hunting oil again

	/* reset notification stuff */
	bNotifiedReadyAttack = FALSE;
	notifyReadyAttackTime = 0;

	numTakeOil = random(maxTakeOil);	//allow attacking oil again
}

function void resetSendForceCoords()
{
	sendForceX = none;
	sendForceY = none;
}

//--------------------------------------
//	Transport
//--------------------------------------
function void stopTransportState()
{
	endTransportState();	//first end then load otherwise endTransportState will reset state

	phase = phTransportDone;	//make sure drop state knows that transport finished successfully
	loadSavedState();
}

function void cancelTransportState()
{
	dbg("cancelTransportState", me);

	eraseLoadSavedState(); 	//since cancelled

	temp = 0;
	while(temp < maxTransporters)
	{
		if(transporter[temp] != NULLOBJECT)
		{
			//temp = isInMyBase(transporter[temp].x, transporter[temp].y);
			if((not transporterFlying(transporter[temp])) and isInMyBase(transporter[temp].x, transporter[temp].y))	//landed inside of the base
			{
				dbg("unloading transporter", me);
				unloadTransporter(transporter[temp], transporter[temp].x, transporter[temp].y);
			}
			else	//Send to unload in the base
			{
				dbg("ordering transporter to disembark in the base", me);
				orderTranspDisembark(transporter[temp], baseX, baseY);		//make unload units in the base
			}

		}
		temp = temp + 1;
	}

	notifyCantDrop();

	checkRequestStatus();

	deselectAllDroids();
	goRTB();			//only sends sendAttackGr home, not transportGr

	prepareTransporters();	//send transporters back to base

	endTransportState();

	resetSendForceCoords();

	enemy = none;		//must be done here, since not done in endTransportState()
}

function void endTransportState()
{
	dbg("endTransportState", me);

	groupAddGroupCmd(defendGr, transportGr);	//return unloaded units to defenders or if state cancelled

	transportX = none;
	transportY = none;

	tWaitLoadDrop = 0;

	setState(stNone);
	phase = phNone;

	//enemy = none;
}

//--------------------------------------
//	Drop
//--------------------------------------
function void stopDropState()
{
	endDropState();
	dbg("DROP: stopped !!!", me);

	/* If we were doing something before dropping, resume it */
	if(lastState != stNone)
	{
		resumeState();
	}
	else
	{
		/* we started the drop directly, not from a different state, so just start attacking the enemy */
		enemy = enemy;		//shouldn't change
		if(knowBase[enemy])
		{
			//HACK resume with curBase[], since didn't save last attack x and y coords
			startAttack(enemy, curBase[enemy][0], curBase[enemy][1]);
			requestStartAttack(enemy, curBase[enemy][0], curBase[enemy][1]);
		}
	}
}

function void cancelDropState()
{
	erasePausedState();		//don't resume since cancelled

	enemy = none;		//should be cleard here?

	dropStartTime = none;	//doesn't belong to endDropState()
	tSyncDrop = 0;		//doesn't belong to endDropState()

	endDropState();

	dbg("DROP: cancelled !!!", me);
}

function void endDropState()
{
	setState(stNone);
	phase = phNone;

	if(enemy != none)
	{
		tempReinfCount[enemy] = 0;		//start over
	}
}

//----------------------------------------------------------
//			stop collecting
//----------------------------------------------------------
function void stopCollecting()
{
	collectTime = 0;

	setState(stNone);
	phase = phNone;

	collectX = none;
	collectY = none;

	dbg("COLLECT: stopped", me);
}

function void cancelCollecting()
{
	stopCollecting();
}

function void setTechBranch()
{
	tech = 0;	//random(numBranches);	//FIXME
}

function bool pendingLasSatStrike()
{
	local int _tempPlayer;

	_tempPlayer = 0;
	while(_tempPlayer < 8)
	{
		if(allianceExistsBetween(_tempPlayer, me))
		{
			if(lasSatState[_tempPlayer] == lsWaitingReply)	//someone requested lassat strike?
			{
				return TRUE;
			}
		}
		_tempPlayer = _tempPlayer + 1;
	}

	return FALSE;
}

function void updateLasSat()
{
	local STRUCTURE _lasSatTarget;

	/* check if finished recharging lassat */
	if(lasSatState[me] == lsRecharging)	//only recharge if we built lasSat already and are not recharged already (would reset waiting state)
	{
		if(tLasSat >= tLasSatReady)		//ready
		{
			dbg("lassat ready**********************", me);
			lasSatState[me] = lsReady;
		}
	}

	if(lasSatState[me] == lsReady)
	{
		if(pendingLasSatStrike())
		{
			dbg("LASSAT: joining ****************", me);
			lasSatState[me] = lsRequesterWaitingRecharging;	//join and tell that lassat is ready
		}
		else
		{
			notifyAllies("let's lassat someone", TRUE);
			dbg("notified allies**********************", me);
			lasSatState[me] = lsWaitingReply;		//wait to find out if anyone wants to join
			tLasSatCountdown = tLasSatReplyMax;		//start countdown
		}
	}

	if(lasSatState[me] == lsWaitingReply)
	{
		if(tLasSatCountdown <= 0)		//waited enough for allies to reply to lassat request
		{
			dbg("notified allies countdown: time is up********", me);
			lasSatState[me] = lsWaiting;	//wait for allies to finish recharging lassat
			tLasSatCountdown = tLasSatWaitAlliesMax;			//start wait for allies countdown
		}
	}

// start 'someone requested lassat strike' code

	/* someone requested lassat and waiting for us to finish recharging lassat */
	if(lasSatState[me] == lsRequesterWaitingRecharging)
	{
		/* check if finished recharging lassat */
		if(tLasSat >= tLasSatReady)		//ready
		{
			notifyAllies("lassat ready", FALSE);	//tell them lassat is ready, so that requester can start the strike if everyone else is ready too
			lasSatState[me] = lsWaitingForRequester;
			tLasSatCountdown = tLasSatWaitAlliesMax;		//wait for requester to start lassat strike
		}
	}

	/* we finished recharging our lassat and are now waiting for the requester to start the strike */
	if(lasSatState[me] == lsWaitingForRequester)
	{
		/* check if we waited to long, if yes, start the attack on our own */
		if(tLasSatCountdown <= 0)	//requester got killed? etc
		{
			dbg("waited too long for the requester, firing*************", me);
			lasSatState[me] = lsFiring;	//just fire, don't wait anymore
		}
	}

// end 'someone requested lassat strike' code

	/* all allies ready to fire? */
	if(lasSatState[me] == lsWaiting)
	{
		//tLasSatCountdown = off;		//not needed anymore

		dbg("lsWaiting: waiting...********", me);
		if(allyLasSatReady() or (tLasSatCountdown <= 0))	//if everyone can fire or waited too long
		{
			if(allyLasSatReady())
			{
				dbg("lsWaiting: firing now0********", me);
			}
			else if(tLasSatCountdown <= 0)
			{
				dbg("lsWaiting: firing now1********", me);
			}

			lasSatState[me] = lsFiring;
		}
	}

	/* everyone's ready or waited too long, fireing now! */
/*
	if(lasSatState[me] == lsFiring)
	{
		_lasSatTarget = findLasSatTarget(enemy);

		if(_lasSatTarget != NULLOBJECT)
		{
			dbg("lsFiring: found target********", me);
			fireLasSat(_lasSatTarget);
		}
		else
		{
			dbg("lsFiring: couldn't find target********", me);
		}
	}
*/
}

/*
function void fireLasSat(STRUCTURE _targetStructure)
{
	//TODO: must select lasSat if debugging otherwise WZ wouldn't let fire if AI is played as selectedPlayer (human)
	//if(DEBUG_OBSERVE and (me == selectedPlayer))
	//{
	//	selectStructure(_targetStructure, TRUE);
	//}

	skFireLassat(me, _targetStructure);
	notifyLassat(_targetStructure);

	resetLasSat();		//reset all counters etc
	lasSatState[me] = lsRecharging;		//start recharging lassat (after resetLasSat() !)
}
*/

function void notifyLassat(STRUCTURE _targetStructure)
{
	notifyAllies("let's lassat " & getPlayerName(_targetStructure.player), TRUE);		//tell allies who to lassat

	dropAllyBeacon("lassat " & getPlayerName(_targetStructure.player), _targetStructure.x, _targetStructure.y);
}

function bool allyLasSatReady()
{
	local int _tempPlayer;

	/* did we wait too long for allies' lassat to finish recharging? */
	//if(tLasSatWaitAllies >= tLasSatWaitAlliesMax)
	//{
	//	return TRUE;
	//}

	/* find out if we are still waiting for someone's lassat to recharge */
	_tempPlayer = 0;
	while(_tempPlayer < 8)
	{
		if(allianceExistsBetween(_tempPlayer, me))
		{
			if(lasSatState[_tempPlayer] == lsRequesterWaitingRecharging)
			//if((lasSatState[_tempPlayer] != lsRecharging) and (lasSatState[_tempPlayer] != lsWaitingForRequester))//ignore those who don't strike with us
			{
				dbg("LASSAT: " & getPlayerName(_tempPlayer) & " not ready********", me);
				return FALSE;		//someone is still recharging lassat or this is the first time we are checking and thex haven't enterd "lsRequesterWaitingRecharging" yet
			}
		}

		_tempPlayer = _tempPlayer + 1;
	}

	return TRUE;
}

function void resetLasSat()
{
	local int _tempPlayer;

	lasSatState[me] = lsNone;
	lasSatEnemy = none;

	tLasSat = 0;				//start recharging
	tLasSatCountdown = off;		//reset the misc timer

	//_tempPlayer = 0;
	//while(_tempPlayer < 8)
	//{
	//	lasSatState[_tempPlayer] = lsNone;
	//	_tempPlayer = _tempPlayer + 1;
	//}
}

function STRUCTURE findLasSatTarget(int _prefferedEnemy)
{
	local int _tempPlayer,_bestDist,_tempDist;
	local	STRUCTURE	_targetStruct,_tempStruct;

	_targetStruct = NULLOBJECT;

	if(_prefferedEnemy >= 0)
	{
		_targetStruct = mostDamagedBaseStructure(_prefferedEnemy);
	}

	/* check all other enemies */
	if(_targetStruct == NULLOBJECT)
	{
		/* find closest target */
		_bestDist = 99999;
		_tempPlayer = 0;
		while(_tempPlayer < 8)
		{
			if((not allianceExistsBetween(_tempPlayer, me)) and (_tempPlayer != me))
			{
				_tempStruct = mostDamagedBaseStructure(_tempPlayer);


				if(_tempStruct != NULLOBJECT)
				{
	//dbg("mostDamagedBaseStructure(" & _tempPlayer & "): not NULL!! ", me);
					/* check if new one is closer */
					_tempDist = distBetweenTwoPoints(baseX, baseY, _tempStruct.x, _tempStruct.y);
					if(_tempDist < _bestDist)
					{
						//dbg("findLasSatTarget: assigned struct********", me);
						_targetStruct = _tempStruct;
						_bestDist = _tempDist;
					}
				}
				//else
				//{
				//	dbg("mostDamagedBaseStructure: NULL ", me);
				//}
			}

			_tempPlayer = _tempPlayer + 1;
		}
	}

	return _targetStruct;
}

function STRUCTURE mostDamagedBaseStructure(int _targetPlayer)
{
	local	int			_structTypeIndex,_lowestHP,_tempHP;
	local	STRUCTURE	_returnStruct,_tempStruct;

	_structTypeIndex = 0;
	_lowestHP = 99999;
	_returnStruct = NULLOBJECT;

	while(_structTypeIndex < numBaseStructs)
	{
		initEnumStruct(FALSE,baseStructs[_structTypeIndex],_targetPlayer,me);

		_tempStruct = enumStruct();
		while(_tempStruct != NULLOBJECT)
		{
			_tempHP = _tempStruct.health;
			if(_tempHP < _lowestHP)
			{
				_lowestHP = _tempHP;
				_returnStruct = _tempStruct;
			}

			_tempStruct = enumStruct();
		}

		_structTypeIndex = _structTypeIndex + 1;
	}

	return _returnStruct;
}

function int checkAllyThreat()
{
	//return value - player in danger

	range = (23 * 128);

	if(state == stHelpingAlly){return(enemy);}		//already defending

	count = 0;
	while(count < multiPlayerMaxPlayers)
	{
		if(ally[count])
		{
			if(knowBase[count])		//know where his base is?
			{
				result = numEnemyWeapObjInRange(me, curBase[count][0], curBase[count][1], range, false, true);
				result2 = numFriendlyWeapObjInRange(me, curBase[count][0], curBase[count][1], range, false, true);

				if(result > result2)
				{
					//if(enemy == none)	//don't suddenly switch the player, only if not already set	//allyInThreat
					//{
						dbg("ally " & count & " is in danger", me);
						//enemy = count;	//allyInThreat
						//exit;	//must exit here
						return(count);
					//}
				}
				//else if(result < 4)		//we have much more and they only < 4
				//{
				//	if(mapRevealedInRange(curBase[count][0],curBase[count][1],(5 * 128),me))	//can judge if safe only if can see the base
				//	{
				//		if(allyInThreat == count)	//same we were helping
				//		{
				//			dbg(" " & me & ")  HELP ALLY: this player seems to be safe now");
				//			allyInThreat = none;	//can stop helping now
				//			exit;	//must exit here
				//		}
				//	}
				//}
			}
		}

		count = count + 1;
	}

	return(none);	//nothing found
}

function void startDefending(int _counterEnemy)
{
	if((state != stNone) and !defending())	//units busy with something else
	{
		dbg("BASE: we need our units in the base now, cancel current state", me);
		cancelState();
	}

	requestHelpTime = 0;	//reset since started over

	setState(stDefending);
	phase = phMoveToLoc;

	sendForceX = baseX;	//move to base
	sendForceY = baseY;

	enemy = me;
	counterEnemy = _counterEnemy;

	dbg("DEFENDING: defend mode on (enemy = " & counterEnemy & ")", me);
}

function void startHelpAlly(int _allyToHelp, int _helpx, int _helpy)
{
	enemy = _allyToHelp;		//store it in the enemy var, since he invoked this state

	/* Calculate some place on the base edge (my base -> help dest), so won't block the inner of the base */
	sendForceX = baseX;
	sendForceY = baseY;
	circlePerimPoint(_helpx, _helpy, ref sendForceX, ref sendForceY, sendHelpRange);

	//sendForceX = _helpx;	//curBase[enemy][0];	//allyInThreat
	//sendForceY = _helpy;	//curBase[enemy][1];	//allyInThreat

	if((sendForceX <= 0) or (sendForceY <= 0))
	{
		MsgBox("startHelpAlly() - sendForceX <= 0");
		exit;
	}

	setState(stHelpingAlly);
	phase = phMoveToLoc;

	helpTime = maxHelpTime;		//limited time we can help this ally or can stuck forever

	/* Set minimum number of defenders to leave in the base */
	updateNumDefenders();

	dbg("helping " & getPlayerName(enemy) & " !!!!!!!!!!!!!!!!!!!!!!!!", me);	//allyInThreat

	/* Add required number of units from defendGr to sendAttackGr */
	fillHelpers();

	//selectGroup(sendAttackGr, TRUE);


	//ToDo: <check if enough attackers and send to the ally player base>
	//ToDo: <send message to ally>

	//orderGroupLoc(sendAttackGr, DORDER_SCOUT, curBase[enemy][0], curBase[enemy][1]);	//allyInThreat
}

function void manageHelpAlly()
{
	local bool _bFoundTarget;

	ASSERT(enemy >= 0, "manageHelpAlly: wrong ally index (" & enemy & ")", me);

	dbg("manageHelpAlly", me);

	if(enemy == none)
	{
		stopAllyDefense();
		ASSERT(FALSE,"manageHelpAlly() - no player set", me);
		exit;
	}

	if((sendForceX <= 0) or (sendForceY <= 0))
	{
		notifyAllies(getPlayerName(enemy) & ", I can't see your base", false);	//allyInThreat
		//notifyAllies(getPlayerName(enemy) & ", give vision" , false);	//allyInThreat
		ASSERT(FALSE, "manageHelpAlly - (sendForceX <= 0) or (sendForceY <= 0)", me);

		stopAllyDefense();

		//MsgBox("manageHelpAlly() - sendForceX not initialized");
		exit;
	}

	if(not knowBase[enemy])		//no visible structures left for this ally
	{
		notifyAllies(getPlayerName(enemy) & ", I don't see your base" , false);	//allyInThreat
		dbg("manageHelpAlly - not haveBase", me);

		stopAllyDefense();
		exit;
	}

	//--------------------------------------
	//Manage Attack
	//--------------------------------------
	if(phase == phAttackingLoc)
	{
		/* Attack any ally's base intruders */
		defendArea(attackGr, sendHelpRange, sendForceX, sendForceY, defendCorridor, 1);
	}
}

//--------------------------------------------------------
//Add required number of units from defendGr to attackGr
//--------------------------------------------------------
/*  function void fillAttackers(bool _highPriorityTask)
{
	local	int		_numDefenders;
	//_highPriorityTask - if task is a high priority, then use more units

	//don't leave BBs in defend group
	sortOutBBs();

	_numDefenders = groupSizeCmds(defendGr,false,true) - numDefenders;
	if(_highPriorityTask)
	{
		_numDefenders = groupSizeCmds(defendGr,false,true) - minDefenders;	//leave less units in the base
	}

	initIterateGroupCmd(defendGr,true,false,false);
	tempDroid = iterateGroupCmd(defendGr);
	while((tempDroid != NULLOBJECT) and (_numDefenders > 0))	//leave 'numDefenders' number of units in the defendGr
	{
		groupAddDroid(sendAttackGr, tempDroid);
		_numDefenders = _numDefenders - 1;
		tempDroid = iterateGroupCmd(defendGr);
	}

	selectGroup(sendAttackGr, TRUE);
} */

function void fillAttackers(int _numAttackers)
{
	local	DROID	_droid;
	local	int 	_bucket,_numBBs;

	//don't leave BBs in defend group
	_numBBs = sortOutBBs();

	// subtract BBs
	_numAttackers = _numAttackers - _numBBs;

	_bucket = initIterateGroupCmd(defendGr,true,false,true);
	_droid = iterateGroupCmd(defendGr, _bucket);
	while((_droid != NULLOBJECT) and (_numAttackers > 0))
	{
		groupAddDroid(sendAttackGr, _droid);
		_numAttackers--;
		_droid = iterateGroupCmd(defendGr, _bucket);
	}

	selectGroup(sendAttackGr, TRUE);
}

function int numAttackersFromPriorty(bool _highPriorityTask)
{
	local int	_numAttackers;


	if(_highPriorityTask)
	{
		_numAttackers = groupSizeCmds(defendGr,true,false,true) - minDefenders;	//leave less units in the base
	}
	else
	{
		_numAttackers = groupSizeCmds(defendGr,true,false,true) - numDefenders;
	}

	return _numAttackers;
}

//--------------------------------------------------------
//Add required number of units from defendGr to attackGr
//--------------------------------------------------------
function void fillReinforcements(bool _bHelping)
{
	dbg("MANAGE UNITS: sending reinforcements", me);

	//fillAttackers(numAttackersFromPriorty(_bHelping));	//reinforcements have high priority ONLY if defendig ally

	prepareAttackers(_bHelping);

	//Take care of statistic stuff
	if((state != stTakingOil) and !helpingAlly() and !defendingOil())
	{
		reinfCount[enemy] = reinfCount[enemy] + 1;
		tempReinfCount[enemy] = tempReinfCount[enemy] + 1;
	}

	if((state == stAttacking) or (state == stTakingOil))
	{
		reinfTime = maxReinfTime;	//restart "cancel attack" countdown
	}
}

function void fillHelpers()
{
	// prepare helpers
	prepareAttackers(true);

/*	//don't leave BBs in defend group
	sortOutBBs();

	temp = groupSizeCmds(defendGr,true,false,true) - minDefenders;		//send more units if sent not enough

	if((temp + groupSizeCmds(attackGr,true,false,true) + groupSizeCmds(sendAttackGr,true,false,true)) > (numDefenders * 3))
	{
		temp = groupSizeCmds(defendGr,true,false,true) - numDefenders;
	}

	initIterateGroupCmd(defendGr,true,true,false);
	tempDroid = iterateGroupCmd(defendGr);
	while((tempDroid != NULLOBJECT) and (temp > 0))	//leave 'numDefenders' number of units in the defendGr
	{
		groupAddDroid(sendAttackGr, tempDroid);
		temp = temp - 1;
		tempDroid = iterateGroupCmd(defendGr);
	}

	selectGroup(sendAttackGr, TRUE);
*/
}

//---------------------------------------------------------
//	For all trucks with build orders, if there's a
//	closer idle truck, use it instead
//---------------------------------------------------------
function void closerTruck()
{
	range = (25 * 128);

	initIterateGroupB(buildGr, 0);
	droid = iterateGroupB(buildGr, 0);
	while(droid != NULLOBJECT)
	{
		//if((droid.action == DACTION_MOVETOBUILD) and (droid.stat != NULLSTAT))		//has a build order
		if(droid.action == DACTION_MOVETOBUILD)
		{
			//pointless, if too close already
			result = distBetweenTwoPoints(droid.orderx, droid.ordery, droid.x, droid.y);
			if(result > range)		//will build soon
			{

				//now check if we have a droid closer to the build pos
				initIterateGroupB(buildGr, 1);
				droid2 = iterateGroupB(buildGr, 1);
				while(droid2 != NULLOBJECT)
				{
					if((droid2.order == DORDER_NONE) or (droid2.order == DORDER_RTB))
					{
						result2 = distBetweenTwoPoints(droid.orderx, droid.ordery, droid2.x, droid2.y);
						if((result - result2) > range)	//the second one is much closer
						{
							//build what first droid was going to build

							//dbg(" " & me & ")  found a much closer droid at " & (droid.x / 128) & ", " & (droid.y / 128));
							orderDroidStatsLoc(droid2, DORDER_BUILD, droid.stat, droid.orderx, droid.ordery);
							orderDroid(droid, DORDER_RTB);	//send back to base
						}
					}
					droid2 = iterateGroupB(buildGr, 1);
				}
			}
		}

		droid = iterateGroupB(buildGr, 0);
	}
}

function STRUCTURE closestDerrick(int _x, int _y)
{
	local	int				_bestDist,_tempDist;
	local	STRUCTURE		_closestDerrick,_tempDerrick;

	_bestDist = 99999;

	_closestDerrick = NULLOBJECT;

	initEnumStruct(FALSE,derrick,me,me);
	_tempDerrick = enumStruct();
	while(_tempDerrick != NULLOBJECT)
	{
		_tempDist = distBetweenTwoPoints(_tempDerrick.x, _tempDerrick.y, _x, _y);
		if(_tempDist < _bestDist)	//already going to some derrick
		{
			_closestDerrick = _tempDerrick;
			_bestDist = _tempDist;
		}

		_tempDerrick = enumStruct();
	}

	return _closestDerrick;
}

function FEATURE closestOilResource(int _x, int _y)
{
	local	int				_bestDist,_tempDist;
	local	FEATURE			_closestOil,_tempOil;

	_bestDist = 99999;

	_closestOil = NULLOBJECT;

	// check oil resources
	initGetFeature(oilRes,me,me);
	_tempOil = getFeatureB(me);
	while(_tempOil != NULLOBJECT)
	{
		_tempDist = distBetweenTwoPoints(_tempOil.x, _tempOil.y, _x, _y);
		if(_tempDist < _bestDist)	//already going to some derrick
		{
			_tempOil = _tempOil;
			_bestDist = _tempDist;
		}
		_tempOil = getFeatureB(me);
	}

	return _closestOil;
}

function int findBestDefense()
{
	//return	- defense index
	/* find best defense */
	_temp2 = none;
	_temp = 0;
	while(_temp < numDef)
	{
		if(isStructureAvailable(def[_temp],me))
		{
			_temp2 = _temp;		//Best defense
		}
		_temp = _temp + 1;
	}

	return(_temp2);
}

//---------------------------------------------------------
//	Build oil defenses
//---------------------------------------------------------
event buildNormalOilDefenses(inactive)
{
	if(defending()){exit;}

	if(idleGroupCmd(buildGr,true,false) == 0){exit;}

	/* find best defense */
	best = findBestDefense();

	if(best == none){exit;}

	/* make sure not too many trucks are busy with defenses */
	result = numBuildingNoBaseDefenses();

	if(result >= maxOilDefenseTrucks)
	{
		exit;
	}

	/* set number of defenses allowed */
	count = numOilDef;
	// count = minOilDef;
	// if(playerPower(me) >= highPower)
	// {
		// count = maxOilDef;
	// }


	/* find undefended derrick */
	initEnumStruct(FALSE,derrick,me,me);
	structure = enumStruct();
	while(structure != NULLOBJECT)
	{
		/* check if this derrick has a defense location stored */
		result = getOilDefendLocIndex(me, structure.x, structure.y);

		if((result < 0) or (not bLearn))		//no defense loc stored for this derrick
		{
			/* check if too many defenses around already */
			result = numFriendlyWeapStructsInRange(me, structure.x, structure.y, RANGE_ALL_OIL_DEFENSES, false);
			if(result < count)
			{
				/* make sure derrick is not in the base */
				//result = isInMyBase(structure.x, structure.y);

				if(!isInMyBase(structure.x, structure.y))
				{
					/* is anyone already on the way to build something nearby? */
					//result =buildingSiteBlocked(NULLOBJECT, range, structure.x, structure.y);

					if(!buildingSiteBlocked(NULLOBJECT, RANGE_ALL_OIL_DEFENSES, structure.x, structure.y, true))	//anyone going to do ANYTHIN Gon that spot?
					{
						/* build the normal way */
						dbg("building oil defense the normal way at " & (structure.x / 128) & " - " & (structure.y / 128), me);

						buildOnMap(def[best], structure.x, structure.y, 1);
					}
				}
			}
		}

		structure = enumStruct();
	}
}

/* Build a single defense for a single derrick */
function bool buildDerrickDefence(STRUCTURE _derrick, DROID _truck)
{
	local	int		_bestDefIndex,_numFreandlyDefenses,
					_oilDefLocIndex,_oilRecallPrior,_x,_y,_buildX,_buildY;
	//--------------------------------------------------------
	//Check if derrick has at least min num of defenses nearby
	//--------------------------------------------------------

	/* find _bestDefIndex defense */
	_bestDefIndex = findBestDefense();

	if(_bestDefIndex == none){
		return false;
	}

	/* make sure derrick is not in the base */
	//result = isInMyBase(_derrick.x, _derrick.y);

	if(!DEFEND_BASE_DERRICKS and isInMyBase(_derrick.x, _derrick.y)){	//in base, so exit
		return false;
	}

	/* is anyone already on the way to build something nearby? */
	//result = buildingSiteBlocked(_truck, oilDefensesRange, _derrick.x, _derrick.y);

	if(buildingSiteBlocked(_truck, RANGE_ALL_OIL_DEFENSES, _derrick.x, _derrick.y, true)){	//yes
		return false;	//someone will build something here (probably a defence, so exit)
	}


	/* check if too many defenses around already */
	_numFreandlyDefenses = numFriendlyWeapStructsInRange(me, _derrick.x, _derrick.y, RANGE_ALL_OIL_DEFENSES, false);

	/* make sure not too many trucks are busy with defenses */
	//result = numBuildingNoBaseDefenses();

	//if((result >= maxOilDefenseTrucks) and (_numFreandlyDefenses >= 1))
	if(_numFreandlyDefenses >= numOilDef)
	{
		return false;		//has basic defense, so exit
	}

	if(bLearn)
	{
		// check if this derrick has a defense location stored
		_oilDefLocIndex = getOilDefendLocIndex(me, _derrick.x, _derrick.y);

		if(_oilDefLocIndex >= 0)		//we have a defense loc stored for this derrick
		{
			/* check if priority is high enough */
			if(recallOilDefendLoc(me, _oilDefLocIndex, ref _x, ref _y, ref _oilRecallPrior))	//get priority
			{
				if(_oilRecallPrior >= minOilRecallPrior)	//prior high enough
				{
					circlePerimPoint(_derrick.x, _derrick.y, ref _x, ref _y, DEFENSE_DIST_FROM_OIL);

					if(pickStructLocation(def[_bestDefIndex], ref _x, ref _y, me))
					{
						orderDroidStatsLoc(_truck, DORDER_BUILD, def[_bestDefIndex], _x, _y);
						return true;
					}
				}
			}
		}
	}

	if(_numFreandlyDefenses >= numOilDef){
		return false;	//already has a basic defence, so exit
	}

	/* this derrick doesn't have a defense loc, build the normal way */
	_buildX = _derrick.x;
	_buildY = _derrick.y;

	if(pickStructLocation(def[_bestDefIndex], ref _buildX, ref _buildY, me))
	{
		orderDroidStatsLoc(_truck, DORDER_BUILD, def[_bestDefIndex], _buildX, _buildY);
		return true;
	}

	return false;
}

event defendOil(inactive)
{
	local	int 		_numDefensesToBuild,_maxDefRange,_totalOil;
	local	STRUCTURE	_closestDerrick;
	local	DROID		_nullTruck;

	if(not bLearn){exit;}

	if(defending()){exit;}

	if(idleGroupCmd(buildGr,true,false) == 0){exit;}	//no trucks

	/* make sure not too many trucks are busy with defenses */
	result = numBuildingNoBaseDefenses();

	if(result >= maxOilDefenseTrucks)
	{
		exit;
	}

	result = 0;
	count = 0;
	best = none;
	while(count < numDef)
	{
		result2 = numStatBusy(def[count], TRUE);	//How many trucks are busy with defenses
		result = result + result2;

		count = count + 1;
	}

	/* find best defense */
	best = findBestDefense();

	if(best == none){exit;}		//no defenses available

	if(result > maxOilDefenseTrucks){exit;}		//too many busy

	result = 99999;

	//Go through remembered oil defense locations
	//------------------------------------------------
	count2 = getOilDefendLocCount();

	count = 0;
	count4 = 0;
	while((count < count2) and (count4 < MAX_OIL_DEFENSES_SIDES))	//pick max 3 locs
	{
		if(recallOilDefendLoc(me, count, ref x, ref y, ref result))		//if this one stored
		{
			if(result >= minOilRecallPrior)	//at least priority of 3
			{
				//find oil derrick which is supposed to be defended (closest one)
				//---------------------------------------------------------------
				_closestDerrick = closestDerrick(x, y);

				if(_closestDerrick != NULLOBJECT)	//found anything?
				{
					buildX = _closestDerrick.x;
					buildY = _closestDerrick.y;

					//make sure derrick is not in the base
					//result = isInMyBase(buildX, buildY);

					if(!isInMyBase(buildX, buildY))	//not in base
					{
						//move coords closer to derrick perimeter
						circlePerimPoint(_closestDerrick.x, _closestDerrick.y, ref x, ref y, DEFENSE_DIST_FROM_OIL);	//move locations to the derrick perimeter

						// count how many oil resources we are going to defend
						_totalOil = numTotalOilInRange(_closestDerrick.x, _closestDerrick.y, (TILE * 3));

						//decide how many defenses we want to build depending on total number of oil resource we have to guard
						_numDefensesToBuild = max(numOilDef, numOilDef + (_totalOil - 1) * (numOilDef / 2));

						//count if not too many built on this site already (using corrected coords!)
						if(numStructsByTypeInRange(me, me, REF_DEFENSE, buildX, buildY, oilDefensesRange) < _numDefensesToBuild)	//max
						{
							buildX = x;	//remember coords before using pickStructLocation() to check if corrected coords too far away
							buildY = y;

							//MsgBox("11");
							if(pickStructLocation(def[best], ref buildX, ref buildY, me))
							{
								//Make sure not too many building already
								//--------------------------------------------
								retInt = numTrucksOrderInRange(buildX, buildY, RANGE_ALL_OIL_DEFENSES, DORDER_BUILD);

								if(retInt < MAX_TRUCKS_PER_OIL_DEFENSE)	//max 1
								{
									//don't allow to build outside of the range
									_maxDefRange = max( oilDefensesRange, oilDefensesRange + (TILE * (_totalOil - 1)) );
									if(distBetweenTwoPoints(buildX, buildY, x, y) < _maxDefRange)		//coords corrected with pickStructLocation() not too far away from orig
									{
										//MsgBox("22");
										intOK[count4] = count;
										//MsgBox("33");
										count4 = count4 + 1;		//picked another one
									}
								}
							}
						}
					}
				}
			}
		}
		count = count + 1;
	}

	//MsgBox("2");

	if(count4 == 0){exit;}		//couldn't find anything

	//Now choose a random location from the picked ones
	//-------------------------------------------------
	result = intOK[random(count4 - 1)];

	// now recall defend location and build defenses
	bDummy = buildOilDefenseFromExperience(result, _nullTruck);
}

function bool buildOilDefenseFromExperience(int _index, DROID _truck)
{
	local	int			_prior,_defx,_defy;
	local	STRUCTURE	_closestDerrick;

	recallOilDefendLoc(me, _index, ref _defx, ref _defy, ref _prior);

	//find oil derrick which is supposed to be defended (closest one)
	//---------------------------------------------------------------
	_closestDerrick = closestDerrick(_defx, _defy);

	if(_closestDerrick == NULLOBJECT)	//found anything?
	{
		dbg("defendOil() - couldn't find closest derrick !!!!!!!!!!!!!!!!", me);
		return false;
	}

	// build a defense
	bDummy = buildOilDefense(_defx, _defy, _closestDerrick.x, _closestDerrick.y, _truck);

	return true;
}

function bool buildOilDefense(int _buildX, int _buildY, int _oilx,
								int _oily, DROID _truck)
{
	local	STRUCTURE	_closestDerrick;
	local	int			_x,_y,_closestDist,_bucket,_dist,_dist2;
	local	bool		_bFound,_bResult2;
	local	DROID		_droid2,_droid3;

	//find oil derrick which is supposed to be defended (closest one)
	//---------------------------------------------------------------
	// _closestDerrick = closestDerrick(_oilx, _oily);

	// if(_closestDerrick != NULLOBJECT)	//found anything?
	// {
		// buildX = _closestDerrick.x;
		// buildY = _closestDerrick.y;
	// }
	// else
	// {
		// dbg("buildOilDefense() - couldn't find closest derrick !!!!!!!!!!!!!!!!", me);
		// return false;
	// }

	//move locations to the base perimeter
	circlePerimPoint(_oilx, _oily, ref _buildX, ref _buildY, DEFENSE_DIST_FROM_OIL);


	//if(structure2 == NULLOBJECT){exit;}	//no derrick found

	if(_truck == NULLOBJECT)
	{
		//Now find the closest truck
		//---------------------------------------------
		_closestDist = 99999;
		_bFound = FALSE;	//found any?

		_droid2 = NULLOBJECT;
		_droid3 = NULLOBJECT;

		//MsgBox("4");

		_bucket = initIterateGroupCmd(buildGr,true,false,true);
		_truck = iterateGroupCmd(buildGr,_bucket);
		while(_truck != NULLOBJECT)
		{
			_dist2 = distBetweenTwoPoints(_truck.x, _truck.y, _buildX, _buildY);

			if(_dist2 < _closestDist)	//closer
			{
				if(droidOrderIdle(_truck))
				{
					_droid2 = _truck;		//totally idle
					_closestDist = _dist2;
					_bFound = TRUE;
				}
				//if busy, check if it's worth to make this _truck build an oil defense instead
				else if((_truck.order == DORDER_BUILD) and (_truck.action == DACTION_MOVETOBUILD))
				{
					_bResult2 = TRUE;		//can take this truck
					if(_truck.stat == derrick)
					{
						_bResult2 = FALSE;		//don't touch him, probably going far
					}
					else
					{
						initEnumStruct(FALSE,derrick,me,me);
						structure = enumStruct();
						while((structure != NULLOBJECT) and (_bResult2))
						{
							//skip derricks in the base
							//result3 = isInMyBase(structure.x, structure.y);
							if(!isInMyBase(structure.x, structure.y))		//not in base
							{
								if(distBetweenTwoPoints(_truck.orderx, _truck.ordery, structure.x, structure.y) < oilDefensesRange)	//already going to some derrick
								{
									_bResult2 = FALSE;	//don't touch this truck, going far already
								}
							}

							structure = enumStruct();
						}
					}

					if(_bResult2)	//safe to 'kidnap' this busy truck
					{
						_droid3 = _truck;		//remember this one too
						_closestDist = _dist2;
						_bFound = TRUE;
					}
				}
			}
			_truck = iterateGroupCmd(buildGr,_bucket);
		}

		//MsgBox("5");


		//no trucks
		if(!_bFound)
		{
			dbg("buildOilDefense() - no idle trucks (MUST BE SOME!)", me);
			return false;
		}

		//decide which _truck to take
		//-----------------------------------------
		_truck = _droid2;		//default
		if((_droid2 != NULLOBJECT) and (_droid3 != NULLOBJECT))		//which of 2?
		{
			//only if busy one is much closer, otherwise let him do his job since he's busy
			_dist = distBetweenTwoPoints(_droid2.x, _droid2.y, _buildX, _buildY);
			_dist2 = distBetweenTwoPoints(_droid3.x, _droid3.y, _buildX, _buildY);

			if((_dist - _dist2) > (TILE * 12))		//busy one is much closer
			{
				_truck = _droid3;
			}
		}
		else if(_droid3 != NULLOBJECT)
		{
			_truck = _droid3;
		}
	}

	if(_truck == NULLOBJECT)
	{
		return false;
	}

	// build a defense
	if(pickStructLocation(def[best], ref _buildX, ref _buildY, me))
	{
		orderDroidStatsLoc(_truck, DORDER_BUILD, def[best], _buildX, _buildY);

		return true;
	}
	//buildOnMap(def[best], _x, _y, 1);

	return false;
}


//take over enemy derricks
function STRUCTURE findEnemyDerrick(int _targetPlayer)
{
	local 	int 		_numAttackers,_numEnemies;
	local	STRUCTURE	_enemyDerrick;

	//find enemy derrick
	_enemyDerrick = findBestEnemyDerrick(_targetPlayer, numAvailableAttackers(),
							baseX, baseY, -1);

	//if none found
	if(_enemyDerrick == NULLOBJECT){
		return _enemyDerrick;
	}

	//_enemyDerrick = retStruct;

	dbg("findEnemyDerrick() - found derrick", me);

	//see if we can deal with this many defenses
	_numAttackers = numAvailableAttackers();
	_numEnemies = numEnemyWeapObjInRange(me, _enemyDerrick.x, _enemyDerrick.y, (8 * 128), false, true);

	if(_numAttackers < (_numEnemies + 1))
	{
		_enemyDerrick = NULLOBJECT;		//clear
		dbg("TAKE OIL: not enough attackers for this oil", me);
		return _enemyDerrick;		//too many enemies around
	}

	dbg("findEnemyDerrick()- safe", me);

	//enemy = _enemyDerrick.player;

	//sendForceX = _enemyDerrick.x;
	//sendForceY = _enemyDerrick.y;

	return _enemyDerrick;
}

//find closest enemy derrick with litte defense
function STRUCTURE findBestEnemyDerrick(int _targetPlayer, int _numAttackers,
										int _centerx, int _centery, int _maxRange)
{
	local int _numEnemies,_enemy,_x,_y,_dist,_dist2,_dist3;
	retStruct = NULLOBJECT;

	tempResult2 = 99999;	//best weight

	_enemy = 0;
	while(_enemy < multiPlayerMaxPlayers)
	{
		if( ((_targetPlayer == none) and (_enemy != me) and
			(not allianceExistsBetween(_enemy, me)))  	//target player not set
			or ((_targetPlayer != none) and (_enemy == _targetPlayer)) )						//target player set
		{
			initEnumStruct(false,derrick,_enemy,me);
			tempStruct = enumStruct();
			while(tempStruct != NULLOBJECT)
			{
				// make sure oil derrick is in set range
				if( (_maxRange <= 0) or
					(distBetweenTwoPoints(tempStruct.x, tempStruct.y,
					_centerx, _centery) < _maxRange) )
				{
					_x = tempStruct.x;
					_y = tempStruct.y;

					//don't choose if near an enemy base, since might have units nearby, which we don't see
					//temp4 = isNearEnemyBase(x, y);

					if(not isNearEnemyBase(_x, _y))
					{
						//make sure not too well defended
						_numEnemies = numEnemyWeapObjInRange(me, _x, _y, (8 * 128), true, true);	//check VTOLs too
						if(_numEnemies < _numAttackers)	//this one has less defenses than the amount of units we will use for attack
						{
							_dist = distBetweenTwoPoints(_x, _y, _centerx, _centery) / 128;	// my base-derrick distance

							//enemy-derrick distance
							_dist2 = (_dist / 2) / 128;	//if don't know enemy base location
							if(knowBase[_enemy])
							{
								_dist2 = distBetweenTwoPoints(_x, _y, curBase[_enemy][0], curBase[_enemy][1]) / 128;
							}

							_dist3 = distBetweenTwoPoints(_centerx, _centery, curBase[_enemy][0], curBase[_enemy][1]) / 128;	//my base-enemy base

							//calculate
							//criticalAngle = 45 / dist3 / baseRange;
							//temp4 = degree(_centerx, _centery, x, y, curBase[temp][0], curBase[temp][1]);		//base-derrick-enemyBase angle, the bigger the safer
							//if(temp4 > 180){temp4 = 360 - temp4;}

							//if(not((temp4 < criticalAngle) and ((dist - baseRange) > dist3)))	//make sure not behind the enemy base
							//{
								//tempResult = (temp2 * defWeight) + dist - dist2 - temp4;	//calculate weight of the derrick

								//calculate weight for this derrick (threat)
								tempResult = oilWeight(_enemy, _x, _y, _centerx, _centery);

								if(tempResult < tempResult2)
								{
									tempResult2 = tempResult;
									retStruct = tempStruct;
								}
							//}
						}

					}
				}

				tempStruct = enumStruct();
			}
		}
		_enemy = _enemy + 1;
	}

	return retStruct;
}

function int oilWeight(int _owner, int _oilx, int _oily, int _centerx, int _centery)
{
	local int _range;

	_range = TILE * 12;	//must be same as in posWeight()

	retInt = posWeight(_owner, _oilx, _oily, _range, _centerx, _centery);

	retInt = retInt - 250 * numFeatByTypeInRange(me, 4, _oilx, _oily, _range);	//4 = FEAT_OIL_RESOURCE

	return(retInt);
}


//calc threat
function int posWeight(int _owner, int _x, int _y, int _range,
											int _centerx, int _centery)
{
	_result = 0;	//threat
	_temp2 = 100;	//more integer precision

	//base - pos
	_dist = distBetweenTwoPoints(_centerx, _centery, _x, _y) / 128;

	if(_dist == 0)
		_dist = 1;

	//derricks
	_temp3 = numStructsByTypeInRange(me, me, REF_RESOURCE_EXTRACTOR, _x, _y, _range);

	if(_temp3 == 0)
		_temp3 = 1;

	//my weight //*_temp2 for precision
	_dist = (-1) * (weightDistFactor * _temp2) / (_dist / _temp3);

	_temp3 = (_dist / _temp2);
	//dbg("my weight = " & _temp3, me);

	//enemy - pos
	_dist2 = 0;	//if dead, no threat

	//check object enemy
	if(_owner != none)		//not always need one
	{
		if((not dead[_owner]) and (not killedBase[_owner]))
		{
			_dist2 = _dist;	//neutralize if enemy base loc unknown
			if(knowBase[_owner])
			{
				_dist2 = distBetweenTwoPoints(curBase[_owner][0], curBase[_owner][1], _x, _y) / 128;
				//dbg("_dist2 = " & _dist2, me);
				_dist2 = (weightDistFactor * _temp2) / _dist2;
			}
		}
	}

	_temp3 = (_dist2 / _temp2);
	//dbg("his weight = " & _temp3, me);

	//calc weight
	_result = (_dist2 + _dist);

	_temp3 = (_result / _temp2);
	//dbg("_result = " & _temp3, me);

	//check allies and all enemies
	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if((_temp != me) and (_temp != _owner))
		{
			/* Ally/Enemy */
			_temp3 = (-1);
			if(not allianceExistsBetween(_temp ,me))
			{
				_temp3 = 1;
			}

			if(knowBase[_temp] and seeBase[_temp])	//seeBase[] - otherwise this player might have been destroyed already or not loaded at all
			{
				_dist2 = distBetweenTwoPoints(curBase[_temp][0], curBase[_temp][1], _x, _y) / 128;
				if(_dist2 == 0){_dist2 = 1;}

				_result = _result + (_temp3 * (weightDistFactor / 4 * _temp2)) / _dist2;	//weightDistFactor / 2 => allies and other enemies have less weight	//was /4
			}
		}
		_temp = _temp + 1;
	}

	_result = _result / _temp2;

	//dbg("ally _result = " & _result, me);

	//also check enemy defenses nearby
	_temp3 = numEnemyWeapObjInRange(me, _x, _y, (_range + TILE * 2), true, true);	//also check VTOLs

	//dbg("num defenses = " & _temp3, me);

	_result = _result + _temp3;

	//also take into account possible ally and my objects nearby
	_temp3 = numFriendlyWeapObjInRange(me, _x, _y, (_range + TILE * 2), true, true);	//also check VTOLs
	_result = _result - _temp3;

	return(_result);
}

//---------------------------------------------------------
//	Check if point is in base
//---------------------------------------------------------
function bool isInMyBase(int _checkX, int _checkY)
{
	if(distBetweenTwoPoints(_checkX, _checkY, baseX, baseY) > (baseRange + defendCorridor))	//not in the base
	{
		return(FALSE);
	}

	return(TRUE);
}

//---------------------------------------------------------
//	Check if point is near anyone's base
//---------------------------------------------------------
function bool isNearAnyBase(int _x, int _y)
{
	_range = (25 * 128);

	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(knowBase[_temp] and seeBase[_temp])	//seeBase[] - otherwise this player might have been destroyed already or not loaded at all
		{
			if(distBetweenTwoPoints(curBase[_temp][0], curBase[_temp][1], _x, _y) < _range)
			{
				return(TRUE);
			}
		}
		_temp = _temp + 1;
	}

	return(FALSE);
}

function bool isNearEnemyBase(int _x, int _y)
{
	_range = (25 * 128);

	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(not allianceExistsBetween(_temp ,me))
		{
			if(knowBase[_temp] and seeBase[_temp])	//seeBase[] - otherwise this player might have been destroyed already or not loaded at all
			{
				if(distBetweenTwoPoints(curBase[_temp][0], curBase[_temp][1], _x, _y) < _range)
				{
					return(TRUE);
				}
			}
		}
		_temp = _temp + 1;
	}

	return(FALSE);
}

//---------------------------------------------------------
//	Returns TRUE if a base structures (not defense etc)
//---------------------------------------------------------
function bool isBaseStruct(STRUCTURE _checkStruct)
{
	if(_checkStruct == NULLOBJECT)
	{
		MsgBox("isBaseSTruct - _checkStruct is NULLOBJECT");
		return(FALSE);
	}

	temp = 0;
	while(temp < numBaseStructs)
	{
		if(_checkStruct.stat == baseStructs[temp])
		{
			return(TRUE);
		}
		temp = temp + 1;
	}

	return(FALSE);
}

//---------------------------------------------------------
//	Build derricks
//---------------------------------------------------------
function void buildOil(bool _bInBaseOnly)
{
	local	FEATURE		_oil;
	local	int			_numBuildingOil;

	//dbg(" " & me & ")  Executing buildOil()");

	//How many trucks already working on derricks
	_numBuildingOil = numStatBusy(derrick, true);	//How many trucks are busy with derricks

	_oil = NULLOBJECT;

	//dbg(" " & me & ")  right now building " & _numBuildingOil & " oil resoirces");

	if(_numBuildingOil < maxBuildOilTrucks)	//Not too many
	{
		if(_bInBaseOnly){
			_oil = findBestOilToBuildOn(baseX, baseY, baseRange);	//Look near the base
		}else{
			_oil = findBestOilToBuildOn(baseX, baseY, -1);			//Normal way
		}

		if(_oil != NULLOBJECT)
		{
			//dbg(" " & me & ")  found unoccupied oil resource");

			bDummy = buildUsingClosestTruck(derrick, _oil.x, _oil.y, 1);	//Can skip "buildOnMap" for oil
		}
	}

	//dbg(" " & me & ")  End buildOil()");
}

/* Build oil near some location */
function bool buildNextOil(DROID _truck, int _maxRange, bool _bClosestOil)
{
	local	int			_oilDist,_bestDist,_bucket,_oilRange;
	local	bool		_bCanBuild;
	local	FEATURE		_oil,_bestOil;
	local	DROID		_otherTruck;

	_bestDist = 99999;
	_bestOil = NULLOBJECT;	//Not found right now

	_oilRange = _maxRange;	//max range to look for further oil
	_bCanBuild = false;		//can we build using callback truck?

	if(_bClosestOil)
	{
		initGetFeature(oilRes,me,me);
		_oil = getFeature(me);
		while(_oil != NULLOBJECT)
		{
			_oilDist = distBetweenTwoPoints(_truck.x, _truck.y, _oil.x, _oil.y);
			if(_oilDist < _oilRange)	//oil very near
			{
				if(_oilDist < _bestDist)	//closest one
				{
					if(!buildingSiteBlocked(_truck, _maxRange, _oil.x, _oil.y, true))
					{
						//make sure not dangerous
						if(!threatInRange(me, _oil.x, _oil.y, threatRange, false))
						{
							_bestDist = _oilDist;
							_bestOil = _oil;	//Remember and return it
						}
						else
						{
							dbg("dangerous to build more oil", me);
						}
					}
					else
					{
						dbg("oil blocked", me);
					}
				}
			}
			_oil = getFeature(me);
		}
	}
	else
	{
		// if not looking for the best oil, just find the closest possible
		_bestOil = findBestOilToBuildOn(_truck.x, _truck.y, _maxRange);
	}

 	//now check if any other trucks were sent to build there already
	if(_bestOil != NULLOBJECT)	//found oil
	{
		_bCanBuild = true;

		_bucket = initIterateGroupCmd(buildGr,true,false,true);
		_otherTruck = iterateGroupCmd(buildGr,_bucket);
		while(_otherTruck != NULLOBJECT)
		{
			if((_otherTruck.orderx == _bestOil.x) and (_otherTruck.ordery == _bestOil.y))
			{
				_bCanBuild = false;	//someone already going to build

				//check if it's closer than callback _truck
				if(distBetweenTwoPoints(_otherTruck.x, _otherTruck.y, _bestOil.x, _bestOil.y) > _bestDist)
				{
					//dbg(" " & me & ")  CALLBACK truck - sending other _truck back to base", me);
					orderDroid(_otherTruck, DORDER_RTB);		//send back to base
					_bCanBuild = true;	//(assuming AI only sends 1 truck at each oil !!!)
				}
			}
			_otherTruck = iterateGroupCmd(buildGr,_bucket);
		}
	}

	if(_bCanBuild)		//safe to build with callback _truck
	{
		//dbg(" " & me & ")  CALLBACK truck - building derrick with CALLBACK truck (" & _bestOil.x & "-" & _bestOil.y & ")", me);
		orderDroidStatsLoc(_truck, DORDER_BUILD, derrick, _bestOil.x, _bestOil.y);
		return true;	//exit here
	}

	return false;
}

//-----------------------------------------------------
//Build ArgStrStat0 (passes STRUCTURESTAT) somewhere
//-----------------------------------------------------
function void buildOnMap(STRUCTURESTAT _statToBuild, int _buildX, int _buildY, int _maxTrucks)
{
	bTempResult = pickStructLocation(_statToBuild, ref _buildX, ref _buildY, me);
	if(bTempResult)
	{
		bDummy = buildUsingClosestTruck(_statToBuild, _buildX, _buildY, _maxTrucks);		//can re-use all arguments
	}
}

function FEATURE findBestOilToBuildOn(int _lookx, int _looky, int _maxRange)
{
	local	FEATURE		_oil,_tempOil;
	local	int			_bestWeight,_tempWeight;

	//dbg(" " & me & ")  Executing findBestOilToBuildOn()");

	_oil = NULLOBJECT;	//Not found right now
	_bestWeight = 99999;

	initGetFeature(oilRes,me,me);
	_tempOil = getFeature(me);
	while(_tempOil != NULLOBJECT)
	{
		//_tempWeight = distBetweenTwoPoints(temp3, temp4, _tempOil.x, _tempOil.y);
		//if(_tempWeight < _bestWeight)
		//{
			//make sure not dangerous
			if(not threatInRange(me, _tempOil.x, _tempOil.y, threatRange, false))
			{
				//Any trucks already were sent to build there?
				//temp5 = buildingSiteBlocked(NULLOBJECT, (5 * 128), _tempOil.x, _tempOil.y);	//anyone going there already?

				if(not buildingSiteBlocked(NULLOBJECT, (TILE * 5), _tempOil.x, _tempOil.y, true))	//No one going there
				{
					//make sure close enough to provided position
					if(not ((_maxRange > 0) and
						(distBetweenTwoPoints(_lookx, _looky, _tempOil.x, _tempOil.y) < _maxRange)))
					{
						_tempWeight = oilWeight(none, _tempOil.x, _tempOil.y,
											_lookx, _looky);

						if(_tempWeight < _bestWeight)
						{
							_bestWeight = _tempWeight;
							_oil = _tempOil;	//Remember it
						}
					}
				}
			}
		//}
		_tempOil = getFeature(me);
	}

	return _oil;

	//dbg(" " & me & ")  End findBestOilToBuildOn()");
}

function bool needTrucks()
{
	local	int	_totalTrucks,_numHaveTrucks;

	// we always need at least minTrucks
	if( !gettingMinTrucks() ){
		return true;
	}

	_numHaveTrucks = groupSizeCmds(buildGr,true,false,true);

	_totalTrucks = numBuildersInProduction(me) + _numHaveTrucks;

	if((idleGroupCmd(buildGr,true,false) == 0) and (_totalTrucks < MAX_BUILDERS)){
		return true;
	}

	return false;
/*

	if(_totalTrucks >= maxTrucks)
	{
		return false;
	}

	if(_totalTrucks < minTrucks)
	{
		return true;
	}

	// need trucks if we have more than minTrucks and almost all of them are busy
	if((_totalTrucks >= minTrucks) and (idleGroupCmd(buildGr,true,false) < 2))
	{
		return true;
	}

	return false; */
}

function void buildTrucks()
{
	local	int 		_numBuilding,_haveTrucks,_tmplIndex,_totalTrucks,
						_maxBuiltMinTrucks;
	local	STRUCTURE	_factory;
	local	bool		_bFoundTemplate,_bStartedBuilding;

	_haveTrucks = groupSizeCmds(buildGr,true,false,true);

	_numBuilding = numBuildersInProduction(me);	//How many builders are being built at the moment

	_totalTrucks = _haveTrucks + _numBuilding;

	if(_totalTrucks >= MAX_BUILDERS){
		dbg("HAVE TOO MANY TRUCKS", me);
		exit;
	}

	_maxBuiltMinTrucks = 2;
	if(defending()){
		_maxBuiltMinTrucks = 1;
	}

	initEnumStruct(FALSE,fac,me,me);
	_factory = enumStruct();
	while( (_factory != NULLOBJECT) and
		((_numBuilding == 0) or 		// max 1 at a time, if have more than minTrucks, use only 1 fac for trucks
		(!gettingMinTrucks() and (_numBuilding < _maxBuiltMinTrucks)) ) )	//But keep building until we have min number (max _maxBuiltMinTrucks at a time)
	{
		if(structureComplete(_factory))
		{
			if(structureIdle(_factory))
			{
				// find best availabe truck template for this factory
				_tmplIndex = numTruckTmpl - 1;
				_bFoundTemplate = false;
				while(!_bFoundTemplate and (_tmplIndex >= 0))
				{
					if(skCanBuildTemplate(me,_factory, truck[_tmplIndex]))
					{
						tmplOK[0] = truck[_tmplIndex];
						_bFoundTemplate = true;
					}
					_tmplIndex--;
				}

				// build a truck
				if(_bFoundTemplate)
				{
					buildDroid(tmplOK[0], _factory, me, 1);
					_numBuilding++;
					_totalTrucks++;
				}
			}
		}
		_factory = enumStruct();
	}

	// Build cyborg engineers if we are still low on trucks
	initEnumStruct(false,cybfac,me,me);
	_factory = enumStruct();
	while((_factory != NULLOBJECT) and
		 ( !gettingMinTrucks() or			// very low on trucks
		 (needTrucks() and legoPhase() )) )	// at the beginning we need asap trucks to get oil
	{
		if(structureComplete(_factory))
		{
			if(structureIdle(_factory))
			{
				//Try to build an engineer
				if( skCanBuildTemplate(me,_factory, cybEngineer) )	//make sure we have researched cyb engineer
				{
					buildDroid(cybEngineer, _factory, me, 1);
					_numBuilding++;
					_totalTrucks++;
				}
			}
		}
		_factory = enumStruct();
	}
}

function void checkPowerGen()
{
	local	bool	_bStartedBuilding;
	//dbg(" " & me & ")  Executing checkPowerGen()");

	_bStartedBuilding = FALSE;

	if(not structureLimitReached(powGen, me))
	{
		result = getNumStructures(derrick, me);
		result = result + numStatBusy(derrick, FALSE);	//"Think ahead"

		result2 = getNumStructures(powGen,me);

		if((result2 * 4) < result)	//not enough pow gens
		{
			count = (((result+3)/4) - result2);		//How many power gens are missing

			//dbg(" " & me & ")  num gens to build: " & count);

			while(count > 0)
			{
				_bStartedBuilding = buildInBase(powGen, 1);	//Build power gen in the base  (can re-use argument ArgStrStat0)

				if(_bStartedBuilding){
					count--;
				}else{
					count = -1;		//break loop
				}
			}
		}
	}

	//dbg(" " & me & ")  End checkPowerGen()");
}

function void upgradePow()
{
	local	int			_numUpgrading;
	local	STRUCTURE	_structure;

	if(idleGroupCmd(buildGr,true,false) == 0){exit;}

	//powergen
	initEnumStruct(FALSE,powGen,me,me);
	_structure = enumStruct();
	while(_structure != NULLOBJECT)
	{
		if(isStructureAvailable(powMod,me) and (not testStructureModule(me, _structure, 0)))
		{
			//result = buildingSiteBlocked(NULLOBJECT, 128, _structure.x, _structure.y);

			if(numBuildSameBuilding(powMod, _structure.x, _structure.y) <= MAX_POWGEN_UPGRADE_TRUCKS)	//Make sure not too many upgrading
			{
				_numUpgrading = numStatBusy(powMod, true);	//How many trucks are busy with facMod

				if(_numUpgrading == 0)		//Make sure not too many trucks are doing the same thing at a time
				{
					buildOnMap(powMod, _structure.x, _structure.y, MAX_POWGEN_UPGRADE_TRUCKS);
				}
			}
		}
		_structure = enumStruct();
	}
}

function void upgradeFac()
{
	local	int			_numUpgrading;
	local	STRUCTURE	_structure;
	local	bool		_bLetFinishProduction;

	if(idleGroupCmd(buildGr,true,false) == 0){exit;}

	initEnumStruct(FALSE,fac,me,me);
	_structure = enumStruct();
	while(_structure != NULLOBJECT)
	{
		if(isStructureAvailable(facMod,me) and (skGetFactoryCapacity(_structure) < 2 ))
		{
			//result = buildingSiteBlocked(NULLOBJECT, 128, _structure.x, _structure.y);

			// if this is a startup phase and we are low on scouts and fac is building a tank, let it finish
			_bLetFinishProduction = false;
			if(!structureIdle(_structure) and needStartupScouts())
			{
				// see if this tank can be used as a scout (and probably will be)
				_bLetFinishProduction = isTankTemplate(factoryGetTemplate(_structure));
			}

			if(!_bLetFinishProduction)
			{
				if(numBuildSameBuilding(facMod, _structure.x, _structure.y) <= MAX_FACTORY_UPGRADE_TRUCKS)	//Make sure not too many upgrading
				{
					_numUpgrading = numStatBusy(facMod, TRUE);	//How many trucks are busy with facMod

					if(_numUpgrading <= (MAX_FACTORY_UPGRADE_TRUCKS + 1))		//Make sure not too many trucks are doing the same thing at a time
					{
						buildOnMap(facMod, _structure.x, _structure.y, MAX_FACTORY_UPGRADE_TRUCKS);
					}
				}
			}
		}
		_structure = enumStruct();
	}
}

function void upgradeVtolFac()
{
	local	int			_numUpgrading;
	local	STRUCTURE	_structure;

	if(idleGroupCmd(buildGr,true,false) == 0){exit;}

	//vtol Factory
	initEnumStruct(FALSE,vtolfac,me,me);
	_structure = enumStruct();
	while(_structure != NULLOBJECT)
	{
		if(isStructureAvailable(facMod,me) and (skGetFactoryCapacity(_structure) < 2))
		{
			//result = buildingSiteBlocked(NULLOBJECT, 128, _structure.x, _structure.y);

			if(not buildingSiteBlocked(NULLOBJECT, 128, _structure.x, _structure.y, false))
			{
				_numUpgrading = numStatBusy(facMod, TRUE);	//How many trucks are busy with resMod

				if(_numUpgrading <= 1)		//Max 2 at a time
				{
					buildOnMap(facMod, _structure.x, _structure.y, 1);
				}
			}
		}
		_structure = enumStruct();
	}
}

function void upgradeResFac()
{
	local	int			_numUpgrading;
	local	STRUCTURE	_structure;

	//dbg(" " & me & ")  Executing doUpgrades()");

	if(idleGroupCmd(buildGr,true,false) == 0){exit;}

	//research
	initEnumStruct(FALSE,resFac,me,me);
	_structure = enumStruct();
	while(_structure != NULLOBJECT)
	{
		if(isStructureAvailable(resMod,me) and (not testStructureModule(me, _structure, 0)))
		{
			//result = buildingSiteBlocked(NULLOBJECT, 128, _structure.x, _structure.y);

			if(not buildingSiteBlocked(NULLOBJECT, 128, _structure.x, _structure.y, false))
			{
				_numUpgrading = numStatBusy(resMod, TRUE);	//How many trucks are busy with resMod

				if(_numUpgrading <= 1)		//Max 2 at a time
				{
					buildOnMap(resMod, _structure.x, _structure.y, 1);
				}
			}
		}
		_structure = enumStruct();
	}

	//dbg(" " & me & ")  End doUpgrades()");
}

function void deselectAllDroids()
{
	//Iterate through all player droids
	InitEnumDroids(me,me);
	tempDroid = EnumDroid();
	while(tempDroid != NULLOBJECT)
	{
		selectDroid(tempDroid, FALSE);
		tempDroid = EnumDroid();
	}
}

/* Calculate how many research facilities need to start researching */
function int calcNeededRes()
{
	local	int 		_missingDefendersCost,
						_availableAttackersCost,_minAttackersCost,
						_stateCost,_tStateUrgencyTimeout,_researchActivityCost;
	local	int 		_needRes,_availableAttackers,_minAttackers;
	local	float		_fNeedRes,_fNeedResInPower,_topicCost,_tankCost,_fMinResCost,_fPlayerPow,
						_fMissingDefCost;

	/* decide how many research facilities we want to use */
	_needRes = maxResearch;

	/*
	 * NOTE: toPow(x / a, power) - means: parabola depends on x. Parabola's f(x) will have 1 at 'a',
	 * ie 'a' is like a threshold, which makes toPow() kick-in (output f(x) > 0) only after 'a', having no effect for x < a.
	*/

	_topicCost = 400.0;			//Approximate cost of a single research topic
	_tankCost = _topicCost;
	_missingDefendersCost = max(0, minDefenders - groupSizeCmds(defendGr,true,false,true)) * (int)_tankCost;	//can't be negative, don't care if have more than needed

	_availableAttackers = numAvailableAttackers();
	_minAttackers = minAttackers;
	_availableAttackersCost = _availableAttackers * (int)_tankCost;
	_minAttackersCost = _minAttackers * (int)_tankCost;

	// don't allow to idle too long
	_researchActivityCost = (int)(toPow((fmin(fCurResUrgency, 7000.0) / fMaxResHold), 3.0)
		* _topicCost);	//+1 res at fMaxResHold

	_stateCost = 0;
	_tStateUrgencyTimeout = (int)fMaxResHold;	//MINUTE * 10;
											/* 10 mins - when to add at least 1 res, in secs, can't put research on hold forever while defending or helping ally
											shouldn't lose urgency way too fast, should still put enough power into what we are doing now - flat function*/
	if(defending() or (state == stHelpingAlly)) {
		//ASSERT(tState != 0, "doResearch: tState == 0", me);
		_stateCost = max(0, (int)_topicCost * max((_tStateUrgencyTimeout / max(tState, 1) - 1), 0));		//f(x) is +inf at the beginnign of the state, 0 at _tStateUrgencyTimeout, '-' after _tStateUrgencyTimeout
	}

	/* Temporary calculations in power currency */
	/* numRes = (fMinResearch * _topicCost) 							//Try to keep minimum number of res facs working
			+ playerPower(me)  							//use each 400 power for 1 additional research topic
			- _missingDefendersCost		//Save some power if we don't have enough defenders
			+ toPow(_availableAttackersCost / _minAttackersCost, 2)		//Research more if we have alot of attackers already, +1 res at _minAttackersCost
			+ _researchActivityCost			//Take into account how actively we have been researching in the last tResUrgencyTrackInterval seconds
			- _stateCost
			- enemyAttackers; */				//Do less research if enemy is about to invade with a huge force

	_fMinResCost = _topicCost * fMinResearch;
	_fPlayerPow = (float)playerPower(me);
	_fMissingDefCost = (float)_missingDefendersCost;

	_fNeedResInPower = (_fMinResCost + _fPlayerPow -
		_fMissingDefCost +
		(float)((int)toPow((float)_availableAttackers / (float)max(_minAttackers, 1), 2.0) * (int)_tankCost) +
		(float)(_researchActivityCost - _stateCost));	// - enemyAttackers;

	/* Convert from power currency into number of research facilities needed to put to work */
	_needRes = (int)(_fNeedResInPower / _topicCost);
	_fNeedRes = (_fNeedResInPower / _topicCost);

	// round to the nearest integer
	if((_fNeedRes - (float)(int)_fNeedRes) > 0.5){
		_needRes++;
	}

	// don't do more than fMinResearch reserahces if defending the base
	if(defending() and (playerPower(me) < highPower)){
		_needRes = min(0, _needRes);
	}
	else
	{
		_needRes = min((int)fMinResearch, _needRes);
	}

	/* Update debug menu */
	if(watchWindowDebug == WATCH_DEBUG_RESEARCH)
	{
	 	setDebugMenuEntry("need res: " & _needRes & " (" & _fNeedResInPower & ") " & fNumDefaultResearch, 0);
		setDebugMenuEntry("resUrgency : " & fCurResUrgency & " (" & _researchActivityCost & ")" , 1);
		setDebugMenuEntry("-defenders: " & _missingDefendersCost, 2);
		setDebugMenuEntry("attackers: " & _availableAttackers & " (" & toPow((float)_availableAttackers / (float)max(_minAttackers,1), 2.0) & ")", 3);

		setDebugMenuEntry("maxOilScouts: " & maxOilScouts, 5);
		setDebugMenuEntry("addScout: " & addScout, 6);
		setDebugMenuEntry("numEnemyScouts: " & numEnemyScouts, 7);
		setDebugMenuEntry("fMapRevealFactor: " & fMapRevealFactor, 9);
	}

/* 	numRes = fMinResearch 							//Try to keep minimum number of res facs working
			+ (power / _topicCost) 			//use each 400 power for 1 additional research topic
			- ( _numMissingDefenders / (_topicCost / _tankCost) )		//Save some power if we don't have enough defenders
			+ toPow(numAvailableAttackers / minAttackers, 2)		//Research more if we have alot of attackers already, +1 res at minAttackers
			+ toPow(fCurResUrgency / fMaxResHold, 5);					//+1 res at fMaxResHold	 */

	return _needRes;
}

/* Put all research facilities to work, done at startup */
event startAllResearch(inactive)
{
	// start research facilities
	doResearchAll();
}

event doResearchEv(inactive)
{
	doResearchAll();
}

function void doResearchAll()
{
	local	STRUCTURE	_resFac;
	local	int			_needRes,_resIndex,_numResearching;


	/* find out how many research facilities are busy */
	_numResearching = numBusyByType(resFac);

	if(_numResearching > 0){
		tLastResearch = 0;	//reset, since we are not idle
	}

	/* Calculate how many research facilities should be researching */
	_needRes = calcNeededRes();

	/* see if we already have enough research facilities busy */
	if(_numResearching >= _needRes){
		exit;
	}

	_resIndex = none;		//research index


	/* Put research facilities to work */
	initEnumStruct(FALSE,resFac,me,me);
	_resFac = enumStruct();

	while((_resFac != NULLOBJECT) and (_numResearching < _needRes))		//not too many working
	{

		_resIndex = doResearch(_resFac, _resIndex);

		if(_resIndex >= 0)
		{

			_numResearching++;	//one more working
			tLastResearch = 0;	//reset, since we are not idle now
		}

		_resFac = enumStruct();

	}

}

event startNewResearch(inactive)
{
	local	STRUCTURE	_resFac;
	local	int			_needRes,_resIndex,_numResearching;

	// structure can be null sometimes
	if(structure == NULLOBJECT){
		exit;
	}

	ASSERT(structureIdle(structure), "startNewResearch: Res fac is not idle", me);

	/* find out how many research facilities are busy */
	_numResearching = numBusyByType(resFac);

	if(_numResearching > 0){
		tLastResearch = 0;	//reset, since we are not idle
	}

	/* Calculate how many research facilities should be researching */
	_needRes = calcNeededRes();

	/* see if we already have enough research facilities busy */
	if(_numResearching >= _needRes){
		exit;
	}

	_resIndex = none;		//research index

	// start researching next research topic with this idle res fac
	_resIndex = doResearch(structure,_resIndex);
}

function int doResearch(STRUCTURE _resFac, int _resIndex)
{
	local	bool	_bStarted;
	local	int		_tech;

	/* current tech tree */
	_tech = 0;	//default tank tech //TODO: fix
	if(tech != none){
		_tech = tech;	//use whatever we selected as our new preference
	}

	if(structureIdle(_resFac))
	{

		if(structureComplete(_resFac))
		{
			_bStarted = FALSE;	//this res lab idle for now

			/* check if need unit transporter ASAP */
/*
			if((state == stDrop) and (not researchFinished(resUnitTransporter, me)))
			{
				_bStarted = pursueResearch(_resFac,me,resUnitTransporter);

				if(_bStarted)
				{
					dbg("getting transporter tech", me);
				}
			}
*/

			/* do normal research */
			while(not _bStarted)
			{

				_resIndex = findResearch(_resIndex + 1, _tech);

				if(_resIndex > none)	//found research
				{

					_bStarted = pursueResearch(_resFac,me,research[_tech][_resIndex]);

					// if(_bStarted)
					// {
						// _numResearching++;	//one more working
						// tLastResearch = 0;	//reset, since we are not idle now
					// }
				}
				else
				{
					_bStarted = TRUE;	//make loop end, no research found
				}
			}
		}
	}

	if(!_bStarted)
	{
		return none;
	}

	return _resIndex;
}

function int findResearch(int _searchStart, int _techTree)
{
	ASSERT(_searchStart >= 0, "findResearch: _searchStart < 0", me);
	ASSERT(_techTree >= 0, "findResearch: _techTree < 0", me);

	retInt = _searchStart;
	while(retInt < numRes[_techTree])
	{
		if((not researchFinished(research[_techTree][retInt], me)) and (not researchStarted(research[_techTree][retInt], me)))
		{
			return(retInt);		//found research
		}
		retInt = retInt + 1;
	}

	retInt = none;		//not found
	return(retInt);
}

//--------------------------------------------------------
//Number of busy structures by type
//--------------------------------------------------------
function int numBusyByType(STRUCTURESTAT _busyStructType)
{
	local	int 		_result;
	local	STRUCTURE	_structure;

	initEnumStruct(FALSE,_busyStructType,me,me);
	_structure = enumStruct();
	_result = 0;
	while(_structure != NULLOBJECT)
	{
		if(not structureIdle(_structure))
		{
			_result++;
		}
		_structure = enumStruct();
	}

	return(_result);
}

//--------------------------------------------------------
//For how many structures of given type there's a pending
//build (truck is on the way to build or already building)
//--------------------------------------------------------
function int numStatBusy(STRUCTURESTAT _structureToCheck, bool _bExcludeAlreadyBuilding)
{
	local	int		_numStatBusy,_bucket;
	local	DROID	_bTruck;

	_numStatBusy = 0;

	_bucket = initIterateGroupCmd(buildGr,true,false,true);
	_bTruck = iterateGroupCmd(buildGr,_bucket);
	while(_bTruck != NULLOBJECT)
	{
		if(_bTruck.order == DORDER_BUILD)
		{
			if(not (_bExcludeAlreadyBuilding and _bTruck.action == DACTION_BUILD))
			{
				if(_bTruck.stat == _structureToCheck)	//going to build it
				{
					_numStatBusy++;
				}
			}
		}
		_bTruck = iterateGroupCmd(buildGr,_bucket);
	}

	return _numStatBusy;
}

//--------------------------------------------------------
//Total number of trucks are have started building
//something (not just going to the building site)
//--------------------------------------------------------
function int numTrucksBuilding()
{
	local	int 	_bucket;

	retInt = 0;
	_bucket = initIterateGroupCmd(buildGr,true,false,true);
	tempDroid = iterateGroupCmd(buildGr,_bucket);
	while(tempDroid != NULLOBJECT)
	{
		if((tempDroid.order == DORDER_BUILD) and (tempDroid.action != DACTION_MOVETOBUILD))	//Started building
		{
			retInt = retInt + 1;
		}
		tempDroid = iterateGroupCmd(buildGr,_bucket);
	}

	return(retInt);
}

//---------------------------------------------------------
//Returns number of trucks that are on the way to
//build a certain structure type (not building yet)
//---------------------------------------------------------
function int numStatMoveBusy(STRUCTURESTAT _structStatToCheck)
{
	local	int 	_bucket,_numBusy;
	local	DROID	_truck;

	_numBusy = 0;
	_bucket = initIterateGroupCmd(buildGr,true,false,true);
	_truck = iterateGroupCmd(buildGr,_bucket);
	while(_truck != NULLOBJECT)
	{
		if((_truck.order == DORDER_BUILD) and (_truck.action == DACTION_MOVETOBUILD)) //Not reached the building site yet
		{
			if(_truck.stat == _structStatToCheck)	//going to build it
			{
				_numBusy = _numBusy + 1;
			}
		}
		_truck = iterateGroupCmd(buildGr,_bucket);
	}

	return(_numBusy);
}

//-----------------------------------------------------
function bool buildInBase(STRUCTURESTAT _statToBuild, int _maxTrucks)
{
	local	bool		_bStartedBuilding;

	_bStartedBuilding = FALSE;

	//dbg(" " & me & ")  Executing buildInBase()");

	temp = 6 * 128;
	temp2 = baseX + (random(temp) - (temp/2));	//Randomize a bit
	temp3 = baseY + (random(temp) - (temp/2));

	if(pickStructLocation(_statToBuild, ref temp2, ref temp3, me))
	{
		_bStartedBuilding = buildUsingClosestTruck(_statToBuild, temp2, temp3, _maxTrucks);		//can re-use ArgStrStat0
	}

	//dbg(" " & me & ")  End buildInBase()");

	return _bStartedBuilding;
}

//-----------------------------------------------------
//Build a structure with the closest truck
//-----------------------------------------------------
function bool buildUsingClosestTruck(STRUCTURESTAT _statToBuild, int _buildX, int _buildY, int _maxTrucks)		//Building coords and STRUCTURESTAT are passed
{
	local	int		_numTrucks;
	local	bool	_bHaveMoreTrucks;
	local	DROID	_truck;

	//dbg(" " & me & ")  Executing buildUsingClosestTruck()");

	_numTrucks = 0;
	_bHaveMoreTrucks = TRUE;
	while((_numTrucks < _maxTrucks) and _bHaveMoreTrucks)
	{
		_bHaveMoreTrucks = FALSE;

		_truck = closestIdleTruck(_buildX, _buildY);
		if(_truck != NULLOBJECT)
		{
			_bHaveMoreTrucks = TRUE;
			orderDroidStatsLoc(_truck, DORDER_BUILD, _statToBuild, _buildX, _buildY);

			//dbg(" " & me & ")  End buildUsingClosestTruck()");
			_numTrucks++;
		}
	}

	//dbg(" " & me & ")  End buildUsingClosestTruck()");

	return (_numTrucks > 0);
}

//-----------------------------------------------------
//Build factories and research facilities dynamically
//-----------------------------------------------------
function void buildBaseStructs()
{
	local	int _maxResFac,_numResFac,_maxFacs,_numFacs,_buildX,_buildY,
				_range,_result3;
	local	bool _bStartedBuild,_bNeedFac,_bNeedResFac,_bResult;

	if(idleGroupCmd(buildGr,true,false) == 0)
		exit;

	_range = 6 * 128;

	_buildX = baseX + random(_range) - (_range / 2);
	_buildY = baseY + random(_range) - (_range / 2);

	_maxFacs = getStructureLimit(fac, me);
	_maxResFac = getStructureLimit(resFac, me);

	// num already built plus num pending
	_numFacs = getNumStructures(fac,me) + numStatMoveBusy(fac);
	_numResFac = getNumStructures(resFac,me) + numStatMoveBusy(resFac);

	/* limit num of facs when critical power or low on defenders */
	if(alert)
	{
		_maxFacs = min(minFacs, _maxFacs);		//limit facs,
		_maxResFac = min(minResFacs, _maxResFac);		//limit res fac
	}

	/*check if limit reached */
	_bNeedFac = ((not structureLimitReached(fac, me)) and (_numFacs < _maxFacs));	//bool = available 	//limit not reahced and not more than allowed at the moment
	_bNeedResFac = ((not structureLimitReached(resFac, me)) and (_numResFac < _maxResFac));

	dbg("max facs/res facs: " & _maxFacs & "/" & _maxResFac & ", need: " &
		_bNeedFac & "/" & _bNeedResFac, me);

	_bStartedBuild = FALSE;

	/* Build HQ */
	if(getStructure(HQ, me) == NULLOBJECT)	//not built and no one's on the way to build
	{
		//Check if someone's already on the way to build HQ
		_result3 = numStatBusy(HQ, TRUE);

		if(_result3 == 0)		//no one's on the way to build
		{
			bDummy = buildInBase(HQ, 1);
		}
	}

	/* see if we need VTOL factories */
	if( ((state == stDrop) or (playerPower(me) > highPower)) and
		(groupSizeCmds(defendGr,true,false,true) >= numDefenders))	//don't waste time, since transporter tech becomes available only after vtol fac is built
	{
		if((_numFacs > 0) and (_numResFac > 0) and isStructureAvailable(vtolfac, me))
		{
			//if(numResearchLeft(me, resUnitTransporter) <= 6)	//don't bother if still to far away from being able to build transporter
			//{
				if(getNumStructures(vtolfac, me) < min(0, getStructureLimit(vtolfac, me)))	//don't try to build more than allowed
				{
					//Check if someone's already on the way to build VTOL fac
					_result3 = numStatBusy(vtolfac, TRUE);

					if(_result3 == 0)		//no one's on the way to build
					{
						bDummy = buildInBase(vtolfac, 2);
						dbg("Building VTOL Factory", me);
						exit;
					}
				}
			//}
		}
	}

	//if((not _bNeedFac) and (not _bNeedResFac)){exit;}



	/* build factories and research facilities */
	if(_bNeedFac and							// need facs
		(!_bNeedResFac or (_numFacs <= _numResFac) or (_numResFac >= 3) or
		(_bNeedResFac and (_numResFac * 2 > _numFacs)) or
		((_numFacs < minFacs) and (_numResFac >= 1)) ) ) //The only avail left or not enough or (less than min and have at least 1 res)
	{
		//How many trucks are on the way to build factories
		_result3 = numStatMoveBusy(fac);	//How many builds are in pending (not in progress already!)

		//dbg(" " & me & ")  buildBaseStructs() - factory - have: " & _numFacs & " pending: " & _result3);

		if((_numFacs + _result3) < _maxFacs)	//Will not max out
		{
			_bResult = pickStructLocation(fac, ref _buildX, ref _buildY, me);
			if(_bResult == TRUE)
			{
				//Anyone already wants to build something else on this spot?
				//_result3 = buildingSiteBlocked(NULLOBJECT, 128, _buildX, _buildY);

				if(not buildingSiteBlocked(NULLOBJECT, 128, _buildX, _buildY, false))
				{
					_bResult = buildUsingClosestTruck(fac, _buildX, _buildY, 2);		//Building coords and STRUCTURESTAT are passed

					if(_bResult)
					{
						_bStartedBuild = TRUE;	//Build successfull
					}
				}
				else
				{
					dbg("buildBaseStructs() - factory someone's building (!!!!!!!!!!)", me);
				}
			}
		}
	}

	if(alert){
		exit;
	}

	/* build res fac */
	if(!_bStartedBuild and _bNeedResFac)	//Factory unavailable (didn't start build it) and Rec fac available
	{
		//dbg(" " & me & ")  buildBaseStructs() - must build res fac (*)");

		//How many trucks are on the way to build res fac
		_result3 = numStatMoveBusy(resFac);	//How many builds are in progress or pending

		if((_result3 + _numResFac) < min(_maxResFac, maxResearch))	//Will not max out, or don't build more than required (maxResearch)
		{
			dbg("Building res fac", me);

			_bResult = pickStructLocation(resFac, ref _buildX, ref _buildY, me);
			if(_bResult == TRUE)
			{
				//Anyone already wants to build something else on this spot?
				//_result3 = buildingSiteBlocked(NULLOBJECT, 128, _buildX, _buildY);

				if(not buildingSiteBlocked(NULLOBJECT, 128, _buildX, _buildY, false))
				{
					bDummy = buildUsingClosestTruck(resFac, _buildX, _buildY, 1);		//Building coords and STRUCTURESTAT are passed
				}
			}
		}
	}

	/* build uplink center */
	if(getNumStructures(uplink,me) >= 1){exit;}
	if(not isStructureAvailable(uplink, me)){exit;}

	if((_numFacs < 1) or (_numResFac < 1)){exit;}	//no facs, no research

	//How many trucks are on the way to build uplink
	_result3 = numStatMoveBusy(uplink);	//How many builds are in progress or pending

	if(_result3 > 0){exit;}

	_buildX = baseX + random(_range) - (_range / 2);
	_buildY = baseY + random(_range) - (_range / 2);

	_bResult = pickStructLocation(uplink, ref _buildX, ref _buildY, me);
	if(_bResult == TRUE)
	{
		//Anyone already wants to build something else on this spot?
		//_result3 = buildingSiteBlocked(NULLOBJECT, 128, _buildX, _buildY);

		if(not buildingSiteBlocked(NULLOBJECT, 128, _buildX, _buildY, false))
		{
			bDummy = buildUsingClosestTruck(uplink, _buildX, _buildY, 1);		//Building coords and STRUCTURESTAT are passed
		}
	}


	//dbg(" " & me & ")  End buildBaseStructs()");
}

//---------------------------------------------------------
//	Find droids without a group
//---------------------------------------------------------
function void unassignedDroids(GROUP defendersGr, GROUP buildersGr)
{
	_temp = 0;

	//Iterate through all player droids
	InitEnumDroids(me,me);
	tempDroid = EnumDroid();
	while(tempDroid != NULLOBJECT)
	{
		if(not hasGroup(tempDroid))
		{
			if(tempDroid.droidType == DROID_CONSTRUCT)
			{
				groupAddDroid(buildersGr, tempDroid);
				_temp = _temp + 1;
			}
			else
			{
				if((tempDroid.droidType != DROID_TRANSPORTER) and
				(tempDroid.droidType != DROID_COMMAND))
				{
					groupAddDroid(defendersGr, tempDroid);
					_temp = _temp + 1;
				}
			}
		}
		tempDroid = EnumDroid();
	}

	dbg("found " & _temp & " unassigned droids", me);
}

//---------------------------------------------------------------
//Returns how many droids are already on the way to build the
//same structure on the same spot (like helpbuild)
//---------------------------------------------------------------
function int numBuildSameBuilding(STRUCTURESTAT _checkStat, int _x, int _y)
{
	local	int 	_bucket;

	retInt = 0;

	_bucket = initIterateGroupCmd(buildGr,true,false,true);
	tempDroid = iterateGroupCmd(buildGr,_bucket);
	while(tempDroid != NULLOBJECT)
	{
		if(tempDroid.order == DORDER_BUILD)
		{
			if(tempDroid.stat == _checkStat)	//Same struct type
			{
				//Within some range
				if(distBetweenTwoPoints(_x, _y, tempDroid.orderx , tempDroid.ordery) <= 128)
				{
					retInt = retInt + 1;
				}
			}
		}
		tempDroid = iterateGroupCmd(buildGr,_bucket);
	}

	return(retInt);
}

function int numTrucksSameOrder(int _orderIndex)
{
	local	int 	_bucket;

	retInt = 0;

	_bucket = initIterateGroupCmd(buildGr,true,false,true);
	tempDroid = iterateGroupCmd(buildGr,_bucket);
	while(tempDroid != NULLOBJECT)
	{
		if(tempDroid.order == _orderIndex)	//right order type
		{
			retInt = retInt + 1;
		}
		tempDroid = iterateGroupCmd(buildGr,_bucket);
	}

	return(retInt);
}


//---------------------------------------------------------------
//Returns how many trucks have order in a range
//---------------------------------------------------------------
function int numTrucksOrderInRange(int _rangex, int _rangey, int _range, int _order)
{
	local	int 	_bucket;
	local	DROID	_truck;

	retInt = 0;

	_bucket = initIterateGroupCmd(buildGr,true,false,true);
	_truck = iterateGroupCmd(buildGr,_bucket);
	while(_truck != NULLOBJECT)
	{
		if((_order < 0) or (_truck.order == _order))	//Any order or right order type
		{
			//Within some range
			if(distBetweenTwoPoints(_rangex, _rangey, _truck.orderx , _truck.ordery) <= _range)
			{
				retInt = retInt + 1;
			}
		}
		_truck = iterateGroupCmd(buildGr,_bucket);
	}

	return(retInt);
}

//---------------------------------------------------------------
//Returns how many trucks have the same order location
//---------------------------------------------------------------
function int numTrucksSameOrderLoc(int _x, int _y, int _orderIndex)
{
	local	int 	_bucket;

	retInt = 0;

	_bucket = initIterateGroupCmd(buildGr,true,false,true);
	tempDroid = iterateGroupCmd(buildGr,_bucket);
	while(tempDroid != NULLOBJECT)
	{
		if((_orderIndex < 0) or (tempDroid.order == _orderIndex))	//Any order or right order type
		{
			//Within some range
			if(distBetweenTwoPoints(_x, _y, tempDroid.orderx , tempDroid.ordery) <= 64)
			{
				retInt = retInt + 1;
			}
		}
		tempDroid = iterateGroupCmd(buildGr,_bucket);
	}

	return(retInt);
}

//---------------------------------------------------------------
//	Find out if a truck is already building on the spot where
//	another truck might try to build and will fail
//---------------------------------------------------------------
function bool buildingSiteBlocked(DROID _truck, int _radius, int _x, int _y, bool _bAllOrders)
{
	local	int 	_bucket;
	local	DROID	_tempDroid;

	_bucket = initIterateGroupCmd(buildGr,true,false,true);
	_tempDroid = iterateGroupCmd(buildGr,_bucket);
	while(_tempDroid != NULLOBJECT)
	{
		if(_tempDroid != _truck)		//Not himself (_truck allowed to be NULLOBJECT)
		{
			if(_tempDroid.orderx > 0)
			{
				//Within some range
				if(distBetweenTwoPoints(_x, _y, _tempDroid.orderx , _tempDroid.ordery) <= _radius)
				{
					if(_bAllOrders)
					{
						if(_tempDroid.order != DORDER_NONE)
						{
							return true;
						}
					}
					else
					{
						if((_tempDroid.order == DORDER_BUILD) or (_tempDroid.order == DORDER_LINEBUILD))
						{
							return true;		//Spot busy
						}
					}
				}
			}

		}
		_tempDroid = iterateGroupCmd(buildGr,_bucket);
	}

	return false;
}

//Don't have to be deactivated
event droidDestroyed(droidDestroyedTr)
{
	local	DROID		_commander,_newDroid,_droid;
	local	GROUP		_cmdGroup,_group;
	local	int			_cmdIndex;

	//ASSERT(count >= 0 and count < MAX_PLAYERS, "wrong player index: " & count, me);

	//Calculate how much a player has lost in power currency
	lostDroids[me] = lostDroids[me] + calcDroidPower(droid);

	//If a commander has lost a unit give it another unit

	if(droid.droidType == DROID_COMMAND)
	{
		_cmdGroup = droid.group;
		_cmdIndex = cmdToIndex(droid);

		if(_cmdIndex >= 0)
		{
			_group = cmdGr[_cmdIndex];	//group a commander belonged to

			dbg("Destroyed commander had " & _cmdGroup.members & " attached", me);

			//Add all units controlled by the commander to the group commander belonged to
			initIterateGroup(_cmdGroup);
			_droid = iterateGroup(_cmdGroup);
			while(_droid != NULLOBJECT)
			{
				groupAddDroid(_group, _droid);
				_droid = iterateGroup(_cmdGroup);
			}

			//refill other commanders from the same group as this commander with unassigned droids
			assignDroidsToBestCommandersFromGroup(_group, _group);
		}

	}

	//See if a unit belonged to a commander group and find a new unit for a commander
	if((droid.droidType != DROID_TRANSPORTER) and (droid.droidType != DROID_COMMAND))
	{
		if(droid.group != NULLOBJECT)		//this droid belonged to a group
		{
			if(droid.group.type == GT_COMMAND)		//if it's a commander group unit belonged to
			{
				dbg("Destroyed unit from a commander group", me);

				_commander = droid.group.commander;
				_cmdIndex = cmdToIndex(_commander);
				if(_commander != NULLOBJECT and _cmdIndex >= 0)
				{
					ASSERT(_commander.droidType == DROID_COMMAND, "Droid is not a commander", me);

					// find a droid not in a command group closest to the commander
					//_newDroid = closestDroidByGroup(defendGr, _commander.x, _commander.y, false);
					_newDroid = closestDroidByGroup(cmdGr[_cmdIndex], _commander.x, _commander.y, false);

					if(_newDroid != NULLOBJECT)
					{
						//make sure a new unit will not have to travel too far
						if(distBetweenTwoPoints(_x, _y, _droid.x, _droid.y) < MAX_CMD_ASSIGN_DIST)
						{
							dbg("Assigned a new droid to a commander", me);
							cmdDroidAddDroid(_commander, _newDroid);
						}
					}
				}
			}
		}
	}
}

event structDestroyed(inactive)
{
	local	int i,_numEnemies;

	if(structure == NULLOBJECT)
		exit;

	// deal with a destroyed derrick
	if(structure.stat == derrick)
	{
		if(!isInMyBase(structure.x,structure.y))
		{
			_numEnemies = enemyWeapObjCostInRange(me, structure.x, structure.y,
				CHECK_OIL_THREAT_RANGE, false, true);

			tOilAttackBegin = GAME_TIME_IN_SECS;
			tLastOilAttack = GAME_TIME_IN_SECS;
			lastOilAttackedX = structure.x;
			lastOilAttackedY = structure.y;

			//if(checkOilThreat(structure.x, structure.y))
			//{
				if(canStartDefendingOil())
				{
					// start defending oil
					initializeStartDefeindingOil(structure.x, structure.y);
				}
			//}
		}
	}


	/* Update ghost data */
	if(structure.player == me)
	{
		if((structure.stat == wall) or (structure.stattype == REF_DEFENSE))
		{
			/* Find structure that was destroyed */
			i = 0;
			while(i < maxGhosts)
			{
				if((ghostx[i] == structure.x) and (ghosty[i] == structure.y) and (ghostStat[i] == structure.stat))
				{
					dbg("FOUND DESTROYED STRUCTURE!!!!!", me);
					ghostDead[i] = TRUE;
					i = maxGhosts;			//exit
				}
				i = i + 1;
			}
		}
	}

	/* remember we lost LasSat */
	if(structure.stat == lasSat)
	{
		lasSatState[me] = lsNone;
	}
}

function bool manageOilSite(DROID _truck, STRUCTURE _derrick)
{
	local	int			_threatRange;
	local	bool		_bBusy,_bThreat;
	local	STRUCTURE	_enemyDerrick;

	_threatRange = (TILE * 8);

	_bBusy = false;

	// attack unprotected enemy derrick with defenses, if can
	_enemyDerrick = getClosestEnemyStructByType(_derrick.x, _derrick.y, NEXT_OIL_RANGE, REF_RESOURCE_EXTRACTOR, me);
	if(_enemyDerrick != NULLOBJECT)
	{
		// check if there are any enemy structures or droid nearby
		_bThreat = false;
		if(threatInRange(me, _enemyDerrick.x, _enemyDerrick.y, _threatRange, false))
		{
			_bThreat = true;
		}

		// if there are unbuilt structures, check if there's an enemy truck that could finish building it (assume it will be faster than us)
		if(!_bThreat)
		{
			if(numEnemyWeapStructsInRange(me, _enemyDerrick.x, _enemyDerrick.y, NEXT_OIL_RANGE, false) > 0)
			{
				if(closestEnemyDroidByType(_enemyDerrick.x, _enemyDerrick.x , _threatRange, DROID_CONSTRUCT) != NULLOBJECT)
				{
					_bThreat = true;
				}

				if(closestEnemyDroidByType(_enemyDerrick.x, _enemyDerrick.x, _threatRange, DROID_CYBORG_CONSTRUCT) != NULLOBJECT)
				{
					_bThreat = true;
				}
			}
		}

		// build defenses near enemy derrick, if it's not dangerous
		if(!_bThreat)
		{
			// build defenses near enemy derrick => destroy it
			if(buildDerrickDefence(_enemyDerrick, _truck))
			{
				dbg("ATTACKING ENEMY DERRICK WITH DEFENSES!!!", me);
				return true;
			}
		}
	}

	// TODO: also protect burning oil derricks, with a lower priority

	/* check if we can build another derrick near this one */
	if(!structureLimitReached(derrick, me))
	{
		// try to build next oil nearby, exit here if succeeded
		if(buildNextOil(_truck, NEXT_OIL_RANGE, true))
		{
			return true;
		}
	}
	else
	{
		dbg("can't build more derricks", me);
	}

	// if there's threat nearby, then first try to repair structures
	if(threatInRange(me, _derrick.x, _derrick.y, _threatRange, false))
	{
		if(repairDamagedDefenses(_derrick.x, _derrick.y, _truck, 50, RANGE_ALL_OIL_DEFENSES)){
			return true;
		}

		if(finishDefenses(_truck, _derrick.x, _derrick.y, RANGE_ALL_OIL_DEFENSES)){
			return true;
		}
	}
	else
	{
		if(finishDefenses(_truck, _derrick.x, _derrick.y, RANGE_ALL_OIL_DEFENSES)){
			return true;
		}

		if(repairDamagedDefenses(_derrick.x, _derrick.y, _truck, 50, RANGE_ALL_OIL_DEFENSES)){
			return true;
		}
	}

	if(buildDerrickDefence(_derrick, _truck))
	{
		return true;
	}

	return false;
}

event structBuilt(inactive)
{
	local	FEATURE		_oilResource;
	local	STRUCTURE	_closestDerrick;
	local	int			_count,_count2;

	//dbg(" " & me & ")  CALLBACK - built (" & structure.x & "-" & structure.y & ")", me);

	if(structure == NULLOBJECT)
	{
		MsgBox("structBuilt - structure NULLOBJECT");
		exit;
	}

	if(droid == NULLOBJECT)
	{
		MsgBox("structBuilt - droid NULLOBJECT");
		exit;
	}

	/* remember we have LasSat */
	if(structure.stat == lasSat)
	{
		dbg("buildInitialDefenses() - lassat built", me);
		resetLasSat();
		lasSatState[me] = lsRecharging;
	}

	/* build next anti-rush defense if just finished one,
	don't let other building routines intercept this truck */
	if((droid == initialDefensesTruck) and (not initialDefensesFinished))
	{
		buildInitialDefenses(TRUE);
		exit;
	}

	/* give allies vision of the entire map */
	if(structure.stat == uplink)
	{
		refreshAllyRadar();
	}

	/* check if it's the right structure type */
	if(structure.stattype == REF_DEFENSE)
	{
		/* find derrick we were building defense for */
		_closestDerrick = closestDerrick(structure.x, structure.y);

		if(_closestDerrick == NULLOBJECT){
			exit;
		}

		/* exit if this defense was not built for a derrick */
		if(distBetweenTwoPoints(_closestDerrick.x, _closestDerrick.y,
			structure.x, structure.y) > oilDefensesRange){	//closest derrick - built defense
			exit;
		}

		structure = _closestDerrick;		//remember derrick for defenses building

		// if(!isInMyBase(_closestDerrick.x, _closestDerrick.y))
		// {
			if(manageOilSite(droid, _closestDerrick))
			{
				exit;
			}
		// }

		// try to find any unoccupied oil resource
		if(buildNextOil(droid, NEXT_OIL_RANGE, false))
		{
			exit;
		}
	}
	else if(structure.stat == derrick)
	{
		// if(!isInMyBase(structure.x, structure.y))
		// {
			if(manageOilSite(droid, structure))
			{
				exit;
			}
		// }

		// try to find any unoccupied oil resource
		if(buildNextOil(droid, NEXT_OIL_RANGE, false))
		{
			exit;
		}
	}
	else if(structure.stattype == REF_FACTORY)	/* factory or factory module */
	{
		if( isStructureAvailable(facMod,me) and (skGetFactoryCapacity(structure) < 2 ))
		{
			orderDroidStatsLoc(droid, DORDER_BUILD, facMod, structure.x, structure.y);	// upgrade it.
			exit;
		}
	}
	else if(!defending() and structure.stattype == REF_VTOL_FACTORY)	/* vtol factory or vtol factory module */
	{
		if( isStructureAvailable(facMod,me) and (skGetFactoryCapacity(structure) < 2 ))
		{
			orderDroidStatsLoc(droid, DORDER_BUILD,facMod, structure.x,structure.y);	// upgrade it.
			exit;
		}
	}
	else if(!defending() and structure.stattype == REF_POWER_GEN)	/* power generator */
	{
		if( isStructureAvailable(powMod,me) and (not testStructureModule(me, structure, 0)))
		{
			orderDroidStatsLoc(droid, DORDER_BUILD,powMod, structure.x,structure.y);	// upgrade it.
			exit;
		}
	}
	else
	{
		exit;
	}

	//if(bResult){exit;}		//already started building with this truck

/* 	if(structure == NULLOBJECT){exit;}	//don't have a derrick to defend

	if(structure.stat != derrick){exit;}	//make sure we are going to build defenses for a derrick

	if(defending()){exit;}

	// make the callback droid build a defence near this oil derrick
	buildDerrickDefence(structure, droid, NEXT_OIL_RANGE); */
}

event droidTakeOverEv(inactive)
{
	if(droid != NULLOBJECT)
	{
		if(droid.player == me)
		{
			assignDroid(droid);
		}
	}
	else
	{
		MsgBox("droidTakeOverEv - NULLOBJECT passed");
	}
}

//deal with a droid being built
event droidBuilt(inactive)
{
	assignDroid(droid);

	// start building trucks if we need any
	if(needTrucks()){
		buildTrucks();
	}

	// start build tanks
	if((tech == techTanks) or (playerPower(me) > muchoPower))
	{
		// if(canBuildTanks())
		// {
			buildTanks();
		// }
	}
}

function void assignDroid(DROID _droid)
{
	local	DROID	_commander;

	if(isVtol(_droid))
	{
		groupAddDroid(vtolGr, _droid);
	}
	else if(_droid.droidType == DROID_COMMAND)
	{
		assignCommander(_droid, defendGr);
	}
	else
	{
		setDroidSecondary(_droid, DSO_ATTACK_RANGE, DSS_ARANGE_LONG);
		setDroidSecondary(_droid, DSO_HALTTYPE, DSS_HALT_GUARD);

		if((_droid.droidType == DROID_CONSTRUCT) or
			(_droid.droidType == DROID_CYBORG_CONSTRUCT))				// if constructor droid
		{
			/* make it build anti-rush defenses if still not finished */
			if(!initialDefensesFinished)
			{
				if((groupSizeCmds(buildGr,true,false,true) >= 5) and (initialDefensesTruck == NULLOBJECT))
				{
					dbg("buildInitialDefenses() assigned truck", me);
					initialDefensesTruck = _droid;
					buildInitialDefenses(true);
					return;
				}
			}

			// add to the build group
			groupAddDroid(buildGr, _droid);
		}
		else if(_droid.droidType == DROID_TRANSPORTER)
		{
			dbg("built transporter", me);

			temp = 0;
			bResult = TRUE;
			while((temp < 10) and bResult)
			{
				if(transporter[temp] == NULLOBJECT)
				{
					dbg("built transporter " & temp, me);
					transporter[temp] = _droid;
					orderDroidLoc(_droid, DORDER_MOVE, baseX, baseY);
					bResult = FALSE;
				}
				temp = temp + 1;
			}
		}
		else if((_droid.droidType == DROID_REPAIR) or
			   (_droid.droidType == DROID_CYBORG_REPAIR))
		{
			setDroidSecondary(_droid, DSO_HALTTYPE, DSS_HALT_PERSUE);

			//commanders have priority
			_commander = bestCommanderWithoutRepairer();
			if(_commander != NULLOBJECT)
			{
				dbg("Added repeir droid to commander " & cmdToIndex(_commander), me);

				ASSERT(_commander.droidType == DROID_COMMAND, "Droid is not a commander", me);

				groupAddDroid(cmdRepGr[ cmdToIndex(_commander) ], _droid);
			}
			else	//add to defenders if no commander needs repair units
			{
				groupAddDroid(defendRepairGr, _droid);
			}
		}
		else if(_droid.weapon == weaponBB)
		{
			//prfunction void BBs from wasting ammo on units
			//setDroidSecondary(_droid, DSO_ATTACK_LEVEL, DSS_ALEV_ATTACKED);
			groupAddDroid(defendGr, _droid);
			assignDroidToBestCommander(_droid, defendGr);
		}
		else
		{
			bResult = FALSE;

			//don't add to scouts if not early-game anymore and not enough defenders
			bResult2 = TRUE;
			if((groupSizeCmds(defendGr,true,false,true) < numDefenders) and (GAME_TIME_IN_SECS > SCOUT_BUILD_TIME))
			{
				bResult2 = FALSE;
			}

			if(defending()){
				bResult2 = false;
			}

			if(watchWindowDebug == WATCH_DEBUG_RESEARCH){
				setDebugMenuEntry("to scouts: " & addScout & "/" & lowMilitary & "/" & bResult2, 8);
			}

			if((addScout == 0) and !lowMilitary and bResult2)	//for scouts?
			{
				if(groupSizeCmds(enemyScoutGr,true,false,true) < numEnemyScouts and bToEnemyScoutGr)
				{
					// send to the scout location immediately
					if(realEnemyScoutX > 0 and realEnemyScoutY > 0){
						orderDroidLoc(_droid, DORDER_MOVE, realEnemyScoutX, realEnemyScoutY);
					}

					groupAddDroid(enemyScoutGr, _droid);
					bResult = TRUE;
					bToEnemyScoutGr = !bToEnemyScoutGr;
				}
				else if(groupSizeCmds(scoutGr,true,false,true) < numOilScouts and !bToEnemyScoutGr)
				{
					groupAddDroid(scoutGr, _droid);
					bResult = TRUE;
					bToEnemyScoutGr = !bToEnemyScoutGr;
				}
			}

			if((addScout != 0) or !bResult)		//for attackers, or scouts were full
			{
				if((defendX != none) and (defendY != none))
				{
					result = numFriendlyWeapObjInRange(me, defendX, defendY, (10 * 128), false, true);
					result2 = numEnemyWeapObjInRange(me, defendX, defendY, (10 * 128), false, true);

					if((groupSizeCmds(defendGr,true,false,true) >= minDefenders) or (result >= result2))	//don't send one by one or if dangerous
					{
						orderDroidLoc(_droid, DORDER_SCOUT, defendX, defendY);
					}
				}

				groupAddDroid(defendGr, _droid);
				assignDroidToBestCommander(_droid, defendGr);

				/* remember we'd finished building first-time defenders */
				if((groupSizeCmds(defendGr,true,false,true) >= minDefenders) or (gameTime > (8 * 600)))		//8 mins
					bFirstTimeDefenders = FALSE;
			}

			addScout++;
			if(addScout > addScoutInterval)
			{
				addScout = 0;		//add to scouts next one
			}
		}
	}
}

// Update scout variables
function void updateMaxScouts()
{
	minEnemyScouts = 1;

	enemyScoutRange = (13 * 128);		//revealed when within this range

	addScout = 0;	//next tank is for scouts

	// addScoutInterval = (int) ( ((float)MAX_SCOUTS_PRIORITY - (float)MIN_SCOUTS_PRIORITY) /
						// ((float)SCOUT_MIN_OIL_RES - (float)SCOUT_MAX_OIL_RES) *
						// (float)numVisibleOilResInRange() + (float)MAX_SCOUTS_PRIORITY );

	// use more scouts if there are not many revealed oil resources [ y = mx+z  =>  y = (x1 - x2 / y1 - y2)x + z ]
	addScoutInterval = (int)(((float)MIN_SCOUTS_PRIORITY - (float)MAX_SCOUTS_PRIORITY) /
						(MAP_REVEAL_FAC_UBOUND - MAP_REVEAL_FAC_LBOUND) *
						fMapRevealFactor +
						(float)MAX_SCOUTS_PRIORITY);
	if(watchWindowDebug == WATCH_DEBUG_RESEARCH)
	{
		setDebugMenuEntry("addScoutInterval: " & addScoutInterval & "(" &  min(addScoutInterval, MIN_SCOUTS_PRIORITY)
		 & "/" & max(min(addScoutInterval, MIN_SCOUTS_PRIORITY), MAX_SCOUTS_PRIORITY) & ")", 4);
	}
	// make sure addScoutInterval is between MAX_SCOUTS_PRIORITY and MIN_SCOUTS_PRIORITY
	addScoutInterval = min(addScoutInterval, MIN_SCOUTS_PRIORITY);
	addScoutInterval = max(addScoutInterval, MAX_SCOUTS_PRIORITY);

	// use 2 scouts when scouting has a high priority
	// if(addScoutInterval <= MAX_SCOUTS_PRIORITY){
		// maxEnemyScouts = 2;
	// }else{
		maxEnemyScouts = 1;
	// }

	numEnemyScouts = maxEnemyScouts;

	if(GAME_TIME_IN_SECS <= STARTUP_PHASE_LEN){
		dbg("addScoutInterval = " & addScoutInterval, me);
	}


	scoutStep = (25 * 128);		//inacrease search area by this value
	scoutRange = scoutStep;		//start with small area

	enemyScoutX = none;
	enemyScoutY = none;

	enemyScoutStep = (18 * 128);

	// define number of oil scouts depending on the map reveal factor (linear function)
	maxOilScouts = (int)((float)(MIN_OIL_SCOUTS - MAX_OIL_SCOUTS) /
						(MAP_REVEAL_FAC_UBOUND - MAP_REVEAL_FAC_LBOUND) *
						fMapRevealFactor) + MAX_OIL_SCOUTS;

	//adapt for big maps
	if(bigMap)
	{
		enemyScoutStep = (25 * 128);

		maxOilScouts++;
		scoutStep = scoutStep + (TILE * 12);
		scoutRange = scoutStep;
	}

	numOilScouts = maxOilScouts;
}

//Group can be NULLOBJECT
function DROID closestDroidByGroup(GROUP _group, int _x, int _y, bool _bIncludeCommanders)
{
	local	DROID	_droid,_closestDroid;
	local	int		_closestDistance,_dist,_bucket;

	_closestDistance = 99999;
	_closestDroid = NULLOBJECT;

	if(_group != NULLOBJECT)
	{
		_bucket = initIterateGroupCmd(_group,true,_bIncludeCommanders,_bIncludeCommanders);
		_droid = iterateGroupCmd(_group, _bucket);
		while(_droid != NULLOBJECT)
		{
			//calculate the distance between the _commander and droid
			_dist = distBetweenTwoPoints(_x, _y, _droid.x, _droid.y);

			if(_dist < _closestDistance)
			{
				_closestDistance = _dist;
				_closestDroid = _droid;
			}

			_droid = iterateGroupCmd(_group,_bucket);
		}
	}

	return _closestDroid;
}

	/************************************
			COMMANDER STUFF
	*************************************/
/* Unassign all droids from all commanders belonging to a certain group */
function void unassignAllDroidsFromCMDsFromGroup(GROUP _unassignGroup, GROUP _toGroup)
{
	local	int		_cmdIndex;

	_cmdIndex = 0;
	while(_cmdIndex < MAX_COMMANDERS)
	{
		if(cmds[_cmdIndex] != NULLOBJECT)
		{
			if((_unassignGroup == NULLOBJECT) or (_unassignGroup == cmdGr[_cmdIndex]))
			{
				unassignAllDroidsFromCMD(cmds[_cmdIndex], _toGroup);
			}
		}
		_cmdIndex++;
	}
}

/* Unassign all units from a commander */
function void unassignAllDroidsFromCMD(DROID _commander, GROUP _toGroup)
{
	local	GROUP 	_cmdGroup;
	local	DROID	_groupMember;

	ASSERT(_commander != NULLOBJECT,
		"unassignAllDroidsFromCMD: _commander is NULL", me);

	_cmdGroup = _commander.group;

	initIterateGroup(_cmdGroup);
	_groupMember = iterateGroup(_cmdGroup);
	while(_groupMember != NULLOBJECT)
	{
		ASSERT(_groupMember.droidType != DROID_COMMAND,
			"unassignAllDroidsFromCMD: unassigning a commander from a commander group?", me);

		//droidLeaveGroup(_groupMember);
		groupAddDroid(_toGroup, _groupMember);
		_groupMember = iterateGroup(_cmdGroup);
	}
}

/* Goes through all commanders from group x and assigns droids from group x to all commanders from group x in a smart way */
function void assignDroidsToBestCommandersFromGroup(GROUP _fromGroup, GROUP _toGroup)
{
	local	int		_cmdIndex,_bestCMDKills,_tmpCmdKills,_bestCost,_tmpCost,
					_bucket;
	local	DROID	_droid,_bestCMD,_bestDroid;
	local	bool	_bStop;

	_bStop = false;

	while(!_bStop and
		groupSizeCmds(_fromGroup, true, false, false) > 0)	//only count unassigned droids
	{
		_cmdIndex = 0;
		_bestCMDKills = (-1);
		_bestCMD = NULLOBJECT;

		while(_cmdIndex < MAX_COMMANDERS)
		{
			// find best commander with highest rank
			if(cmds[_cmdIndex] != NULLOBJECT)
			{
				if( (_toGroup == cmdGr[_cmdIndex]) and 			//the right group
					(cmds[_cmdIndex].group.members < cmdDroidMaxGroup(cmds[_cmdIndex])) )	//commander can take more droids
				{
					_tmpCmdKills = getDroidKills(cmds[_cmdIndex]);

					if(_tmpCmdKills > _bestCMDKills)
					{
						_bestCMD = cmds[_cmdIndex];
						_bestCMDKills = _tmpCmdKills;
					}
				}
			}
			_cmdIndex++;
		}

		//Now fill droids for the best found commander
		if(_bestCMD != NULLOBJECT)
		{
			while( (_bestCMD.group.members < cmdDroidMaxGroup(_bestCMD)) and //while commander group not filles
				(groupSizeCmds(_fromGroup, true, false, false) > 0) )	//while there are still more droids in the _fromGroup group
			{
				_bestCost = (-1);
				_bestDroid = NULLOBJECT;

				//Find the most expensive droid
				_bucket = initIterateGroupCmd(_fromGroup,true,false,false);	//don't touch units from commander group
				_droid = iterateGroupCmd(_fromGroup,_bucket);
				while(_droid != NULLOBJECT)
				{
					_tmpCost = calcDroidPower(_droid);

					if(_tmpCost > _bestCost)
					{
						_bestCost = _tmpCost;
						_bestDroid = _droid;
					}

					_droid = iterateGroupCmd(_fromGroup,_bucket);
				}

				//Add best droid to the best commander
				if(_bestCMD != NULLOBJECT)
				{
					cmdDroidAddDroid(_bestCMD, _bestDroid);
				}
			}
		}
		else
		{
			_bStop = true;	//No more commanders left, stop here
		}
	}

}

/* Uses MCDM */
function void assignDroidToBestCommander(DROID _droid, GROUP _group)
{
	local	int		_cmdIndex,_tilesPerDroid,_tilesPerRank,_tileDist,_bestScore,
					_score,_rank,_cmdGroupSize;
	local	DROID	_bestCommander;

	_tilesPerDroid = (TILE * 3);	//1 droid = 3 tiles
	_tilesPerRank = (TILE * 7);		//1 rank higher = 6 tiles

	_bestScore = (-99999);
	_bestCommander = NULLOBJECT;

	//find the most suitable commander, consider distance to the commander, size of its group and commander rank
	_cmdIndex = 0;
	while(_cmdIndex < MAX_COMMANDERS)
	{
		if(cmds[_cmdIndex] != NULLOBJECT)
		{
			//if group is specified make sure commander belongs to this group
			if((_group == NULLOBJECT) or (cmdGr[_cmdIndex] == _group))
			{
				//skip commanders who already have a full group
				if(cmds[_cmdIndex].group.members < cmdDroidMaxGroup(cmds[_cmdIndex]))
				{
					//calculate distance between the base range and commander (will be 0 if commander is withon the base range)
					_tileDist = (distBetweenTwoPoints(cmds[_cmdIndex].x, cmds[_cmdIndex].y, _droid.x, _droid.y) -
						(baseRange + defendCorridor)) / TILE;
					_tileDist = max(0, _tileDist);	//make sure distance is not negative

					_rank = getDroidRank(cmds[_cmdIndex]);
					_cmdGroupSize = cmds[_cmdIndex].group.members;

					//calculate score
					_score = _rank * _tilesPerRank - _cmdGroupSize * _tilesPerDroid - _dist;

					//check if this commander is the best one so far
					if(_score > _bestScore)
					{
						_bestScore = _score;
						_bestCommander = cmds[_cmdIndex];
					}
				}
			}
		}

		_cmdIndex++;
	}

	//add droid to the group of the best suitable commander
	if(_bestCommander != NULLOBJECT)
	{
		cmdDroidAddDroid(_bestCommander, _droid);
	}
}

//Store a newly built comander
function void assignCommander(DROID _newCommander, GROUP _group)
{
	local	int		_index;

	// FIXME: number of commander can exceed MAX_COMMANDERS

	_index = 0;
	while(_index < MAX_COMMANDERS)
	{
		if(cmds[_index] == NULLOBJECT)		//found a free slot
		{
			//store commander
			cmds[_index] = _newCommander;
			cmdGr[_index] = _group;			//set group commander belongs to

			//Add droids without commander to the new commander
			fillCommanderGroup(_newCommander, _group);

			return;
		}
		_index++;
	}
}

/* Add droids to the _commander */
function void fillCommanderGroup(DROID _commander, GROUP _fillFromGroup)
{
	local	GROUP	_cmdGroup;
	local	DROID	_droid,_closestDroid;
	local	int		_freeCapacity,_index,_closestDistance,_cmdX,_cmdY,_dist;

	_cmdGroup = _commander.group;

	//Find out how many droids this commander can have in a group
	_freeCapacity = cmdDroidMaxGroup(_commander) - _cmdGroup.members;

	_cmdX = _commander.x;
	_cmdY = _commander.x;

	_index = 0;
	while(_index < _freeCapacity)
	{
		_closestDroid = NULLOBJECT;
		_closestDistance = 99999;

		_closestDroid = closestDroidByGroup(_fillFromGroup, _commander.x, _commander.y, false);

		//Add found droid to the _commander
		if(_closestDroid != NULLOBJECT)
		{
			cmdDroidAddDroid(_commander, _closestDroid);
		}

		_index++;
	}

	dbg("Adding " & _index & "/" & _freeCapacity & " to the commander", me);
}

/* Check if we can build commanders */
function bool canUseCommanders()
{
	haveCommandTech = researchFinished(resCmd, me);

	if(haveCommandTech)
	{
		if(structureBuilt(cmdCenter, me))		//make sure command center is finished building
		{
			return true;
		}
	}

	return false;
}

/* Returns number of commanders */
function int getNumCommanders()
{
	/* local	int		_index,_numCmds;

	_numCmds = 0;
	_index = 0;
	while(_index < MAX_COMMANDERS)
	{
		if(cmds[_index] != NULLOBJECT)
		{
			_numCmds++;
		}
		_index++;
	}

	return _numCmds; */

	return numDroidsByComponent(cmdTurret, me, me);
}

/* Returns how many units can be attached to all available commanders (_group == NULLOBJECT) or to all commanders in some group (_group != NULLOBJECT) */
function int getTotalCmdsCapacity(GROUP _group, bool _bIncludeInProduction)
{
	local	int		_index,_numDroids;

	_numDroids = 0;
	_index = 0;
	while(_index < MAX_COMMANDERS)
	{
		if(cmds[_index] != NULLOBJECT)
		{
			if((_group == NULLOBJECT) or (cmdGr[_index] == _group))		//make sure commander belongs to the right group
			{
				_numDroids = _numDroids + cmdDroidMaxGroup(cmds[_index]);
			}
		}
		_index++;
	}

	//Check if we have to include commanders that are getting built now
	if(_bIncludeInProduction)
	{
		_numDroids = _numDroids + numCommandersInProduction() * CMD_INIT_CAPACITY;
	}

	return _numDroids;
}

/* Returns total number of droids that can still be assigned to commanders belonging to a certain group */
function int getFreeCmdsCapacityInGroup(GROUP _group)
{
	local	int		_index,_numDroids;

	_numDroids = 0;
	_index = 0;
	while(_index < MAX_COMMANDERS)
	{
		if(cmds[_index] != NULLOBJECT)
		{
			if((_group == NULLOBJECT) or (cmdGr[_index] == _group))		//make sure commander belongs to the right group
			{
				_numDroids = _numDroids +
					cmdDroidMaxGroup(cmds[_index]) - cmds[_index].group.members;
			}
		}
		_index++;
	}

	return _numDroids;
}

/* fill commanders with highest rank into some group until some tatal capacity is reached */
function void fillBestCommandersCapacity(int _maxCapacity, GROUP _newGroup,
															GROUP _oldGroup)
{
	local int	_curCapacity,_cmdIndex,_bestKills,_tmpKills,_bestCMDIndex;
	local bool	_bCMDsLeftToIterate;
	local DROID	_bestCommander;

	dbg("fillBestCommandersCapacity: _maxCapacity = " & _maxCapacity, me);

	_curCapacity = 0;
	_cmdIndex = 0;

	//make sure there are commanders left in the old group we can iterate over
	_bCMDsLeftToIterate = (groupSizeCmds(_oldGroup, false, true, false) > 0);

	//iterate over all commanders until capacity is filled or no commanders left in the old group
	while((_curCapacity < _maxCapacity) and _bCMDsLeftToIterate)
	{
		_cmdIndex = 0;
		_bestKills = (-1);
		_bestCMDIndex = (-1);
		_bestCommander = NULLOBJECT;

		while(_cmdIndex < MAX_COMMANDERS)
		{
			if(cmds[_cmdIndex] != NULLOBJECT)
			{
				if( ((_oldGroup == NULLOBJECT) or (cmdGr[_cmdIndex] == _oldGroup))	//cmd is in the right group
					and (cmdGr[_cmdIndex] != _newGroup))		//make sure we won't re-add commanders we just added
				{
					_tmpKills = getDroidKills(cmds[_cmdIndex]);

					if(_tmpKills > _bestKills)
					{
						_bestCommander = cmds[_cmdIndex];
						_bestCMDIndex = _cmdIndex;
						_bestKills = _tmpKills;
					}
				}
			}
			_cmdIndex++;
		}

		// add commander with the most kills to the new group
		if(_bestCommander != NULLOBJECT)
		{
			cmdGr[_bestCMDIndex] = _newGroup;	//change commander's group
			_curCapacity = _curCapacity + cmdDroidMaxGroup(_bestCommander);
		}

		//make sure there are commanders left in the old group we can iterate over
		_bCMDsLeftToIterate = (groupSizeCmds(_oldGroup, false, true, false) > 0);
	}
}

/* Goes through all commander groups and counts how many repairers are missing in total */
function int numMissingCmdRepairers(int _groupIndex, bool _bIncludeDeadCmds)
{
	local	int		_numMissing,_index;

	_index = 0;
	_numMissing = 0;
	while(_index < MAX_COMMANDERS)
	{
		if(_bIncludeDeadCmds or (cmds[_index] != NULLOBJECT))
		{
			if((_groupIndex < 0) or (_index == _groupIndex))
			{
				// make sure commander has any droids attached or has a high level
				if((cmds[_index].group.members > 0) or
					(getDroidRank(cmds[_index]) >= 2))
				{
					_numMissing = _numMissing +
						max(NUM_REPAIRS_FOR_CMD - cmdRepGr[_index].members, 0);	//max = don't reduce _numMissing if cmd has more than NUM_REPAIRS_FOR_CMD repairers
				}
			}
		}
		_index++;
	}

	return _numMissing;
}

/* Returns the commander the deserves to get a new repair unit */
function DROID bestCommanderWithoutRepairer()
{
	local	int			_index,_tmpScore,_bestScore;
	local	DROID		_bestCommander,_commander;

	_bestScore = 0;
	_index = 0;
	_bestCommander = NULLOBJECT;
	while(_index < MAX_COMMANDERS)
	{
		if(cmds[_index] != NULLOBJECT)
		{
			//make sure this commander still needs repair units
			if(cmdRepGr[_index].members < NUM_REPAIRS_FOR_CMD)	//not to omany
			{
				//best score in kills
				_tmpScore =  getDroidKills(cmds[_index]) +		// commander rank
							((100 - cmds[_index].health) / 2) +		// damage in % / weight
							((NUM_REPAIRS_FOR_CMD - cmdRepGr[_index].members) * 30);	//missing repairers * weight

				if(_tmpScore > _bestScore)
				{
					_bestScore = _tmpScore;
					_bestCommander = cmds[_index];
				}
			}
		}
		_index++;
	}

	return _bestCommander;
}


//==============================================================================================
//	>>>>>>>>>>>>>>>>>>>>>>>>	MILITARY STUFF		<<<<<<<<<<<<<<<<<<<<<<<<<
//==============================================================================================

event manageCMDRepairsEv(inactive)
{
	repairCMDGroup();
}

/* Repair and follow commanders */
function void repairCMDGroup()
{
	local	int		_cmdIndex,_x,_y,_maxDistanceFromCMD,_bucket,_distanceFromCMD;
	local	DROID	_repairer,_droidToRepair,_commanderToRepair;
	local	bool	_bBusy;

	_bBusy = false;

	_cmdIndex = 0;
	while(_cmdIndex < MAX_COMMANDERS)
	{
		if((cmds[_cmdIndex] != NULLOBJECT) and (cmdRepGr[_cmdIndex].members > 0))
		{
			// see if we have to repair commander
			_commanderToRepair = NULLOBJECT;
			if(cmds[_cmdIndex].health < 95){
				_commanderToRepair = cmds[_cmdIndex];
			}

			// iterate through all repair droids this commander group has and look if it is too far away from the commander
			_bucket = initIterateGroupCmd(cmdRepGr[_cmdIndex],true,true,true);
			_repairer = iterateGroupCmd(cmdRepGr[_cmdIndex],_bucket);
			while(_repairer != NULLOBJECT)
			{
				_bBusy = false;

				// if not repairing commander
				if(! (_repairer.order == DORDER_DROIDREPAIR and	// don't do anything if repairing commander already
					_repairer.target == cmds[_cmdIndex]) )
				{
					// see if we have to repair our commander
					if(_commanderToRepair != NULLOBJECT)
					{
						_bBusy = true;
						orderDroidObj(_repairer, DORDER_DROIDREPAIR, _commanderToRepair);
					}
					else	// see if we have to come closer to the commander if we are not already on the way to the commander
					{
						// if repairer is repairing something (explicitly or implicitly) he can stay further away from the commander
						_maxDistanceFromCMD = MAX_REP_DIST_FROM_CMD;	//if idle
						if(_repairer.order == DORDER_DROIDREPAIR or
							(droidActionDroidRepair(_repairer)))
						{
							_maxDistanceFromCMD = MAX_REP_DIST_FROM_CMD_WHILE_REP;
						}

						// find cur dist to the commander
						_distanceFromCMD = distBetweenTwoPoints(cmds[_cmdIndex].x,
											cmds[_cmdIndex].y, _repairer.x, _repairer.y);

						if(_distanceFromCMD > _maxDistanceFromCMD)	// too far away from commander
						{
							// already moving closer to the comander ?
							if( !( (_repairer.order == DORDER_MOVE) and (_repairer.orderx > 0) and
								(distBetweenTwoPoints(_repairer.orderx, _repairer.ordery, cmds[_cmdIndex].x, cmds[_cmdIndex].y) <
								(MAX_REP_DIST_FROM_CMD * 2) )) )
							{
								_x = baseX;		//_repairer.x;
								_y = baseY;		//_repairer.y;

								_bBusy = true;

								circlePerimPoint(cmds[_cmdIndex].x, cmds[_cmdIndex].y, ref _x, ref _y, (MAX_REP_DIST_FROM_CMD + 1) / 2);	//send back to commander
								orderDroidLoc(_repairer, DORDER_MOVE, _x, _y);

								dbg("Moving repairer to commander " & _cmdIndex & "(" & _x / TILE & "-" & _y / TILE & ")", me);
							}
						}
					}

					// if not coming closer to the commander and not repairing commander then repair a damaged droid if we have one
					if(!_bBusy and (_repairer.order != DORDER_DROIDREPAIR) and
							!droidActionDroidRepair(_repairer))	//not busy, not repairing
					{
						// find a damaged unit
						_droidToRepair = findCMDGroupObjectToRepair(_cmdIndex, _repairer);

						if(_droidToRepair != NULLOBJECT)
						{
							// order repair droid to repair this unit
							if(_droidToRepair != NULLOBJECT){
								orderDroidObj(_repairer, DORDER_DROIDREPAIR, _droidToRepair);
							}
						}
					}
				}
				_repairer = iterateGroupCmd(cmdRepGr[_cmdIndex],_bucket);
			}
		}
		_cmdIndex++;
	}
}

/* Find a droid commander repairs should repair */
function DROID findCMDGroupObjectToRepair(int _cmdIndex, DROID _repairer)
{
	local	DROID	_choiceDroid,_droid,_mostDamagedDroid,_damagedRepairer;
	local	int		_mostDamage,_tempDamage,_tempScore,_bestScore,_bucket,
					_distScore,_damageScore,_dist;

	_choiceDroid = NULLOBJECT;
	_mostDamagedDroid = NULLOBJECT;

	if(_cmdIndex >= MAX_COMMANDERS){
		return _choiceDroid;
	}

	// find a damaged repair unit
	_mostDamage = 0;
	_choiceDroid = NULLOBJECT;
	_bucket = initIterateGroupCmd(cmdRepGr[_cmdIndex],true,true,true);
	_damagedRepairer = iterateGroupCmd(cmdRepGr[_cmdIndex],_bucket);
	while(_damagedRepairer != NULLOBJECT)
	{
		// make sure we are not going to repair ourselves
		if(_damagedRepairer != _repairer)
		{
			_tempDamage = 100 - _damagedRepairer.health;

			// don't bother if too far away, will be ordered back anyway
			if(distBetweenTwoPoints(_damagedRepairer.x,_damagedRepairer.y,
				cmds[_cmdIndex].x, cmds[_cmdIndex].y) < MAX_REP_DIST_FROM_CMD_WHILE_REP)
			{
				// remember the most damaged repair unit
				if(_tempDamage > _mostDamage)
				{
					_mostDamage = _tempDamage;
					_choiceDroid = _damagedRepairer;
				}
			}
		}
		_damagedRepairer = iterateGroupCmd(cmdRepGr[_cmdIndex],_bucket);
	}

	// see if repair unit is slightly damaged
	if(_choiceDroid != NULLOBJECT)
	{
		if(_choiceDroid.health < 90)
		{
			return _choiceDroid;
		}
	}

	// find a damaged unit attached to a commander
	_bestScore = (-99999);
	_choiceDroid = NULLOBJECT;
	_bucket = initIterateGroupCmd(cmdRepGr[_cmdIndex],true,true,true);
	_droid = iterateGroupCmd(cmdRepGr[_cmdIndex],_bucket);
	while(_droid != NULLOBJECT)
	{
		// find out how far the damaged unit is from the repairer
		_dist = distBetweenTwoPoints(_repairer.x,_repairer.y,_droid.x,_droid.y);

		// consider health and distance from the commander, make sure droid is not too far away
		if((_droid.health < 90) and (_dist < MAX_REP_DIST_FROM_CMD_WHILE_REP))
		{
			// the closer the better
			_distScore = _dist / TILE;

			// the more damaged the better
			_damageScore = (100 - _droid.health);

			// calculate final score
			_tempScore = (int)((float)_damageScore * 2.3) - _distScore;

			// remember the most damaged repair unit
			if(_tempScore > _bestScore)
			{
				_bestScore = _tempScore;
				_choiceDroid = _droid;
			}
		}

		_droid = iterateGroupCmd(cmdRepGr[_cmdIndex],_bucket);
	}

	// see if this unit is really damaged and needs to be repaired
	if(_choiceDroid != NULLOBJECT)
	{
		return _choiceDroid;
	}

	_choiceDroid = NULLOBJECT;

	return _choiceDroid;
}

function bool repairDamagedDefenses(int _repairx, int _repairy, DROID _truck,
									int _minDamage, int _maxRange)
{
	local	int			_def,_mostDamage,_tempDamage;
	local	STRUCTURE	_defense, _mostDamagedDefense;

	_mostDamage = 0;
	_mostDamagedDefense = NULLOBJECT;

	_def = numDef;
	while(_def >= 0)
	{
		initEnumStruct(FALSE,def[_def],me,me);
		_defense = enumStruct();
		while(_defense != NULLOBJECT)
		{
			if(distBetweenTwoPoints(_defense.x, _defense.y, _repairx, _repairy) < _maxRange)
			{
				if(!buildingSiteBlocked(_truck, _maxRange, _defense.x, _defense.y, true))
				{
					_tempDamage = 100 - _defense.health;

					// damaged at least by _minDamage %
					if(_tempDamage >= _minDamage)
					{
						// remember the most damaged defense
						if(_tempDamage > _mostDamage)
						{
							_mostDamage = _tempDamage;
							_mostDamagedDefense = _defense;
						}
					}
				}
			}
			_defense = enumStruct();
		}

		_def--;
	}

	if(_mostDamagedDefense != NULLOBJECT)
	{
		orderDroidObj(_truck, DORDER_REPAIR, _mostDamagedDefense);
		return true;
	}

	return false;
}

event repairDefendDroids(inactive)
{
	if(groupSizeCmds(defendRepairGr,true,false,true) == 0){exit;}
	if(groupSizeCmds(defendGr,true,true,true) == 0){exit;}

	groupRepairGroup(defendGr, defendRepairGr);

	/* repair the repair droids if idle */
	if((groupSizeCmds(defendRepairGr,true,false,true) > 1) and (idleGroupCmd(defendRepairGr,true,false) > 0))
	{
		groupRepairGroup(defendGr, defendRepairGr);
	}
}

function void groupRepairGroup(GROUP _damagedGr, GROUP _repairerGr)
{
	local	int 	_bucket;

	_temp = maxDamageLevels - 1;	//start with heavyDamage, don't reset before loop to save CPU time
	_temp2 = 0;

	_bucket = initIterateGroupCmd(_repairerGr,true,false,true);
	_droid = iterateGroupCmd(_repairerGr,_bucket);
	while(_droid != NULLOBJECT)
	{
		if(_droid.order != DORDER_DROIDREPAIR)	//not already busy
		{
			/* look for a damaged unit, starting search with heavily damaged units */
			_droid2 = NULLOBJECT;		//damaged droid
			while((_temp >= 0) and (_droid2 == NULLOBJECT))	//first look for heavilyDamaged units, going up to lightDamage
			{
				/* find damaged droid no one is repairing yet */
				_droid2 = closestDamagedGroupDroid(me, _damagedGr, damageLevel[_temp], _droid.x, _droid.y, 0);
				if(_droid2 == NULLOBJECT)
				{
					_temp = _temp - 1;	//go to lighter damage levels
				}
			}

			if((_droid2 != NULLOBJECT) and (_droid != _droid2))	//found someone and him going to repair himself
			{
				//dbg("FOUND DAMAGED UNIT!!!! (for unit " & _temp2 & ")", me);
				orderDroidObj(_droid, DORDER_DROIDREPAIR, _droid2);
			}
			else if(droidOrderIdle(_droid) or (_droid.target == _droid))	//if idle or auto-repairing
			{
				/* if idle, check it's not too far away from the base */
				//_range = baseRange + defendCorridor;	//allow to repair defenders in the corridor as well
				//if((_droid.order == DORDER_NONE) and (_droid.target == NULLOBJECT))	//if not repairing
				//{
				//	_range = baseRange;	//move closer to base
				//}

				_range = baseRange;

				if(distBetweenTwoPoints(_droid.x, _droid.y, baseX, baseY) > _range)
				{
					//dbg("ORDERING REPAIR UNIT BACK TO BASE", me);
					_x = _droid.x;
					_y = _droid.y;
					circlePerimPoint(baseX, baseY, ref _x, ref _y, baseRange);	//send back to base
					orderDroidLoc(_droid, DORDER_MOVE, _x, _y);
				}
			}

			//don't reset _temp and don't start over for every repair unit, since nothing changes
		}

		_temp2++;
		_droid = iterateGroupCmd(_repairerGr,_bucket);
	}
}

/* Goes through trucks and compares target */
function DROID getTruckByTarget(BASEOBJ _target)
{
	local 	DROID 	_droid;
	local	int 	_bucket;

	_bucket = initIterateGroupCmd(buildGr,true,false,true);
	_droid = iterateGroupCmd(buildGr,_bucket);
	while(_droid != NULLOBJECT)
	{
		if(_droid.target == _target)
			return _droid;

		_droid = iterateGroupCmd(buildGr,_bucket);
	}

	return NULLOBJECT;
}

/* Number of BB templates a player is currently building */
function int numBBsInProduction(int _player)
{
	local	int			_index,_numBBsInProd;

	_index = 0;
	_numBBsInProd = 0;
	while(_index < numBBTempl)
	{
		_numBBsInProd = _numBBsInProd + numTemplatesInProduction(tmplBB[_index], _player);
		_index++;
	}

	return _numBBsInProd;
}

function int numBuildersInProduction(int _player)
{
	local	int			_index,_numBuildersInProd;

	/* Trucks */
	_index = 0;
	_numBuildersInProd = 0;
	while(_index < numTruckTmpl)
	{
		_numBuildersInProd = _numBuildersInProd +
			numTemplatesInProduction(truck[_index], _player);

		_index++;
	}

	/* Cyborg Engineers */
	_numBuildersInProd = _numBuildersInProd +
		numTemplatesInProduction(cybEngineer,me);	//engineers

	return _numBuildersInProd;
}

function int numCommandersInProduction()
{
	local	int			_index,_numCmdsInProd;

	_index = 0;
	_numCmdsInProd = 0;
	while(_index < numCmdTmpl)
	{
		_numCmdsInProd = _numCmdsInProd + numTemplatesInProduction(tmplCmd[_index], me);
		_index++;
	}

	return _numCmdsInProd;
}

function bool needStartupScouts()
{
	if(GAME_TIME_IN_SECS > SCOUT_BUILD_TIME){
		return false;
	}

	if(groupSizeCmds(enemyScoutGr,true,false,true) == 0){
		return true;
	}

	if(groupSizeCmds(scoutGr,true,false,true) == 0){
		return true;
	}

	return false;
}

function bool canBuildTanks()
{
	// make sure we didn't build too many units already
	if(getDroidCount(me) >= unitLimit){
		return false;
	}

	// make sure we won't use too much of the startup power for tanks
	if(!needStartupScouts() or			//ensure have scouts
	   ((GAME_TIME_IN_SECS > MIN_DELAY_INITIAL_TANKS) and		//waited min time delay
	   (GAME_TIME_IN_SECS > MAX_DELAY_INITIAL_TANKS or numBuildingDefenses() < 3)))	//if can use power now (ie not building many defenses) or had enough time to build defenses
	{
		return true;
	}

	return false;
}

function void buildTanks()
{
	local	int			_numTotalCommanders,_index,_numNeedCmds,
						_result,_result2,_facNum,_tmplGroup,_numDroidsNoCmd,
						_needTotalRepairers,_minUnassignedDroids,_needBBs;
	local	bool		_bStartedBuild;
	local	STRUCTURE	_factory;

	//dbg(" " & me & ")  Executing buildTanks()");

	_facNum = 0;

	/* decide if want to use heavy templates */
	_tmplGroup = 0;
	// TODO: fix heavy templates
	// if((playerPower(me) > muchoPower) and !defending())
	// {
		// _tmplGroup = 1;
	// }

	//Calculate how many commanders we have and how many are being built
	_numTotalCommanders = getNumCommanders() + numCommandersInProduction();

	// calc how many repairers we still need
	_needTotalRepairers = numNeedRepairers();


	initEnumStruct(FALSE,fac,me,me);
	_factory = enumStruct();
	while(_factory != NULLOBJECT)
	{
		if(structureComplete(_factory))
		{
			_facNum = _facNum + 1;		//'id' of fac

			if(structureIdle(_factory))
			{
				_bStartedBuild = FALSE;

				/* Build commanders */
				if(!_bStartedBuild and bCanUseCommanders and
						(_numTotalCommanders < MAX_COMMANDERS))
				{
					// if( !defending() )
					// {
						/* Calculate how many commanders we need */
						_numDroidsNoCmd = max(0, totalWeapUnits() - getTotalCmdsCapacity(NULLOBJECT, true));	//num of droids without commander or 0

						// droids need a new commander if there are more than _minUnassignedDroids of them
						_minUnassignedDroids = 4;
						if( defending() ){
							_minUnassignedDroids = CMD_INIT_CAPACITY;
						}

						// calculate how many commanders we need
						_numNeedCmds = (_numDroidsNoCmd + CMD_INIT_CAPACITY - _minUnassignedDroids) / CMD_INIT_CAPACITY;

						//if some droids left without commanders (droid need a new commander if there are more than (CMD_INIT_CAPACITY / 2) of them)
						// if( modulo( max(0, _numDroidsNoCmd - (CMD_INIT_CAPACITY / 2)) , CMD_INIT_CAPACITY) > 0 )
						// {
							// _numNeedCmds++;
						// }

						dbg("need " & _numNeedCmds & " commanders for " & _numDroidsNoCmd & " droids", me);

						if((_numNeedCmds > 0) and ( (_numTotalCommanders + _numNeedCmds) < MAX_COMMANDERS))
						{
							//Find best commander template
							_result2 = 0;
							_result = numCmdTmpl;
							while((_result > 0) and (_result2 == 0))
							{
								_result--;
								if(skCanBuildTemplate(me,_factory, tmplCmd[_result]))
								{
									tmplOK[_result2] = tmplCmd[_result];
									_result2++;
								}
							}

							if(_result2 > 0)		//found a template to build
							{
								_bStartedBuild = TRUE;
								buildDroid(tmplOK[0], _factory, me, 1);
								_numTotalCommanders++;
							}
						}
					// }
				}

				//Build BBs
				//------------------
				if(!_bStartedBuild and haveBB and (groupSizeCmds(defendGr,true,false,true) >= (numDefenders + 4)))		//BB researched and not low on tanks
				{
					if(!lowMilitary and !alert and !defending())
					{
						_result = numBBsInProduction(me);	//how many already building
						if(_result < 1)		//not too many already
						{
							_result = _result + numDroidsByComponent(weaponBB, me, me);	//num BBs

							_needBBs = min(numBB, _result - numAvailableAttackers() / 9);	//1 bb for 9 droids

							//if(_result < numBB)	//not too many
							if(_needBBs > 0)	//not too many
							{
								//Find best BB template
								_result2 = 0;
								_result = numBBTempl;
								while((_result > 0) and (_result2 == 0))
								{
									_result--;
									if(skCanBuildTemplate(me, _factory, tmplBB[_result]))
									{
										tmplOK[_result2] = tmplBB[_result];
										_result2++;
									}
								}

								if(_result2 > 0)		//found a template to build
								{
									_bStartedBuild = TRUE;
									buildDroid(tmplOK[0], _factory, me, 1);
								}

							}
						}
					}
				}

				//Build repair units for defenders and commanders
				//--------------------------------------------------------
				if(!_bStartedBuild and playerPower(me) >= highPower)	//don't build expensive repairs if low on power
				{
					// make facs pump tanks to prevent rush at the beginning of the game
					if(!legoPhase())
					{
						// if need repairers,  build one at a time
						if((_needTotalRepairers > 0) and (numNonCybRepairsInProd() == 0))
						{
							_result = numRepairTmpl - 1;
							while(!_bStartedBuild and (_result >= 0))
							{
								if(skCanBuildTemplate(me, _factory, tmplRep[_result]))
								{
									_bStartedBuild = true;
									_needTotalRepairers--;
									buildDroid(tmplRep[_result], _factory, me, 1);
								}
								_result--;
							}
						}
					}
				}


				//Build attack units
				//--------------------
				if(not _bStartedBuild)		//didn't start building BB or repair unit
				{
					//Find best available templates
					_result = numTemplates[_tmplGroup];
					_result2 = 0;
					while((_result > 0) and (_result2 < MAX_CHOICE_DROIDS))
					{
						_result = _result - 1;
						if(skCanBuildTemplate(me,_factory, tmpl[_tmplGroup][_result]))
						{
							tmplOK[_result2] = tmpl[_tmplGroup][_result];
							_result2 = _result2 + 1;
						}
					}

					if(_result2 > 0)		//found a template to build
					{
						_bStartedBuild = TRUE;
						buildDroid(tmplOK[random(_result2)], _factory, me, 1);

						//if((alert) and (not lowMilitary))
						//{
						//	if(
						//	numTemplatesInProduction(truck,me);
						//}
					}
				}
			}

			/* build tanks only in first 3 factories (-trucks) if alert of non-military type */
			if(( (_facNum - numBuildersInProduction(me)) >= 3) and
				(alert and (not lowMilitary)))
			{
				exit;
			}
		}
		_factory = enumStruct();
	}

	// Build cyborg mechanicsif we are still low on repairers
	initEnumStruct(false,cybfac,me,me);
	_factory = enumStruct();
	while((_factory != NULLOBJECT) and (_needTotalRepairers > 0))
	{
		if(structureComplete(_factory))
		{
			if(structureIdle(_factory))
			{
				//Try to build a mechanic
				if( skCanBuildTemplate(me,_factory, cybMechanic) )
				{
					buildDroid(cybMechanic, _factory, me, 1);
					_needTotalRepairers++;
				}
			}
		}
		_factory = enumStruct();
	}

	//dbg(" " & me & ")  End buildTanks()");
}

// calculate how many repairers we still need
function int numNeedRepairers()
{
	local		int		_needCmdRepairers,_numDefendRepairers,_needDefendRepairers,
						_numRepInProd,_needTotalRepairers;


	_needCmdRepairers = 0;
	if(bCanUseCommanders){
		_needCmdRepairers = numMissingCmdRepairers(-1, false);
	}

	_numDefendRepairers = groupSizeCmds(defendRepairGr,true,false,true);

	//1 rep for 4 defenders, cap at "maxDefendRepairers"
	_needDefendRepairers = min(maxDefendRepairers,
		(groupSizeCmds(defendGr,true,false,false) / NUM_DEFENDERS_PER_REPAIRER)
		- _numDefendRepairers);

	if(_needDefendRepairers < 0){
		_needDefendRepairers = 0;
	}

	_numRepInProd = totalRepairersInProduction();

	// calc how many we still need
	_needTotalRepairers = _needCmdRepairers + _needDefendRepairers - _numRepInProd;

	return _needTotalRepairers;
}

function void buildVTOLs()
{
	if(getDroidCount(me) >= unitLimit)
	{
		exit;}

	count = 0;

	/* decide if want to use heavy templates */
	count3 = 0;
	//if((playerPower(me) > muchoPower) and (state != stDefending))
	//{
	//	count3 = 1;
	//}

	initEnumStruct(FALSE,vtolfac,me,me);
	structure = enumStruct();
	while(structure != NULLOBJECT)
	{
		if(structureComplete(structure))
		{
			count = count + 1;		//'id' of fac

			if(structureIdle(structure))
			{

				//Build attack units
				//-------------------
				//if(not bResult)		//didn't start building BB or repair unit
				//{
					//Find best available templates
					result = numVtolTemplates;
					result2 = 0;
					while((result > 0) and (result2 < 2))	//2 best tmplates
					{
						result = result - 1;
						if(skCanBuildTemplate(me,structure, vtoltmpl[count3][result]))
						{
							tmplOK[result2] = vtoltmpl[count3][result];
							result2 = result2 + 1;
						}
					}

					if(result2 > 0)		//found a template to build
					{
						buildDroid(tmplOK[random(result2)], structure, me, 1);
					}
				//}
			}

			/* build vtols only in first 3 factories, if alert of non-military type */
			if((count >= 3) and (alert and (not lowMilitary)))
			{
				exit;
			}
		}
		structure = enumStruct();
	}
}


//
//
//

function int totalRepairersInProduction()
{
	local	int		_numRepairers;

	// total repairs
	_numRepairers = numNonCybRepairsInProd() + numCybRepairsInProd();

	return _numRepairers;
}

function int numCybRepairsInProd()
{
	local	int		_numRepairers;

	_numRepairers = 0;

	// cyborg mechanics
	_numRepairers = numTemplatesInProduction(cybMechanic,me);	//mechanics

	return _numRepairers;
}

function int numNonCybRepairsInProd()
{
	local	int		_repTmplIndex,_numRepairers;

	_numRepairers = 0;
	_repTmplIndex = 0;

	// wheeled, tracked repairs
	while(_repTmplIndex < numRepairTmpl)
	{
		_numRepairers = _numRepairers + numTemplatesInProduction(tmplRep[_repTmplIndex],me);
		_repTmplIndex++;
	}

	return _numRepairers;
}

//how many trucks are building defenses
function int numBuildingDefenses()
{
	//return	- number of busy trucks

	temp2 = 0;		//How many are ordered to build a defense
	temp = 0;
	while(temp < numDef)
	{
		if(isStructureAvailable(def[temp],me))
		{
			temp3 = numStatBusy(def[temp], TRUE);	//How many going to build it
			temp2 = temp2 + temp3;
		}

		temp = temp + 1;
	}

	return(temp2);
}

function int numBuildingBaseDefenses()
{
	local	int 	_bucket;

	//return	- number of busy trucks

	temp2 = 0;		//How many are ordered to build a defense
	temp = 0;
	while(temp < numDef)
	{
		if(isStructureAvailable(def[temp],me))
		{
			temp3 = 0;
			_bucket = initIterateGroupCmd(buildGr,true,false,true);
			tempDroid = iterateGroupCmd(buildGr,_bucket);
			while(tempDroid != NULLOBJECT)
			{
				if(tempDroid.order == DORDER_BUILD)
				{
					if(tempDroid.stat == def[temp])	//going to build it
					{
						if(distBetweenTwoPoints(tempDroid.orderx, tempDroid.ordery, baseX, baseY) <= (baseRange + defendCorridor))	//within base
						{
							temp3 = temp3 + 1;
						}
					}
				}
				tempDroid = iterateGroupCmd(buildGr,_bucket);
			}


			temp2 = temp2 + temp3;
		}

		temp = temp + 1;
	}

	return(temp2);
}

function int numBuildingNoBaseDefenses()
{
	local	int 	_bucket,_numBuildingDef,_defTypeIndex,_nonBaseDef;
	local	DROID	_truck;

	//return	- number of busy trucks

	_numBuildingDef = 0;		//How many are ordered to build a defense
	_defTypeIndex = 0;
	while(_defTypeIndex < numDef)
	{
		if(isStructureAvailable(def[_defTypeIndex],me))
		{
			_nonBaseDef = 0;
			_bucket = initIterateGroupCmd(buildGr,true,false,true);
			_truck = iterateGroupCmd(buildGr,_bucket);
			while(_truck != NULLOBJECT)
			{
				if(_truck.order == DORDER_BUILD)
				{
					if(_truck.stat == def[_defTypeIndex])	//going to build it
					{
						if(distBetweenTwoPoints(_truck.orderx, _truck.ordery, baseX, baseY) > (baseRange + defendCorridor))	//not within base
						{
							_nonBaseDef++;
						}
					}
				}
				_truck = iterateGroupCmd(buildGr,_bucket);
			}


			_numBuildingDef = _numBuildingDef + _nonBaseDef;
		}

		_defTypeIndex++;
	}

	return(_numBuildingDef);
}

function DROID closestIdleTruck(int _x, int _y)
{
	local DROID _closestTruck,_tempTruck;
	local int 	_closestDist,_tempDist,_bucket;

	_closestTruck = NULLOBJECT;
	_closestDist = 99999;

	_bucket = initIterateGroupCmd(buildGr,true,false,true);
	_tempTruck = iterateGroupCmd(buildGr,_bucket);
	while(_tempTruck != NULLOBJECT)
	{
		if(droidOrderIdle(_tempTruck))
		{
			_tempDist = distBetweenTwoPoints(_x, _y, _tempTruck.x, _tempTruck.y);
			if(_tempDist < _closestDist)
			{
				_closestDist = _tempDist;
				_closestTruck = _tempTruck;
			}
		}
		_tempTruck = iterateGroupCmd(buildGr,_bucket);
	}

	return _closestTruck;
}

//------------------------------------------------
//Build some defenses on startup to prevent rushes
//------------------------------------------------
function void buildInitialDefenses(bool _bForceBuild)	//returns TRUE if finished
{
	//_bForceBuild - if returned from callback, truck order is not reste to DORDER_NONE yet, but it's idle

	if(not bLearn){return;}		//only uses learn data so far
	if(defending()){return;}		//don't waste power

	/* if no builder, find one */
	if(initialDefensesTruck == NULLOBJECT)
	{
		if(groupSizeCmds(buildGr,true,false,true) >= 5)	//don't take away any trucks if low on them
		{
			initialDefensesTruck = closestIdleTruck(baseX, baseY);
		}
	}

	if(initialDefensesTruck == NULLOBJECT)
	{
		//dbg("buildInitialDefenses() - no truck", me);
		return;		//try again later
	}

	if((initialDefensesTruck.order != DORDER_NONE) and (not _bForceBuild))
	{
		//dbg("buildInitialDefenses() - truck busy", me);
		return;		//try again later
	}

	range = BASE_DEFENSES_RANGE;		//"too-many-built-in-range" range
	best = none;		//Best defense

	/* find best defense */
	best = findBestDefense();
	if(best == none){return;}	//No defenses researched

	//Now iterate through the stored locations
	//----------------------------------------
	result2 = getBaseDefendLocCount();		//how many locations there are stored (max)

	while(curInitialBaseDef <= maxInitialBaseDef)
	{
		count = 0;	//start from the first stored location again

		while((count < result2) and (count < maxInitialDefSites))		//don't build at more than maxInitialDefSites in total
		{
			if(recallBaseDefendLoc(me, count, ref x, ref y, ref result3))	//TRUE if stored
			{
				if(result3 > 0)		//attacked atleast 1 time (highest priority is always at the top)
				{
					//move coords closer to base
					circlePerimPoint(baseX, baseY, ref  x, ref y, (baseRange + defendCorridor / 2));	//move locations to the base perimeter

					buildX = x;	//remember coords before using pickStructLocation() to check if corrected coords too far away
					buildY = y;

					//count if not too many built on this site already (using corrected coords!)
					if(numFriendlyWeapStructsInRange(me, buildX, buildY, range, false) < curInitialBaseDef)	//don't build too many
					{
						if(pickStructLocation(def[best], ref buildX, ref buildY, me))
						{
							//don't allow to build outside of the range
							if(distBetweenTwoPoints(buildX, buildY, x, y) < range)		//coords corrected with pickStructLocation() not too far away from orig
							{
								orderDroidStatsLoc(initialDefensesTruck, DORDER_BUILD, def[best], buildX, buildY);

								//dbg("buildInitialDefenses() - started", me);

								return;	/* this one successfull, try again next time */
							}
						}
					}
				}
			}
			count = count + 1;
		}
		curInitialBaseDef = curInitialBaseDef + 1;	/* finished this round, rise defenses number per site and start over again if not finished */
		dbg("buildInitialDefenses() - RAISED curInitialBaseDef", me);
	}


	//stopInitialDefenses();
	return;
}

function void stopInitialDefenses()
{
	/* finished for real: no open sites with no defenses left, stop the whole process */
	initialDefensesFinished = true;
	dbg("buildInitialDefenses() - FINISHED", me);

	/* add builder back to the buildGr if finished */
	if(initialDefensesTruck != NULLOBJECT)
	{
		dbg("buildInitialDefenses() - ADDED BACK THE TRUCK", me);
		groupAddDroid(buildGr, initialDefensesTruck);
		initialDefensesTruck = NULLOBJECT;
	}
}

function void buildBaseDefenses()
{
	local bool _buildStarted;

	//dbg(" " & me & ")  buildBaseDefenses()");

	if(not bLearn){exit;}
	if(idleGroupCmd(buildGr,true,false) == 0){exit;}

	//MsgBox("buildBaseDefenses()");

	best = none;		//Best defense

	//How many are ordered to build a defense?
	result = numBuildingBaseDefenses();
	if(result >= maxBaseDefenseTrucks){exit;}		//Not too many busy with defenses already

	/* find best defense */
	best = findBestDefense();
	if(best == none){exit;}	//No defenses researched

	bResult = FALSE;	//started to build anything?

	//Now iterate through the stored locations
	//---------------------------------------
	result2 = getBaseDefendLocCount();		//how many locations there are stored (max)
	count = 0;

	//look at maxBaseDefenseLoc defend locs nad pick MAX_BASE_DEFENSE_LOCATIONS best ones
	count4 = 0;
	while((count < result2) and (count4 < MAX_BASE_DEFENSE_LOCATIONS) and
		(count < maxBaseDefenseLoc))
	{
		if(recallBaseDefendLoc(me, count, ref x, ref y, ref result3))	//TRUE if stored
		{
			if(result3 > MIN_BASE_RECALL_PRIORITY)	//at least priority of MIN_BASE_RECALL_PRIORITY + 1
			{
				//move coords closer to base
				circlePerimPoint(baseX, baseY, ref  x, ref y, (baseRange + defendCorridor / 2));	//move locations to the base perimeter

				buildX = x;	//remember coords before using pickStructLocation() to check if corrected coords too far away
				buildY = y;

				//count if not too many built on this site already (using corrected coords!)
				//if(numStructsByTypeInRange(me, me, REF_DEFENSE, buildX, buildY, range) < numBaseDef)	//max
				if(numFriendlyWeapStructsInRange(me, buildX, buildY, BASE_DEFENSES_RANGE, false) < numBaseDef)
				{
					if(pickStructLocation(def[best], ref buildX, ref buildY, me))
					{
						//don't allow to build outside of the range
						if(distBetweenTwoPoints(buildX, buildY, x, y) < BASE_DEFENSES_RANGE)		//coords corrected with pickStructLocation() not too far away from orig
						{
							//Make sure not too many building already
							//--------------------------------------------
							retInt = numTrucksOrderInRange(buildX, buildY, BASE_DEFENSES_RANGE, DORDER_BUILD);

							if(retInt < maxBaseDefendDefLocTrucks)
							{
								intOK[count4] = count;
								count4 = count4 + 1;		//picked another one
							}
						}
					}
				}
			}
		}
		count = count + 1;
	}

	if(count4 == 0){exit;}		//couldn't recall any locations

	//Choose a random site
	//--------------------------------------------
	result = intOK[random(count4 - 1)];

	//dbg(" " & me & ")  defendDefenses() - building defense at location #" & result & " !!!!!!!!!!!!");

	recallBaseDefendLoc(me, result, ref x, ref y, ref temp2);

	//move coords closer to base
	circlePerimPoint(baseX, baseY, ref x, ref y, (baseRange + defendCorridor / 2));

	buildX = x;	//remember coords before using pickStructLocation() to check if corrected coords too far away
	buildY = y;

	if(pickStructLocation(def[best], ref buildX, ref buildY, me))
	{
		//don't allow to build outside of the range
		if(distBetweenTwoPoints(buildX, buildY, x, y) < BASE_DEFENSES_RANGE)		//coords corrected with pickStructLocation() not too far away from orig
		{
			_buildStarted = buildUsingClosestTruck(def[best], buildX, buildY, 1);

			if(_buildStarted)
			{
				bResult = TRUE;	//Build successfull

				tLastBaseDefense = GAME_TIME_IN_SECS;

				//dbg(" " & me & ")   building on base defense location # " & result & " !!!!!");
				//if((result + count3) >= 5){exit;}		//Not too many busy with defenses already
			}
		}
	}

	//dbg(" " & me & ")  * buildBaseDefenses()");
}

function int numDefenses()
{
	retInt = 0;
	temp = 0;
	while(temp < numDef)
	{
		retInt = retInt + getNumStructures(def[temp],me);
		temp = temp + 1;
	}

	return(retInt);
}

function int numBaseDefenses()
{
	retInt = 0;
	temp = 0;
	while(temp < numDef)
	{
		initEnumStruct(FALSE,def[temp],me,me);
		tempStruct = enumStruct();
		while(tempStruct != NULLOBJECT)
		{
			if((tempStruct.x < maxx) and (tempStruct.x > minx))
			{
				if((tempStruct.y < maxy) and (tempStruct.y > miny))
				{
					retInt = retInt + 1;
				}
			}
			tempStruct = enumStruct();
		}
		temp = temp + 1;
	}

	return(retInt);
}



event objectAttacked(inactive)
{
	local	int 		_bucket;

	if(obj == NULLOBJECT){exit;}
	if(obj2 == NULLOBJECT){exit;}

	if(obj.player == obj2.player){exit;}

	attacked[obj2.player] = attacked[obj2.player] + 1;	//remember how many times attacked by him

	//check if attacked object is in the base
	//---------------------------------------

	if(distBetweenTwoPoints(baseX, baseY, obj.x, obj.y) < (baseRange + defendCorridor))	//baseRange + corridor where defenders can stay
	{
/*
		if(objectHasIndirectWeapon(obj2))
		{
			dbg("attacked by arty in the base", me);

			if(numEnemyWeapObjInRange(me, obj2.x, obj2.y, (5 * 128), FALSE) < defendGr.members)
			{
				dbg("attacking arty", me);
				orderGroupObj(defendGr, DORDER_ATTACK, obj2);
			}
		}
*/

		if(obj2.type == OBJ_DROID)				//attacker is a droid
		{
			if(!isVtol(objToDroid(obj2)))		//not vtol
			{
				if(bLearn)
				{
					storeBaseDefLocEv();
				}
			}
			else	/* check if we have to build some AAs asap */
			{
				if(knowBase[obj2.player])
				{
					exit;		//other routine does it in this case
				}

				x = obj.x;
				y = obj.y;
				range = INBASE_AA_DEF_MAX_RANGE;	//too many on spot range

				if(numAAinRange(me, me, x, y, range) >= MAX_INBASE_AA_DEF)
				{
					exit;
				}

				best = findBestAA();
				if(best == none){exit;}

				buildX = x;	buildY = y;
				/* make sure we can build and won't be built too far away from orig loc */
				if(!pickStructLocation(AA[best], ref buildX, ref buildY, me))
				{
					exit;
				}

				if(distBetweenTwoPoints(buildX, buildY, x, y) > range)	//build loc moved too far away
				{
					exit;	//original site was probably blocked, don't build too far away from orig site
				}

				dbg("building AA defense, since don't see attacker's base", me);

				/* build AA */
				buildOnMap(AA[best], buildX, buildY, 2);
			}
		}
	}
	else	//outside of the base
	{
		/* learn oil defense location */
		//result = isNearOil(obj.x, obj.y);

		if(isNearOil(obj.x, obj.y))
		{
			if(bLearn)
			{
				storeOilDefLocEv();
			}

			// decide if we have to defend oil derrick
			dealWithOilAttacked(obj.x, obj.y);
		}
	}

	/* check if we can take them down easily, even outside of the base */
	if(obj2.type == OBJ_DROID)		//attacker is a droid
	{
		if(isVtol(objToDroid(obj2)))		//vtol
		{
			exit;
		}
	}

	range = baseRange * 3 / 2;	//1.5
	if(objectHasIndirectWeapon(obj2))
	{
		range = baseRange * 2;		//can be further away
	}

	// if(distBetweenTwoPoints(baseX, baseY, obj2.x, obj2.y) < range)	//not too far
	// {
		// if(numEnemyWeapObjInRange(me, obj2.x, obj2.y, (6 * 128), false, true) < (groupSizeCmds(defendGr,true,false,true) - 1))	//safe
		// {

			// baseDefendObj = obj2;

			// /* attack with idle defenders */
			// _bucket = initIterateGroupCmd(defendGr,true,true,true);
			// droid = iterateGroupCmd(defendGr,_bucket);
			// while(droid != NULLOBJECT)
			// {
				// if((droid.order != DORDER_ATTACK) and (droid.order != DORDER_EMBARK))
				// {
					// orderDroidObj(droid, DORDER_ATTACK, baseDefendObj);	//attack enemy
				// }
				// droid = iterateGroupCmd(defendGr,_bucket);
			// }
		// }
	// }
}

event droidAttacked(inactive)
{
	if(droid.player != me)
		exit;

	/* Make defenders retreat if heavily damaged to save units */
	if(groupMember(defendGr, droid))
	{
		if(droid.health < 45)
		{
			if(distBetweenTwoPoints(baseX, baseY, droid.x, droid.y) > baseRange)
			{
				if(defendGr.health > 50)		//wouldn't make sense if all half-dead
				{
					x = droid.x;
					y = droid.y;
					circlePerimPoint(baseX, baseY, ref x, ref y, baseRange - (2 * 128));		//retreat behind defense lines
					orderDroidLoc(droid, DORDER_MOVE, x, y);
				}
			}
		}
	}
}

//-----------------------------------------------------------
//Structure attacked CALLBACK
//-----------------------------------------------------------
event structureAttacked(inactive)
{
	local	int		_maxRepairers;
	local	DROID	_truck;
	local	bool	_bOK;

	if(structure != NULLOBJECT)
	{
		/* recycle structure if will be dead with the next shot anyway */
		if(lowOnPower() and (structure.health <= structNoLiveHealth))		//Doesn't make sense if we've got alot of power though
		{
			/* See if any track is working on this structure */
			_truck = getTruckByTarget(structure);
			if(_truck != NULLOBJECT)
			{
				/* Order to recycle */
				dbg("demolishing structure", me);
				orderDroidObj(_truck, DORDER_DEMOLISH, structure);
			}
		}
		else
		{
			/* Repair damaged structure */
			_maxRepairers = 1;

			//close to base?
			if(distBetweenTwoPoints(baseX, baseY, structure.x, structure.y) < (baseRange + (8 * 128)))
			{
				bResult = TRUE;

				_maxRepairers = 2;	//use more trucks for base structures
			}

			if(not((not bResult) and (alert)))	//don't repair if low on power and not a base structure
			{
				retInt = repairStructure(structure, _maxRepairers);
			}
		}
	}
}

/* returns TRUE if we don't have much spare ower */
function bool lowOnPower()
{
	if(playerPower(me) < highPower)
		return TRUE;

	return FALSE;
}

//---------------------------------------------------------
//	Returns true if location is near a derrick or oil resource
//---------------------------------------------------------
function bool isNearOil(int _x, int _y)
{
	local	int			_range;
	local	STRUCTURE	_derrick;
	local	FEATURE		_oil;

	_range = (6 * 128);		//near oil range

	// check derricks
	initEnumStruct(false,derrick,me,me);
	_derrick = enumStruct();
	while(_derrick != NULLOBJECT)
	{
		if(distBetweenTwoPoints(_x, _y, _derrick.x, _derrick.y) < _range)		//close to a derrick
		{
			return true;
		}

		_derrick = enumStruct();
	}

	// check oil resources
	initGetFeature(oilRes,me,me);
	_oil = getFeatureB(me);
	while(_oil != NULLOBJECT)
	{
		if(distBetweenTwoPoints(_x, _y, _oil.x, _oil.y) < _range)		//close to a derrick
		{
			return true;
		}
		_oil = getFeatureB(me);
	}

	return false;
}

//-----------------------------------------------------------
//Check all damaged structures and repair them
//-----------------------------------------------------------
function void repairStructures()
{
	if(idleGroupCmd(buildGr,true,false) == 0)
		exit;

	//How many already repairing
	result = numTrucksSameOrder(DORDER_REPAIR);

	result3 = 5;		//max repairers

	if(result >= result3)
		exit;


	structure2 = NULLOBJECT;
	range = 90;			//repair if below

	//check base structures first
	//----------------------------
	count = 0;
	while(count < numBaseStructs)
	{
		initEnumStruct(FALSE,baseStructs[count],me,me);
		structure = enumStruct();
		while(structure != NULLOBJECT)
		{
			if(structure.health < range)
			{
				result2 = repairStructure(structure, 3);	//use 3 trucks max

				result = result + result2;		//one more busy?

				if(result >= result3){exit;}		//exit if too many busy
			}
			structure = enumStruct();
		}
		count = count + 1;
	}

	//now check all other structures
	//---------------------------------
	initEnumStruct(TRUE,fac,me,me);
	structure = enumStruct();
	while(structure != NULLOBJECT)
	{
		if(structure.health < range)
		{
			result2 = repairStructure(structure, 1);	//use 1 truck max

			result = result + result2;		//one more busy?

			if(result >= result3){exit;}		//exit if too many busy
		}
		structure = enumStruct();
	}
}

function int repairStructure(STRUCTURE _damagedStruct, int _maxRepairers)
{
	//Make sure not too many repairing already
	//----------------------------------------
	temp2 = numTrucksSameOrderLoc(_damagedStruct.x, _damagedStruct.y, DORDER_REPAIR);

	if(temp2 < _maxRepairers)	//not too many already
	{
		//Find closest idle truck
		//---------------------------------------
		tempDroid = closestIdleTruck(_damagedStruct.x, _damagedStruct.y);

		if(tempDroid != NULLOBJECT)
		{
			if(distBetweenTwoPoints(tempDroid.x, tempDroid.y, _damagedStruct.x, _damagedStruct.y) < (25 * 128))	//not too far
			{
				//don't repair if outside of the base and dangerous
				if(not((not isInMyBase(_damagedStruct.x, _damagedStruct.y)) and (threatInRange(me, _damagedStruct.x, _damagedStruct.y, threatRange, FALSE)) ) )
				{
					orderDroidObj(tempDroid, DORDER_REPAIR, _damagedStruct);
					return(1);
				}
			}
		}
	}

	return(0);
}

//
//	Scout
//
event doScout(inactive)
{
	local	int 	_bucket;

	//dbg(" " & me & ")  doScout()");
	if(idleGroupCmd(scoutGr,true,true) == 0){exit;}

	_bucket = initIterateGroupCmd(scoutGr,true,true,false);				// find all units in scout group.
	droid = iterateGroupCmd(scoutGr,_bucket);
	while(droid != NULLOBJECT)
	{
		//dbg(" " & me & ")  doScout() - droid.orderx: " & droid.orderx & ", droid.ordery: " & droid.ordery);

		if( (distBetweenTwoPoints(droid.x, droid.y, droid.orderx, droid.ordery) < 384) or (scoutX <= 0) or droidOrderIdle(droid) )	//Some of them reached destination or first time
		{
			//dbg(" " & me & ")  doScout() - setting new scouting destination (**********)");

			//find next closest unrevealed tile (into buildX and buildY)
			//bResult = fogTileInRange(ref buildX, ref buildY, droid.x, droid.y, baseX, baseY, scoutRange, me);
			bResult = fogTileInRange(ref buildX, ref buildY, droid.x, droid.y, baseX, baseY, -1, me, threatRange);

			//bResult = fogTileInRange(ref buildX, ref buildY, 33, 44, 55, 66, 77, 88);


			if(not bResult)
			{
				//dbg(" " & me & ")  doScout() - failed to find scout loc (**********)");

				//scoutRange = scoutRange + scoutStep;	//and try next time

				//see if whole map revealed
				//if( ((scoutRange / 128) > mapWidth) and ((scoutRange / 128) > mapHeight))
				//{
					dbg("doScout() - STOP SCOUTING, MAP REVEALED (!!!!!!!!!!!!!)", me);

					//fMapRevealFactor = MAP_REVEAL_FAC_UBOUND;

					groupAddGroupCmd(defendGr, scoutGr);
					setEventTrigger(doScout, inactive);	//stop scouting
				//}
			}
			else
			{
				//dbg(" " & me & ")  doScout() x: " & (droid.x/128) & ", y: " & (droid.x/128) & "newx: " & (buildX/128) & "newy :" & (buildY/128));

				scoutX = buildX;
				scoutY = buildY;

				orderDroidLoc(droid, DORDER_MOVE, scoutX, scoutY);
			}
		}

		droid = iterateGroupCmd(scoutGr,_bucket);
	}

	//dbg(" " & me & ")  * doScout()");
}

event scoutForEnemy(inactive)
{
	local	int 	_bucket;

	//dbg(" " & me & ")  scoutForEnemy()");

	// only scout if the group is full, otherwise will lose units too quickly
/* 	if(groupSizeCmds(enemyScoutGr,true,false,true) < maxEnemyScouts){
		exit;
	} */

	bResult = FALSE;	//no idle scouts

	// most of the group is idle
	if(idleGroupCmd(enemyScoutGr,true,false) > (groupSizeCmds(enemyScoutGr,true,false,true)) / 2){
		bResult = TRUE;
	}

	// see if reached destination already
	if(!bResult){

		// count how many scouts have reached destination points
		_bucket = initIterateGroupCmd(enemyScoutGr,true,true,false);	// find all units in group
		droid = iterateGroupCmd(enemyScoutGr,_bucket);
		while(droid != NULLOBJECT)
		{
			if((distBetweenTwoPoints(droid.x, droid.y, droid.orderx, droid.ordery) < 384))	//Some of them reached destination
			{
				//dbg(" " & me & ")  scout reached");
				bResult = TRUE;
			}
			droid = iterateGroupCmd(enemyScoutGr,_bucket);
		}
	}

	if(not bResult){exit;}


	if((enemyScoutX > 0) and (enemyScoutY > 0))
	{
		//find a valid spot we can send droid to
		//bResult = fogTileInRange(ref x, ref y, enemyScoutX, enemyScoutY, enemyScoutX, enemyScoutY, -1, me);
		bResult = chooseValidLoc(ref realEnemyScoutX, ref realEnemyScoutY,
					enemyScoutX, enemyScoutY, me, (11 * 128));

		if(not bResult)
		{
			dbg("couldn't send enemy scouts to " & enemyScoutX & ", " & enemyScoutY, me);
			minEnemyScouts = 0;
			maxEnemyScouts = 0;
			numEnemyScouts = 0;
			realEnemyScoutX = 0;
			realEnemyScoutY = 0;

			//fMapRevealFactor = MAP_REVEAL_FAC_UBOUND;

			groupAddGroupCmd(defendGr, enemyScoutGr);
			setEventTrigger(scoutForEnemy, inactive);	//deactivate
		}
		else
		{
			orderGroupLocCmd(enemyScoutGr, DORDER_MOVE, realEnemyScoutX, realEnemyScoutY);
			//dbg(" " & me & ")  sending enemy scout to: " & x & ", " & y);
		}

	}
	else
	{
		dbg("scoutForEnemy() - no valid coords", me);
		//exit;
	}

	//find coords for the next time
	//--------------------------------------
	count = 0;		//times tried

	if((enemyScoutX > 0) and (enemyScoutY > 0))
	{
		realEnemyScoutX = enemyScoutX;
		realEnemyScoutY = enemyScoutY;
	}
	else
	{
		realEnemyScoutX = baseX;
		realEnemyScoutY = baseY;
	}

	bResult = TRUE;		//revealed
	while(bResult and (count < 200))		//until finds a not revealed loc
	{
		getNextScoutCoord(realEnemyScoutX, realEnemyScoutY);	//Sets enemyScoutX and Y vars
		realEnemyScoutX = enemyScoutX;
		realEnemyScoutY = enemyScoutY;

		// only go there if not already revealed and no threat around
		bResult = mapRevealedInRange(realEnemyScoutX, realEnemyScoutY,
										enemyScoutRange, me) or	//check if has already visited this area
					threatInRange(me, realEnemyScoutX, realEnemyScoutY, (TILE * 10), FALSE);

		count = count + 1;
	}

	if(bResult)		//no new coords found
	{
		dbg("couldn't find next spot after: " & enemyScoutX & ", " & enemyScoutY, me);
		minEnemyScouts = 0;
		maxEnemyScouts = 0;
		numEnemyScouts = 0;
		groupAddGroupCmd(defendGr, enemyScoutGr);
		setEventTrigger(scoutForEnemy, inactive);		//deactivate
	}
	//else
	//{
	//	dbg(" " & me & ")  found new enemy scout coords");
	//}
}

function void getNextScoutCoord(int _lastX, int _lastY)
{
	temp = (9 * 128);		//border offset

	tempX = _lastX;
	tempY = _lastY;

	if(bEnemyScoutHor)		//horizontal - main direction
	{
		if(bEnemyScoutToRight)
		{
			tempX = tempX + enemyScoutStep;

			//check if unit too close to hor edge already
			if(tempX > ((mapWidth * 128) - temp))		//too close to edge
			{
				//dbg(" " & me & ")  ----reached right edge");

				tempX = ((mapWidth * 128) - temp);
				bEnemyScoutToRight = FALSE;

				//have to skip a vert line now

				if(not bEnemyScoutToBottom)	//going to top
				{
					tempY = tempY - enemyScoutStep;

					//check vertical edge now
					if(tempY < temp)	//reached top
					{
						//dbg(" " & me & ")  ----reached top edge");
						tempY = temp;
						bEnemyScoutToBottom = TRUE;
					}
				}
				else		//going to bottom
				{
					tempY = tempY + enemyScoutStep;
					//check vertical edge now
					if(tempY > ((mapHeight * 128) - temp))	//reached bottom
					{
						//dbg(" " & me & ")  ----reached bottom edge");
						tempY = ((mapHeight * 128) - temp);
						bEnemyScoutToBottom = FALSE;
					}
				}
			}


		}
		else		//to left
		{
			tempX = tempX - enemyScoutStep;

			//check if unit too close to hor edge already
			if(tempX < temp)		//too close to edge
			{
				//dbg(" " & me & ")  ----reached left edge");
				tempX = temp;
				bEnemyScoutToRight = TRUE;	//change dir next time

				//have to skip a vert line now

				if(not bEnemyScoutToBottom)	//going to top
				{
					tempY = tempY - enemyScoutStep;

					//check vertical edge now
					if(tempY < temp)	//reached top
					{
						//dbg(" " & me & ")  ----reached top edge");
						tempY = temp;
						bEnemyScoutToBottom = TRUE;
					}
				}
				else				//going to bottom
				{
					tempY = tempY + enemyScoutStep;
					//check vertical edge now
					if(tempY > ((mapHeight * 128) - temp))	//reached bottom
					{
						//dbg(" " & me & ")  ----reached bottom edge");
						tempY = (mapHeight * 128) - temp;
						bEnemyScoutToBottom = FALSE;
					}
				}
			}
		}
	}
	else	//main dir = vert
	{
		if(bEnemyScoutToBottom)
		{
			tempY = tempY + enemyScoutStep;

			//check if unit too close to ver edge already
			if(tempY > ((mapHeight * 128) - temp))		//too close to edge
			{
				//dbg(" " & me & ")  ----reached bottom edge");
				tempY = (mapHeight * 128) - temp;
				bEnemyScoutToBottom = FALSE;		//change dir

				//have to skip a hor line now

				if(not bEnemyScoutToRight)	//going left
				{
					tempX = tempX - enemyScoutStep;

					//check hor edge now
					if(tempX < temp)	//reached left
					{
						//dbg(" " & me & ")  ----reached left edge");
						tempX = temp;
						bEnemyScoutToRight = TRUE;
					}
				}
				else	//to right
				{
					tempX = tempX + enemyScoutStep;
					//check hor edge now
					if(tempX > ((mapWidth * 128) - temp))	//reached right
					{
						//dbg(" " & me & ")  ----reached right edge");
						tempX = (mapWidth * 128) - temp;
						bEnemyScoutToRight = FALSE;
					}
				}
			}


		}
		else		//to top
		{
			tempY = tempY - enemyScoutStep;

			//check if unit too close to ver edge already
			if(tempY < temp)		//too close to edge
			{
				tempY = temp;
				bEnemyScoutToBottom = TRUE;		//change dir

				//have to skip a hor line now

				if(not bEnemyScoutToRight)	//going left
				{
					tempX = tempX - enemyScoutStep;

					//check hor edge now
					if(tempX < temp)	//reached left
					{
						//dbg(" " & me & ")  ----reached left edge");
						tempX = temp;
						bEnemyScoutToRight = TRUE;
					}
				}
				else	//to right
				{
					tempX = tempX + enemyScoutStep;
					//check hor edge now
					if(tempX > ((mapWidth * 128) - temp))	//reached right
					{
						//dbg(" " & me & ")  ----reached right edge");
						tempX = (mapWidth * 128) - temp;
						bEnemyScoutToRight = FALSE;
					}
				}
			}
		}
	}

	enemyScoutX = tempX;
	enemyScoutY = tempY;
}

//---------------------------------------------------------------
//	Returns closest corner based on arguments
//---------------------------------------------------------------
function void getClosestCorner(int _x, int _y)
{
	temp = (12 * 128);	//border offset

	//horizontal
	retInt = temp;					//left
	if(_x > ((mapWidth * 128) / 2))
	{
		retInt = (mapWidth * 128) - temp;	//right
	}


	//vertical
	retInt2 = temp;					//top
	if(_y > ((mapHeight * 128) / 2))
	{
		retInt2 = (mapHeight * 128) - temp;	//bottom
	}
}

//Calculate number of defenders to leave in the base when going out with the main force to attack stuff
function void updateNumDefenders()
{
	local	int		_attackDistance,_numActiveEnemies,_numActiveAllies,_player,
					_numBaseDefenses;
	local	float	_enemyFactor;



	/* If we are not using additional base defenders, leave minimum in the base */
	if(NO_BASE_DEFENDERS)
	{
		numDefenders = minDefenders;
		return;
	}
	else if(PROGRESSIVE_DEFENDERS)
	{
		//leave almost no defenses when the game has just started
		minDefenders = MIN_DEFENDERS;
		if(GAME_TIME_IN_SECS < (MINUTE * 12)){
			minDefenders = (MIN_DEFENDERS / (MINUTE * 12)) * GAME_TIME_IN_SECS;	//0 for 0 mins, 3 for 12 mins
		}

		// leave 9 defenders for 40 and 18 for total 80 units
		numDefenders = max(minDefenders, (int)((float)numAvailableAttackers() / 5.44));
		return;
	}

	// make sure we have all the necessary values
	if(sendForceX <= 0 or baseX <= 0){
		return;
	}

	if( !(state == stAttacking or state == stHelpingAlly) ){
		return;
	}

	//Count all our base defenses
	_numBaseDefenses = numFriendlyWeapStructsInRange(me, baseX, baseY, COUNT_BASE_OBJECTS_RANGE, true) / STR_UNIT_DEFENSE_FACTOR;

	//Count active allies and enemies
	_player = 0;
	_numActiveEnemies = 0;
	while(_player < MAX_PLAYERS)
	{
		if(_player != me)
		{
			//make sure this player is still alive
			if(not dead[_player])
			{
				//we assume that if we attack a certain enemy or help a certain ally this player doesn't count, since can't send units to our base
				if( !( (state == stAttacking or state == stHelpingAlly) and
					(_player == enemy)) )
				{
					if(not allianceExistsBetween(me, _player))
					{
						_numActiveEnemies++;
					}
					else
					{
						//Our ally can't help us if he's defending its base
						if(allyState[_player] != stDefending)
						{
							_numActiveAllies++;
						}
					}
				}
			}
		}
		_player++;
	}

	//Calculate enemy factor, depends on number of enemies and allies, allies are not that important when it comes to defending our base
	_enemyFactor = (float)_numActiveEnemies - (float)_numActiveAllies / 4.1;		//4.1, so we won't get div by 0 error

	//find out how far we are going with our main force
	_attackDistance = distBetweenTwoPoints(sendForceX, sendForceY, baseX, baseY) / TILE;


	//Calculate number of defenders to leave in the base when going out with the main force to attack stuff
	numDefenders = (int)((float)_attackDistance / ((float)UNIT_HOLD_SECS / _enemyFactor)) -
						_numBaseDefenses / STR_UNIT_DEFENSE_FACTOR;
}

function void updateMilitaryStatus()
{
	noBaseTargets = TRUE;	//reset here, set by checkBase()

	count = 0;
	while(count < multiPlayerMaxPlayers)
	{
		if(count != me)
		{
			ally[count] = FALSE;

			if(allianceExistsBetween(count ,me) )
			{
				ally[count] = TRUE;
			}

			/* check if can see any enemy object */
			//only check if not dead already, OBJ_SEEN will make him alive if it sees anything
			if(not dead[count])
			{
				/* check if dead */
				//count2 = checkPlayerDead(count);
				if(checkPlayerDead(count))
				{
					dead[count] = TRUE;

					dbg(getPlayerName(count) & " IS DEAD !!!!!!!!!!!!!!!!++++", me);

					notifyPlayerDead(count);
				}
			}

			/* find base */
			if(not dead[count])
			{
				checkBase(count);
			}
		}
		count = count + 1;
	}
}

/* Some military checks */
function void militarySelftest()
{
	if(researchFinished(resBB, me))	//BB
	{
		haveBB = TRUE;
	}

	bCanUseCommanders = canUseCommanders();

	// how much of the map do we have revealed?
/* 	if(fMapRevealFactor < MAP_REVEAL_FAC_UBOUND)
	{
		fMapRevealFactor = (MAP_REVEAL_FAC_UBOUND - MAP_REVEAL_FAC_LBOUND) /
							(MAP_REVEAL_MAX_OIL_RES - MAP_REVEAL_MIN_OIL_RES) *
							(float)numTotalOilInRange(-1,-1,-1);
		// trim
		fMapRevealFactor = fmax(MAP_REVEAL_FAC_LBOUND, fMapRevealFactor);
		fMapRevealFactor = fmin(MAP_REVEAL_FAC_UBOUND, fMapRevealFactor);
	} */
}

function void findAlternateTarget()
{
	//Only choose alternate target if already ready to attack, otherwise
	//if a real target will be found afterwards, it won't be assigned as main target
	//------------------------------------------------------------------------------

	//find any other structure left
	structure = getClosestEnemyStructByType(baseX, baseY, -1, REF_DEFENSE, me);
	if(structure == NULLOBJECT)
	{
		structure = getClosestEnemyStructByType(baseX, baseY, -1, REF_RESOURCE_EXTRACTOR, me);
	}

	//if found
	if(structure != NULLOBJECT)
	{
		//centreView(structure);

		result = structure.player;
		dbg("no valid base targets, found an alternative target for " & getPlayerName(result), me);

		seeBase[result] = TRUE;
		knowBase[result] = TRUE;

		//dead[result] = FALSE;
		//killedBase[result] = FALSE;

		curBase[result][0] = structure.x;
		curBase[result][1] = structure.y;

		if(curHelpX[result] <= 0)
		{
			curHelpX[result] = curBase[result][0];
			curHelpY[result] = curBase[result][1];
		}

		//if((base[result][0] <= 0) or (base[result][1] <= 0))
		//{
		//	base[result][0] = structure.x;
		//	base[result][1] = structure.y;
		//}

		noBaseTargets = FALSE;
	}
}

function bool canStartAttack(int _enemy)
{
	if(numAvailableAttackers() < numPlayerAttackers[_enemy])
	{
		return(FALSE);
	}

	return(TRUE);
}

//count current attackers as well
function bool canTheoreticallyStartAttack()
{
	if(numAvailableAttackers() >= numAttackers)
	{
		return(TRUE);
	}

	return(FALSE);
}

// have *any* attackers? (count current attackers as well)
function bool haveTheoretilcallyMinAttackers(bool _bSafeToSendLittleAttackers)
{
	if(_bSafeToSendLittleAttackers)		//it's ok to send little attackers, for example if joining forces with other players
	{
		if((totalWeapUnits() - minDefenders) >= minAttackers)
		{
			return TRUE;
		}
	}
	else	//too dangerous to send little attackers, wait until we get more units
	{
		if(numAvailableAttackers() >= minAttackers)
		{
			return TRUE;
		}
	}


	return FALSE;
}

/* All units - number of required defenders */
function int numAvailableAttackers()
{
	return max(totalWeapUnits() - numDefenders, 0);
}

/* Total units that can attack, including defenders */
function int totalWeapUnits()
{
	return groupSizeCmds(attackGr,true,false,true) +
		   groupSizeCmds(sendAttackGr,true,false,true) +
		   groupSizeCmds(defendGr,true,false,true);
}

//Get number of members of a group including units assigned to commanders that belong to this group too
function int groupSizeCmds(GROUP _groupToCount, bool _bIncludeUnassigned,
					bool _bIncludeCmds, bool _bInclDroidsAssignedToCmds)
{
	local	int		_index,_numDroids;
	local	bool	_bCMDsOnly;

	//_groupToCount can only be NULL if we are counting commanders only
	if((_groupToCount == NULLOBJECT) and
		(_bIncludeCmds == TRUE && _bInclDroidsAssignedToCmds == FALSE))
	{
		_bCMDsOnly = TRUE;
	}

	if(!_bCMDsOnly and _bIncludeUnassigned){
		_numDroids = _groupToCount.members;	//count droids not assigned to a comamdner
	}

	while(_index < MAX_COMMANDERS)
	{
		//make sure this commander isn't dead and belongs to the desired group
		if((cmds[_index] != NULLOBJECT) and
			((cmdGr[_index] == _groupToCount) or _bCMDsOnly) )
		{
			//Include units assigned to this commander
			if(_bInclDroidsAssignedToCmds)
			{
				if(cmds[_index].group == NULLOBJECT)
				{
					debug("commander " & _index & " group is null");
				}
				_numDroids = _numDroids + cmds[_index].group.members;	//count droids in the commander group
			}

			//Count the commander
			if(_bIncludeCmds)
			{
				_numDroids++;
			}
		}
		_index++;
	}

	return _numDroids;
}

//Order group and all commanders belonging to this group to move to some location
function void orderGroupLocCmd(GROUP _groupToOrder, int _order, int _x, int _y)
{
	local	int		_cmdIndex;

	//Order droids without commander
	orderGroupLoc(_groupToOrder, _order, _x, _y);

	//Order commanders belonging to this group
	_cmdIndex = 0;
	while(_cmdIndex < MAX_COMMANDERS)
	{
		if(cmds[_cmdIndex] != NULLOBJECT)
		{
			if(cmdGr[_cmdIndex] == _groupToOrder)
			{
				orderDroidLoc(cmds[_cmdIndex], _order, _x, _y);
			}
		}
		_cmdIndex++;
	}
}

/* Add Commander to some group */
function void groupAddCmd(GROUP _group, DROID _commander)
{
	ASSERT(_commander != NULLOBJECT,
		"groupAddCmd: commander is NULL", me);

	//set group for a commander
	cmdGr[cmdToIndex(_commander)] = _group;
}

/* Returns index of a commander */
function int cmdToIndex(DROID _commander)
{
	local int		_index;

	ASSERT(_commander != NULLOBJECT,
		"cmdToIndex: commander is NULL", me);

	_index = 0;
	while(_index< MAX_COMMANDERS)
	{
		if(_commander == cmds[_index])
		{
			return _index;
		}
		_index++;
	}

	ASSERT(_index >= 0, "cmdToIndex: couldn't find commander", me);

	return -1;	//not found
}

//Move droids and all commanders belonging to a certain group to another group
function void groupAddGroupCmd(GROUP _groupTo, GROUP _groupFrom)
{
	local	int		_cmdIndex;

	groupAddGroup(_groupTo, _groupFrom);

	//Move all commanders to a new group
	_cmdIndex = 0;
	while(_cmdIndex < MAX_COMMANDERS)
	{
		if(cmds[_cmdIndex] != NULLOBJECT)
		{
			if(cmdGr[_cmdIndex] == _groupFrom)
			{
				cmdGr[_cmdIndex] = _groupTo;
			}
		}
		_cmdIndex++;
	}
}

// Returns x coordinate of the group, takes commanders into account
function int groupCMD_x(GROUP _group)
{
	local	int		_x,_numUnits,_cmdIndex;

	_x = _group.x;
	_numUnits = _group.members;

	_cmdIndex = 0;
	while(_cmdIndex < MAX_COMMANDERS)
	{
		if(cmds[_cmdIndex] != NULLOBJECT)
		{
			if(cmdGr[_cmdIndex] == _group)
			{
				// commander unit
				_x = _x + cmds[_cmdIndex].x;
				_numUnits++;

				// count units assigned to commander
				_x = _x + cmds[_cmdIndex].group.x;
				_numUnits = _numUnits + cmds[_cmdIndex].group.members;
			}
		}
		_cmdIndex++;
	}

	if(_numUnits <= 0){
		return -1;
	}

	return (_x / _numUnits);
}

// Returns y coordinate of the group, takes commanders into account
function int groupCMD_y(GROUP _group)
{
	local	int		_y,_numUnits,_cmdIndex;

	_y = _group.y;
	_numUnits = _group.members;

	_cmdIndex = 0;
	while(_cmdIndex < MAX_COMMANDERS)
	{
		if(cmds[_cmdIndex] != NULLOBJECT)
		{
			if(cmdGr[_cmdIndex] == _group)
			{
				// commander unit
				_y = _y + cmds[_cmdIndex].y;
				_numUnits++;

				// count units assigned to commander
				_y = _y + cmds[_cmdIndex].group.y;
				_numUnits = _numUnits + cmds[_cmdIndex].group.members;
			}
		}
		_cmdIndex++;
	}

	if(_numUnits <= 0){
		return -1;
	}

	return (_y / _numUnits);
}

function int idleGroupCmd(GROUP _idleGroup, bool _bIncludeNonCmds, bool _bIncludeCmds)
{
	local	int		_cmdIndex,_numIdle;

	_numIdle = idleGroup(_idleGroup);

	// if(_bIncludeCmds)
	// {
		_cmdIndex = 0;
		while(_cmdIndex < MAX_COMMANDERS)
		{
			if(cmds[_cmdIndex] != NULLOBJECT)
			{
				if(cmdGr[_cmdIndex] == _idleGroup)
				{
					// commander
					if(_bIncludeCmds)
					{
						if((cmds[_cmdIndex].order == DORDER_NONE) ||
							(cmds[_cmdIndex].order == DORDER_GUARD and cmds[_cmdIndex].target == NULLOBJECT))
						{
							_numIdle++;
						}
					}

					// units attached to a commander
					if(_bIncludeNonCmds)
					{
						_numIdle = _numIdle + idleGroup(cmds[_cmdIndex].group);
					}
				}
			}
			_cmdIndex++;
		}
	// }

	return _numIdle;
}

//Same as initIterateGroup() but also returns commanders belonging to this group
function int initIterateGroupCmd(GROUP _groupToIterate, bool _bReturnNonCmds,
								bool _bReturnCmds, bool _bReturnCmdAssignedDroids)
{
	local	int		_cmdIndex;

/* 	dbg("initIterateGroupCmd: " & _bReturnNonCmds & "," &
		_bReturnCmds & "," & _bReturnCmdAssignedDroids , me); */

	ASSERT(_bReturnNonCmds or _bReturnCmds or _bReturnCmdAssignedDroids,
		"initIterateGroupCmd: no units to return", me);

	// make sure we start a new iteration, if we are already iterating (iteration inside iteration)
	// we assume there are MAX_GROUP_ITERATE_BUCKET iterations at most
	groupIterateBucket++;
	groupIterateBucket = modulo(groupIterateBucket, MAX_GROUP_ITERATE_BUCKET);

	//dbg("New groupIterateBucket = " & groupIterateBucket, me);

	ASSERT(groupIterateBucket < MAX_GROUP_ITERATE_BUCKET,
		"initIterateGroupCmd: can't start any more iterations (" &
		groupIterateBucket & ")", me);

	//Remember iteration settings
	groupToIterate[groupIterateBucket] = _groupToIterate;	//remember group we are iterating over
	iterateCmdGroup[groupIterateBucket] = NULLOBJECT;		//commander group we are currently iterating over
	bIterateNonCommanders[groupIterateBucket] = _bReturnNonCmds;
	bIterateCommanders[groupIterateBucket] = _bReturnCmds;
	bIterateCmdAssignedDroids[groupIterateBucket] = _bReturnCmdAssignedDroids;		//whether to iterate over the droids assigned to a commander
	iterateCommanderIndex[groupIterateBucket] = 0;	//starting with the first commander

	iterateGroupDroid[groupIterateBucket] = NULLOBJECT;

	iterateStage[groupIterateBucket] = 3;	//nothing left

	//Prepare first non-commander droid
	if(bIterateNonCommanders[groupIterateBucket])
	{
		iterateStage[groupIterateBucket] = 0;	//iterating over main group
		initIterateGroup(groupToIterate[groupIterateBucket]);
		iterateGroupDroid[groupIterateBucket] = iterateGroup(groupToIterate[groupIterateBucket]);
	}

	if(iterateGroupDroid[groupIterateBucket] == NULLOBJECT)
	{
		if(bIterateCommanders[groupIterateBucket])
		{
			iterateStage[groupIterateBucket] = 1;

			//Iterate through all commanders
			_cmdIndex = 0;
			while((_cmdIndex < MAX_COMMANDERS) and (iterateGroupDroid[groupIterateBucket] == NULLOBJECT))
			{
				if(cmds[_cmdIndex] != NULLOBJECT)
				{
					if(cmdGr[_cmdIndex] == groupToIterate[groupIterateBucket])
					{
						//return this commander
						iterateGroupDroid[groupIterateBucket] = cmds[_cmdIndex];
						iterateCommanderIndex[groupIterateBucket] = _cmdIndex + 1;	//access next commander next time
					}
				}
				_cmdIndex++;
			}
		}
	}

	if(iterateGroupDroid[groupIterateBucket] == NULLOBJECT)
	{
		if(bIterateCmdAssignedDroids[groupIterateBucket])
		{
			iterateStage[groupIterateBucket] = 2;

			//Iterate through all droids assigned to commanders
			_cmdIndex = 0;
			while((_cmdIndex < MAX_COMMANDERS) and (iterateGroupDroid[groupIterateBucket] == NULLOBJECT))
			{
				if(cmds[_cmdIndex] != NULLOBJECT)
				{
					if(cmdGr[_cmdIndex] == groupToIterate[groupIterateBucket])
					{
						//return first droid of this commander's group
						iterateCmdGroup[groupIterateBucket] = cmds[_cmdIndex].group;
						initIterateGroup(iterateCmdGroup[groupIterateBucket]);
						iterateGroupDroid[groupIterateBucket] = iterateGroup(iterateCmdGroup[groupIterateBucket]);

						iterateCommanderIndex[groupIterateBucket] = _cmdIndex;	//access this commander again next time
					}
				}
				_cmdIndex++;
			}
		}
	}

	if(iterateGroupDroid[groupIterateBucket] == NULLOBJECT)
	{
		iterateStage[groupIterateBucket] = 3;
	}

	return groupIterateBucket;
}

//Same as iterateGroup() but also returns commanders
function DROID iterateGroupCmd(GROUP _groupToIterate, int _bucket)
{
	local	DROID	_preparedDroid;
	local	int		_cmdIndex;
	local	bool	_bStop;

	// ASSERT(_bucket <= groupIterateBucket,
		// "iterateGroupCmd: wrong bucket: " & _bucket & "/" & groupIterateBucket, me);

	ASSERT(_groupToIterate == groupToIterate[_bucket],
		"iterateGroupCmd: wrong group passed", me);

	ASSERT(bIterateNonCommanders[_bucket] or bIterateCommanders[_bucket] or
		   bIterateCmdAssignedDroids[_bucket],
		"iterateGroupCmd: no units to return", me);

	// decrease bucket, since we are done now
	if(iterateStage[_bucket] == 3)
	{
		//dbg("Decreasing groupIterateBucket from " & groupIterateBucket, me);

		// ASSERT(_preparedDroid != NULLOBJECT,
			// "iterateGroupCmd: _preparedDroid is NULL, called this function after it returned NULL?", me);

		groupToIterate[_bucket] = NULLOBJECT;	// mark this iteration as finished

		// reset some values
		bIterateNonCommanders[_bucket] = false;
		bIterateCommanders[_bucket] = false;
		bIterateCmdAssignedDroids[_bucket] = false;

		// groupIterateBucket--;	// will only get once to this part, since values are reseat and checked before this place

		ASSERT(groupIterateBucket >= 0,
			"iterateGroupCmd: groupIterateBucket = " & groupIterateBucket, me);

		_preparedDroid = NULLOBJECT;

		return _preparedDroid;
	}

	//store prepared droid
	_preparedDroid = iterateGroupDroid[_bucket];
	iterateGroupDroid[_bucket] = NULLOBJECT;

	//Get next droid from the main group
	if(iterateStage[_bucket] == 0)
	{
		iterateGroupDroid[_bucket] = iterateGroup(groupToIterate[_bucket]);

		if(iterateGroupDroid[_bucket] == NULLOBJECT)
		{
			iterateStage[_bucket] = 1;
		}
	}

	if(iterateStage[_bucket] == 1)
	{
		if(bIterateCommanders[_bucket])
		{
			//Iterate through all commanders
			_cmdIndex = iterateCommanderIndex[_bucket];
			while((_cmdIndex < MAX_COMMANDERS) and (iterateGroupDroid[_bucket] == NULLOBJECT))
			{
				if(cmds[_cmdIndex] != NULLOBJECT)
				{
					if(cmdGr[_cmdIndex] == groupToIterate[_bucket])
					{
						iterateGroupDroid[_bucket] = cmds[_cmdIndex];
						iterateCommanderIndex[_bucket] = _cmdIndex + 1;	//access next commander next time
					}
				}
				_cmdIndex++;
			}

			//Check if no commanders left
			if(iterateGroupDroid[_bucket] == NULLOBJECT)
			{
				iterateStage[_bucket] = 2;
				iterateCommanderIndex[_bucket] = 0;
				iterateCmdGroup[_bucket] = NULLOBJECT;
			}
		}
		else
		{
			iterateStage[_bucket] = 2;	//start iterating droids assigned to commanders if needed
			iterateCommanderIndex[_bucket] = 0;
			iterateCmdGroup[_bucket] = NULLOBJECT;
		}
	}

	if(iterateStage[_bucket] == 2)
	{
		if(bIterateCmdAssignedDroids[_bucket])
		{
			_bStop = false;
			_cmdIndex = iterateCommanderIndex[_bucket];
			while(!_bStop and (iterateCommanderIndex[_bucket] < MAX_COMMANDERS) and (iterateGroupDroid[_bucket] == NULLOBJECT))
			{
				//Find next commander that belongs to the right group
				_cmdIndex = iterateCommanderIndex[_bucket];
				while((iterateCmdGroup[_bucket] == NULLOBJECT) and (_cmdIndex < MAX_COMMANDERS))
				{
					if(cmds[_cmdIndex] != NULLOBJECT)
					{
						if(cmdGr[_cmdIndex] == groupToIterate[_bucket])
						{
							iterateCmdGroup[_bucket] = cmds[_cmdIndex].group;
							initIterateGroup(iterateCmdGroup[_bucket]);
							iterateCommanderIndex[_bucket] = _cmdIndex;
						}
					}
					_cmdIndex++;
				}

				//Get next droid of this commander
				if(iterateCmdGroup[_bucket] != NULLOBJECT)	//any suitable commander left?
				{
					iterateGroupDroid[_bucket] = iterateGroup(iterateCmdGroup[_bucket]);

					//It was the last droid of this commander, try next commander
					if(iterateGroupDroid[_bucket] == NULLOBJECT)
					{
						iterateCmdGroup[_bucket] = NULLOBJECT;
						iterateCommanderIndex[_bucket] = iterateCommanderIndex[_bucket] + 1;

						if(iterateCommanderIndex[_bucket] >= MAX_COMMANDERS)
						{
							_bStop = true;
							iterateStage[_bucket] = 3;
						}
					}
				}
				else
				{
					_bStop = true;
					iterateStage[_bucket] = 3;
				}
			}
		}
		else
		{
			iterateStage[_bucket] = 3;
		}
	}

	return _preparedDroid;
}

//---------------------------------------------------------------
//	Check base coords are valid for a certain player
//---------------------------------------------------------------
function void checkBase(int _player)
{
	ASSERT(_player >= 0, "checkBase - _player < 0", me);

	if(knowBase[_player])
	{
		if((curBase[_player][0] <= 0) or (curBase[_player][1] <= 0))
			MsgBox("checkBase() - curBase <= 0");

		if(mapRevealedInRange(curBase[_player][0],curBase[_player][1], (2 * 128), me))		//can tell if it's empty only if visited this place (in case recalled it from memory)
		{
			if(not structInRangeVis(me, _player, curBase[_player][0], curBase[_player][1], (2 * 128)) )
			{
				//if((curBase[_player][0] == base[_player][0]) and (curBase[_player][1] == base[_player][1]))
				//{
				//	dbg(" " & me & ")  recalled location is empty for " & _player & " !!!!!!!!!!!!!!!!!!!!!!!");
				//}

				//find new base
				//temp = findBase(_player);

				if(findBase(_player))	//found new location of the base for this player
				{
					dbg("Corrected base coords for player" & _player, me);

					curBase[_player][0] = retInt;
					curBase[_player][1] = retInt2;

					if(curHelpX[_player] <= 0)
					{
						curHelpX[_player] = curBase[_player][0];
						curHelpY[_player] = curBase[_player][1];
					}

					/* update destination coords if going to this player */
					if(enemy == _player)
					{
						dbg("Enemy cords updated", me);
						sendForceX = curBase[_player][0];
						sendForceY = curBase[_player][1];
					}

					seeBase[_player] = TRUE;	//found base

					if(not ally[_player])
						noBaseTargets = FALSE;

					dbg("found a different enemy base location for " & _player, me);

					//if no real base found yet, only an alternate loc, then remember real base now
					if((base[_player][0] <= 0) or (base[_player][1] <= 0))
					{
						base[_player][0] = retInt;
						base[_player][1] = retInt2;
					}

					//learn this location
					if(bLearn)
					{
						if(not canRememberPlayerBaseLoc(me, _player))		//not already in memory
						{
							learnPlayerBaseLoc(me, _player, retInt, retInt2);
						}
					}
				}
				else	//couldn't find anything
				{
					if(_player == enemy)	//attacking this one right now
					{
						if(seeBase[_player])		//warn only once, when just lost the base
						{
							dbg("lost current enemy " & getPlayerName(_player) & " !!!!!!!!!!!!!!!!!!!!!", me);
						}

					}
					else if(seeBase[_player])	//lost it now
					{
						dbg("lost base loc for enemy " & getPlayerName(_player), me);
					}

					seeBase[_player] = FALSE;	//lost
					//knowBase[_player] = FALSE;	//disabled 15.05.05 because of phSearchingForBase was skipped because of this
				}

			}
			else		//enemy base still there
			{
				if(not allianceExistsBetween(me , _player))	//this player is not our ally
					noBaseTargets = FALSE;

				/* make sure allies see newly found enemy base */
				if(not seeBase[_player])	//just found
					refreshAllyRadar();

				seeBase[_player] = TRUE;	//can see base
			}
		}
		else	//enemy base still there (probably recalled it)
		{
			if(not ally[_player])
				noBaseTargets = FALSE;
		}
	}
	else	//don't have enemy base loc
	{
		//find new base
		//temp = findBase(_player);

		if(findBase(_player))	//found new location of the base for this player
		{
			curBase[_player][0] = retInt;
			curBase[_player][1] = retInt2;

			if(curHelpX[_player] <=0)
			{
				curHelpX[_player] = curBase[_player][0];
				curHelpY[_player] = curBase[_player][1];
			}

			knowBase[_player] = TRUE;
			seeBase[_player] = TRUE;	//found base

			if(not ally[_player])
			{
				noBaseTargets = FALSE;
			}

			dbg("found new enemy base for " & getPlayerName(_player) & " at " & (curBase[_player][0] / 128) & " - " & (curBase[_player][1] / 128) & " !!!!!!!!!", me);

			//if no real base found yet, only an alternate loc, then remember real base now
			if((base[_player][0] <= 0) or (base[_player][1] <= 0))
			{
				base[_player][0] = retInt;
				base[_player][1] = retInt2;
			}

			//learn this location
			if(bLearn)
			{
				if(not canRememberPlayerBaseLoc(me, _player))		//not already in memory
				{
					learnPlayerBaseLoc(me, _player, retInt, retInt2);
				}
			}

			refreshAllyRadar();
		}
		//else
		//{
		//	dead[_player] = TRUE;
		//}
	}
}

function bool checkPlayerDead(int _player)
{
	if(knowBase[_player] and (not seeBase[_player]))		//know location, but don't see it
	{
		if(mapRevealedInRange(curBase[_player][0],curBase[_player][1], (2 * 128), me))	//make sure can see the location where the base should be
		{
			//_temp = canSeePlayer(_player);		//can see any other objects?

			if(not canSeePlayer(_player))
			{
				return(TRUE);		//dead
			}
		}
	}

	return(FALSE);
}

function bool canSeePlayer(int _player)
{
	_bResult = FALSE;	//not found

	initEnumStruct(TRUE,wall,_player,me);
	_structure = enumStruct();
	while((_structure != NULLOBJECT) and (not _bResult))
	{
		_temp = getStructureType(_structure);
		if((_temp != 7) and (_temp != 8) and (_temp != 6) and (_temp != 6))	//wall, cornerwall, defense, rearm
		{
			_bResult = TRUE;
		}
		_structure = enumStruct();
	}

	if(not _bResult)	//no structures
	{
		InitEnumDroids(_player,me);
		_droid = EnumDroid();
		if(_droid == NULLOBJECT)
		{
			return(FALSE);
		}
	}

	return(TRUE);
}

function bool findBase(int _targetPlayer)
{
	local int _structType;

	ASSERT(_targetPlayer >= 0, "findBase - _targetPlayer < 0", me);

	_structType = 0;
	while(_structType < numBaseStructs)
	{
		tempStruct = getStructureVis(baseStructs[_structType], _targetPlayer, me);
		if(tempStruct !=NULLOBJECT)
		{
			retInt = tempStruct.x;
			retInt2 = tempStruct.y;
			return(TRUE);
		}
		_structType = _structType + 1;
	}

	return(FALSE);
}

function int chooseEnemyToDrop()
{
	//choose the most annoying one

	temp5 = none;
	temp4 = (-1);	//num times attacked by an enemy

	temp = 0;
	while(temp < multiPlayerMaxPlayers)
	{
		if((not allianceExistsBetween(temp, me)) and (temp != me))
		{
			if((not dead[temp]) and knowBase[temp] and seeBase[temp])	//found player's base and know this player is active since can se him
			{
				temp2 = numAlliesDroppingPlayer(temp);

				temp3 = numActiveEnemyDrop(temp);

				if((temp3 == 0) and (temp2 < maxAllyDroppers))	//not too many and not already dropping
				{
					if(attacked[temp] > temp4)
					{
						temp4 = attacked[temp];
						temp5 = temp;
					}
				}
			}
		}
		temp = temp + 1;
	}

	return(temp5);
}

function int chooseEnemy()
{
	local	int		_bestEnemy,_enemy,_tileDist;
	local	int		_bestWeight,_tempWeight;
	//return - suited enemy to attack

	_bestEnemy = none;
	_bestWeight = -99999;

	if(offeredEnemy != none)		//anyone already attacking someone?
	{
		if((not ally[offeredEnemy]) and (not dead[offeredEnemy]) and (knowBase[offeredEnemy]) and (offeredEnemy != me))
		{
			dbg("choosing offered enemy", me);
			_bestEnemy = offeredEnemy;
			offeredEnemy = none;		//don't choose it again after destroying it
		}
	}

	if(_bestEnemy == none)		//didn't set offeredEnemy as the enemy
	{
		// now look for bases that were not yet destroyed and which we can see
		_enemy = 0;
		while(_enemy < multiPlayerMaxPlayers)
		{
			if((not ally[_enemy]) and (_enemy != me))
			{
				if(knowBase[_enemy] and (not dead[_enemy]) and
					(not killedBase[_enemy]) and seeBase[_enemy])	//found player's base
				{
					_tileDist = distBetweenTwoPoints(baseX, baseY, curBase[_enemy][0], curBase[_enemy][1]) / 128;

					// Now calculate enemy weight
					_tempWeight = (int)(W_LOST_UNITS * (float)lostDroids[_enemy] -
						W_BASE_DISTANCE * (float)_tileDist * TILE_TRAVEL_COST);

					if(_tempWeight > _bestWeight)
					{
						_bestWeight = _tempWeight;
						_bestEnemy = _enemy;	//enemy so far
					}
				}
			}
			_enemy++;
		}

		// now also include those bases we can't see
		if(_bestEnemy == none)
		{
			_enemy = 0;
			while(_enemy < multiPlayerMaxPlayers)
			{
				if((not ally[_enemy]) and (_enemy != me))
				{
					if(knowBase[_enemy] and (not dead[_enemy]) and
						(not killedBase[_enemy]))	//found player's base
					{
						_tileDist = distBetweenTwoPoints(baseX, baseY, curBase[_enemy][0], curBase[_enemy][1]) / 128;

						// Now calculate enemy weight
						_tempWeight = (int)(W_LOST_UNITS * (float)lostDroids[_enemy] -
							W_BASE_DISTANCE * (float)_tileDist * TILE_TRAVEL_COST);

						if(_tempWeight > _bestWeight)
						{
							_bestWeight = _tempWeight;
							_bestEnemy = _enemy;	//enemy so far
						}
					}
				}
				_enemy++;
			}
		}

		// now also include those bases that were already destroyed
		if(_bestEnemy == none)
		{
			_enemy = 0;
			while(_enemy < multiPlayerMaxPlayers)
			{
				if((not ally[_enemy]) and (_enemy != me))
				{
					//if(knowBase[_enemy] and (not dead[_enemy]))	//found player's base
					if(knowBase[_enemy])	//found player's base
					{
						//TODO: must choose a random one here, since will keep choosing the closest one
						_tileDist = distBetweenTwoPoints(baseX, baseY, curBase[_enemy][0], curBase[_enemy][1]) / 128;

						// Now calculate enemy weight
						_tempWeight = (int)(W_LOST_UNITS * (float)lostDroids[_enemy] -
							W_BASE_DISTANCE * (float)_tileDist * TILE_TRAVEL_COST);

						if(_tempWeight > _bestWeight)
						{
							_bestWeight = _tempWeight;
							_bestEnemy = _enemy;	//enemy so far
						}
					}
				}
				_enemy++;
			}
		}
	}

	return(_bestEnemy);
}

/* function int chooseEnemy()
{
	local	int		_bestEnemy,_bestDistance,_enemy,_tempDistance;
	local	int		_bestWeight;
	//return - suited enemy to attack

	_bestDistance = 99999;
	_bestEnemy = none;

	if(offeredEnemy != none)		//anyone already attacking someone?
	{
		//if((not ally[offeredEnemy]) and (not dead[offeredEnemy]) and (knowBase[offeredEnemy]) and (offeredEnemy != me) and (not killedBase[offeredEnemy]))
		if((not ally[offeredEnemy]) and (not dead[offeredEnemy]) and (knowBase[offeredEnemy]) and (offeredEnemy != me))
		{
			dbg("choosing offered enemy", me);
			_bestEnemy = offeredEnemy;
			offeredEnemy = none;		//don't choose it again after destroying it
		}
	}

	if(_bestEnemy == none)		//didn't set offeredEnemy as the enemy
	{
		// now look for bases that were not yet destroyed and which we can see
		_enemy = 0;
		while(_enemy < multiPlayerMaxPlayers)
		{
			if((not ally[_enemy]) and (_enemy != me))
			{
				if(knowBase[_enemy] and (not dead[_enemy]) and (not killedBase[_enemy]) and seeBase[_enemy])	//found player's base
				{
					_tempDistance = distBetweenTwoPoints(baseX, baseY, curBase[_enemy][0], curBase[_enemy][1]);
					if(_tempDistance < _bestDistance)
					{
						_bestDistance = _tempDistance;
						_bestEnemy = _enemy;	//enemy so far
					}
				}
			}
			_enemy++;
		}

		// now also include those bases we can't see
		if(_bestEnemy == none)
		{
			_enemy = 0;
			while(_enemy < multiPlayerMaxPlayers)
			{
				if((not ally[_enemy]) and (_enemy != me))
				{
					if(knowBase[_enemy] and (not dead[_enemy]) and (not killedBase[_enemy]))	//found player's base
					{
						_tempDistance = distBetweenTwoPoints(baseX, baseY, curBase[_enemy][0], curBase[_enemy][1]);
						if(_tempDistance < _bestDistance)
						{
							_bestDistance = _tempDistance;
							_bestEnemy = _enemy;	//enemy so far
						}
					}
				}
				_enemy++;
			}
		}

		// now also include those bases that were already destroyed
		if(_bestEnemy == none)
		{
			_enemy = 0;
			while(_enemy < multiPlayerMaxPlayers)
			{
				if((not ally[_enemy]) and (_enemy != me))
				{
					//if(knowBase[_enemy] and (not dead[_enemy]))	//found player's base
					if(knowBase[_enemy])	//found player's base
					{
						//TODO: must choose a random one here, since will keep choosing the closest one
						_tempDistance = distBetweenTwoPoints(baseX, baseY, curBase[_enemy][0], curBase[_enemy][1]);
						if(_tempDistance < _bestDistance)
						{
							_bestDistance = _tempDistance;
							_bestEnemy = _enemy;	//enemy so far
						}
					}
				}
				_enemy++;
			}
		}
	}

	return(_bestEnemy);
} */

function void checkBaseThreat()
{
	local 	int 	_attacker,_attackerUnitForce,_attackerStructureForce,_counterEnemy,_bestEnemyForce;
	local	int		_enemyUnits,_enemyStructures,_allyUnits,_allyStructures;
	local	int		_totalEnemies,_totalAllies,_range;
	local	int		_enemyX,_enemyY,_counterEnemyForce;

	//if(not bigMap)
	//	_range = (29 * 128);

	_range = COUNT_BASE_OBJECTS_RANGE;

	//showRangeAtPos(baseX, baseY, _range);

	/* Check if base is in danger */
	// _totalEnemies enemy units and structures
	_enemyUnits = 0;
	_enemyStructures = 0;

	// don't reset counterenemy if we are defending
	if(!defending()) {
		_counterEnemy = -1;
	}

	_bestEnemyForce = 0;
	_attacker = 0;
	while(_attacker < MAX_PLAYERS)
	{
		if((not allianceExistsBetween(_attacker, me)) and (_attacker != me))
		{
			_attackerUnitForce = numPlayerWeapDroidsInRange(_attacker, me, baseX, baseY, _range, FALSE);
			_enemyUnits = _enemyUnits + _attackerUnitForce;

			_attackerStructureForce = numPlayerWeapStructsInRange(_attacker, me, baseX, baseY, _range, true);
			_enemyStructures = _enemyStructures + _attackerStructureForce;


			//console(_attacker & " " & _attackerUnitForce & "/" & _attackerStructureForce);

			// see if this enemy dominates in the area and if so remember him as enemy to counter
			if((_counterEnemy < 0) or ((_attackerUnitForce + _attackerStructureForce / STR_UNIT_DEFENSE_FACTOR) > _bestEnemyForce))
			{
				_bestEnemyForce = _attackerUnitForce + _attackerStructureForce / STR_UNIT_DEFENSE_FACTOR;

				// don't reset counterenemy if we are defending
				if(!defending()) {
					_counterEnemy = _attacker;
				}
			}
		}
		_attacker++;
	}
	_enemyStructures = _enemyStructures / STR_UNIT_DEFENSE_FACTOR;

	//_enemyUnits = numEnemyWeapDroidsInRange(me, baseX, baseY, _range, FALSE);
	//_enemyStructures = numEnemyWeapStructsInRange(me, baseX, baseY, _range) / 3;

	_allyUnits = numFriendlyWeapDroidsInRange(me, baseX, baseY, _range, FALSE);
	_allyStructures = numFriendlyWeapStructsInRange(me, baseX, baseY, _range, true) / STR_UNIT_DEFENSE_FACTOR;

	_totalEnemies = _enemyUnits + _enemyStructures;	//total enemies
	_totalAllies = _allyUnits + _allyStructures;	//total allies

	if(_enemyUnits > 0)
		dbg("Num enemies = " & _enemyUnits & "/" & _enemyStructures & " (" & _allyUnits & "/" & _allyStructures & ") - " & (_range / TILE), me);

	/* pre-warn allies (only units _totalEnemies) */
	if(_enemyUnits >= 7)
	{
		if(!defending()) 	//do only once/attack
		{
			if(timeNotifyEnemyInBase <= 0)
			{
				notifyEnemyAtBase();

				attackedCount++;	//remember how many times we were attacked
			}
		}
	}

	/* Check if base in danger */
	if((_enemyUnits > _totalAllies) or ((_enemyUnits >= maxBaseEnemies) and ((_totalEnemies - _totalAllies) < 4)) or (_totalEnemies > _totalAllies)		//they have more units than all our defenses
	 or ((_allyUnits < minDefenders) and alert and (_enemyUnits >= 2) and (_allyStructures < 20)) )		//if we are low on defenders and power next attack might wipe us out (dangerous especially on big maps)
	{
		if(gameTime > 2800)
		{
			dbg("BASE: too many enemies in the base             !!!!!!", me);

			if(!defending())
			{
				if(state != stNone)
				{
					cancelState();
				}

				//TODO: with _attacker = playerDominanceInArea() find out if attacker's base is closer than our own base
				//and attack enemy base instead

				taunt(_counterEnemy, TAUNT_BASE_DEFENSE, 50);

				startDefending(_counterEnemy);
				requestHelp();
			}
		}

	}
	/* check if can stop defending */
	else if(defending() and (_enemyUnits == 0))		//all enemies are gone
	{
		if(groupSizeCmds(defendGr,true,false,true) >= minDefenders)		//make sure can defend on our own
		{
			dbg("base is safe again", me);

			_counterEnemy = counterEnemy;
			stopDefending();

			taunt(_counterEnemy, TAUNT_BASE_OK, 55);

			notifyAllies("i'm ok", FALSE);		//tell allies we are ok now

			/* See if we can counterattack */
			if((state == stNone) and (_counterEnemy != none))
			{
				if(not allianceExistsBetween(_counterEnemy, me))
				{
					if(totalWeapUnits() >= MIN_COUNTERATTACKERS)
					{
						if(knowBase[_counterEnemy])
						{
							_enemyX = curBase[_counterEnemy][0];
							_enemyY = curBase[_counterEnemy][1];
							_range = (20 * TILE);

							// see if we have a chance to win
							_counterEnemyForce = numPlayerWeapDroidsInRange(_counterEnemy, me, _enemyX, _enemyY, -1, FALSE) +
										  numPlayerWeapStructsInRange(_counterEnemy, me, _enemyX, _enemyY, _range, true) / 3;

							if(totalWeapUnits() > _counterEnemyForce)
							{
								dbg("counterattacking", me);
								startAttack(_counterEnemy, _enemyX, _enemyY);
								requestStartAttack(_counterEnemy, _enemyX, _enemyY);
							}
							else{
								dbg("counterattack: too dangerous: " & totalWeapUnits() & "/" & _counterEnemyForce, me);
							}
						}
						else{
							dbg("counterattack: don't have base of " & _counterEnemy, me);
						}
					}
					else{
						dbg("counterattack: not enough attackers " & totalWeapUnits(), me);
					}
				}
				else{
					dbg("counterattack: counterEnemy is ally: " & _counterEnemy, me);
				}
			}
			else{
				dbg("counterattack: busy: " & state & " : " & _counterEnemy, me);
			}

		}
	}
}

function void requestHelp()
{
	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(allianceExistsBetween(me , _temp))
		{
			giftRadar(me, _temp, FALSE);
			dropBeacon("help", _temp, me, baseX, baseY, 0);
			msg("help", me, _temp);
		}
		_temp = _temp + 1;
	}

	requestHelpTime = maxRequestHelpTime;
}

/* Request status from allies */
function void checkRequestStatus()
{
	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(allianceExistsBetween(me , _temp) and (tRequestStatus[_temp] <= 0))
		{
			requestStatus(_temp);
		}
		_temp = _temp + 1;
	}
}

function void requestStatus(int _player)
{
	msg("status?" ,me ,  _player);

	tRequestStatus[ _player] = tMaxRequestStatus + random(700);
}

function void requestEnemy(int _toAskPlayer)
{
	msg("who's your target?" ,me , _toAskPlayer);

	tWaitPlayerReply[_toAskPlayer] = tMaxWaitPlayerReply;	//start timer
}


function void notifyPlayerDead(int deadPlayer)
{
	exit;

	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(allianceExistsBetween(me , _temp))
		{
			if(deadPlayer == me)
			{
				msg("ok, i'm dead, cya" ,me , _temp);
			}
			else
			{
				msg(getPlayerName(deadPlayer) & " is dead" ,me , _temp);
			}
		}
		_temp = _temp + 1;
	}
}

function void notifyPlayerAlive(int _alivePlayer)
{
	exit;

	if(gameTime < 200)
		exit;	//engine bugs at startup

	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(allianceExistsBetween(me , _temp))
		{
			msg(getPlayerName(_alivePlayer) & " is alive" ,me , _temp);
		}
		_temp = _temp + 1;
	}
}

function void notifyPlayerBaseDestroyed(int _destroyedPlayer)
{
	notifyAllies("destroyed " & getPlayerName(_destroyedPlayer) & "'s base", FALSE);
}

function void notifyLost()
{
	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(allianceExistsBetween(me , _temp))
		{
			msg("cya" ,me , _temp);
		}
		_temp = _temp + 1;
	}
}

/* Notify we are idle, if failed to take over enemy derrick or if attack failed */
function void notifyIdle(bool bAfterFailure)
{
	if(bAfterFailure)
	{
		notifyAllies("building more units", false);		//make sure allies are aware of our current state
	}
	else
	{
		dice = random(10);
		if(dice > 5){
			notifyAllies("getting units", false);
		}else{
			notifyAllies("building an army", false);
		}
	}
}

function void taunt(int targetPlayer, int type, int tauntProbability)
{
	local	string		sTarget,sPlayer;

	if(random(100) >= tauntProbability)
	{
		return;
	}

	// see if we are refering to some player
	if(targetPlayer != NONE)
	{
		sPlayer = getPlayerName(targetPlayer);
		sTarget = getPlayerName(targetPlayer) &  ", ";
	}

	dice = random(10);

	if(type == TAUNT_SUCCESS)
	{
		if(dice < 3)
		{
			notifyAll(sTarget & "you suck.");
		}
		else if(dice < 7)
		{
			notifyAll("too easy");
		}
		else
		{
			notifyAll("I get what I want");
		}
	}
	else if(type == TAUNT_FAILURE)	// state failed
	{
		if(dice < 5){
			notifyAll(sTarget & "screw you!!");
		}else{
			notifyAll(sTarget & "stop turtling");
		}
	}
	else if(type == TAUNT_POSSESSION_LOSS)		// lost a derrick etc
	{
		if(dice < 5){
			notifyAll(sTarget & "I didn't need it anyway");
		}else if(dice < 8){
			notifyAll(sTarget & "next time i'll kick your ass!");
		}else{
			notifyAll(sTarget & "i'll get it back");
		}
	}
	else if(type == TAUNT_GAME_LOSS)
	{
		if(dice < 6){
			notifyAll("gg");
		}else if(dice < 8){
			notifyAll("rematch?");
		}else if(dice < 9){
			notifyAll("I can do better");
		}else{
			notifyAll("it's not my day..");
		}
	}
	else if(type == TAUNT_BASE_DEFENSE)
	{
		if(dice < 7){
			notifyAll(sTarget & "bring it on!");
		}else{
			notifyAll(sTarget & "I've been waiting for you");
		}
	}
	else if(type == TAUNT_BASE_OK)
	{
		if(dice < 4){
			notifyAll(sPlayer & " is a noob");
		}else if(dice < 6){
			notifyAll(sTarget & "maybe next time");
		}else if(dice < 8){
			notifyAll(sTarget & "so how did you like it?");
		}else if(dice < 9){
			notifyAll(sTarget & "ain't I good?");
		}else{
			notifyAll(sTarget & "is that all you got?");
		}
	}
	else if(type == TAUNT_REDISCOVERED_BASE)
	{
		if(dice < 4){
			notifyAll(sTarget & "found ya");
		}else if(dice < 6){
			notifyAll(sTarget & "there you are");
		}else if(dice < 8){
			notifyAll(sTarget & "let me finish you..");
		}else if(dice < 9){
			notifyAll(sTarget & "you thought I wouldn't find you?");
		}else{
			notifyAll(sTarget & "you can run but you can't hide");
		}
	}
	else if(type == TAUNT_LOST_BASE)
	{
		if(dice < 4){
			notifyAll(sTarget & "do you have anything left?");
		}else if(dice < 6){
			notifyAll(sTarget & "that felt good");
		}else if(dice < 8){
			notifyAll(sTarget & "you can't hide forever");
		}else{
			notifyAll("like a knife through butter");
		}
	}
}

function void notifyReadyAttack()
{
	dice = random(10);

	if(dice > 5){
		notifyAllies("go?", FALSE);
	}else if(dice == 0){
		notifyAllies("ready", FALSE);
	}else{
		notifyAllies("I'm ready", FALSE);
	}

	notifyReadyAttackTime = maxNotifyReadyAttackTime;

	bNotifiedReadyAttack = FALSE;	//remember not notified yet

	dbg("ATTACK: allies notified", me);
}

function void notifyReadyToDrop()
{
	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(allianceExistsBetween(me , _temp))
		{
			//if(allyEnemy[_temp] == enemy)		//only if he's attacking the same enemy
			//{
				msg("ready to drop" ,me , _temp);
			//}
		}
		_temp = _temp + 1;
	}

	dbg("ATTACK: allies notified of drop", me);
}

function void refreshAllyRadar()
{
	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(allianceExistsBetween(me , _temp))
		{
			giftRadar(me, _temp, FALSE);
		}
		_temp = _temp + 1;
	}
}

// one function for all notifications
function void notifyAllies(STRING _cstr, bool _bUpdateRadar)
{
	local int i;

	i = 0;
	while(i < multiPlayerMaxPlayers)
	{
		if(allianceExistsBetween(me, i))
		{
			if(_bUpdateRadar)
			{
				giftRadar(me, i, FALSE);
			}
			msg(_cstr, me, i);
		}
		i = i + 1;
	}
}

/* Send a message to all players */
function void notifyAll(STRING _cstr)
{
	local int player;

	player = 0;
	while(player < multiPlayerMaxPlayers)
	{
		msg(_cstr, me, player);
		player++;
	}
}

function void notifyTakeOil(int _enemy, int _x, int _y)
{
	dropAllyBeacon("gonna get " & getPlayerName(_enemy) & "'s derrick", _x, _y);
	notifyAllies("gonna get " & getPlayerName(_enemy) & "'s derrick", TRUE);
}

function void dropAllyBeacon(STRING _cstr, int _x, int _y)
{
	local int i;

	// for me
	dropBeacon(_cstr, me, me, _x, _y, 0);

	i = 0;
	while(i < multiPlayerMaxPlayers)
	{
		if((allianceExistsBetween(me, i)) and (i != me))
		{
			dropBeacon(_cstr, i, me, _x, _y, 0);
		}
		i = i + 1;
	}
}

function void requestPrepareDrop()
{
	if(enemy == none){MsgBox("requestPrepareDrop() - enemy == none"); exit;}

	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(allianceExistsBetween(me , _temp))
		{
			giftRadar(me, _temp, FALSE);
			msg("drop " & enemy, me , _temp);
		}
		_temp = _temp + 1;
	}
}

function void notifyPrepareDrop()
{
	if(enemy == none){MsgBox("notifyPrepareDrop() - enemy == none"); exit;}

	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(allianceExistsBetween(me , _temp))
		{
			giftRadar(me, _temp, FALSE);
			msg("dropping " & enemy, me , _temp);
			msg("preparing drop", me , _temp);
		}
		_temp = _temp + 1;
	}
}

function void notifyStartDrop()
{
	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(allianceExistsBetween(me , _temp))
		{
			msg("transporting units", me , _temp);
		}
		_temp = _temp + 1;
	}
}

function void notifyCantDrop()
{
	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(allianceExistsBetween(me , _temp))
		{
			if(allyEnemy[_temp] == enemy)
			{
				msg("can't drop", me , _temp);
			}
		}
		_temp = _temp + 1;
	}
}

function void notifyLoadedTransporters()
{
	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(allianceExistsBetween(me , _temp))
		{
			if(allyEnemy[_temp] == enemy)
			{
				msg("loaded transporters", me , _temp);
			}
		}
		_temp = _temp + 1;
	}
}

function void requestStartAttack(int _enemy, int _x, int _y)
{
	if(_enemy == none){MsgBox("requestStartAttack() - _enemy == none"); exit;}

	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(allianceExistsBetween(me , _temp))
		{
			giftRadar(me, _temp, FALSE);
			msg("go " & getPlayerName(_enemy), me , _temp);
			//dropBeacon("go " & getPlayerName(_enemy), _temp, me, _x, _y, 0);
		}
		_temp = _temp + 1;
	}

	dropAllyBeacon("go " & getPlayerName(_enemy), _x, _y);
}

function void notifyPlayerHasVTOLs(int _playerWithVTOLs)
{
	notifyAllies(getPlayerName(_playerWithVTOLs) & " got vtols", FALSE);
}

function void notifyStatusAll()
{
	local int i;

	i = 0;
	while(i < multiPlayerMaxPlayers)
	{
		if(allianceExistsBetween(me , i))
		{
			notifyStatus(i);
		}
		i = i + 1;
	}
}

function void notifyStatus(int _playerToNotify)
{
	if(state == stDefending)
	{
		notifyAllies(getPlayerName(_playerToNotify) & ": help" , false);
	}
	if(defendingOil())
	{
		notifyAllies(getPlayerName(_playerToNotify) & ": defending oil" , false);
		dropAllyBeacon("defending oil", sendForceX, sendForceY);
	}
	else if(state == stAttacking)
	{
		notifyAllies(getPlayerName(_playerToNotify) & ": attacking " & getPlayerName(enemy), false);
	}
	else if(state == stHelpingAlly)
	{
		notifyAllies(getPlayerName(_playerToNotify) & ": helping " & getPlayerName(enemy), false);
	}
	else if(state == stTakingOil)
	{
		notifyAllies(getPlayerName(_playerToNotify) & ": hunting " & getPlayerName(enemy) & "'s oil" , false);
		dropAllyBeacon("hunting " & getPlayerName(enemy) & "'s oil", sendForceX, sendForceY);
	}
	else if(((state == stDrop) or (state == stTransporting)) and (enemy != none))
	{
		notifyAllies(getPlayerName(_playerToNotify) & ": dropping " & getPlayerName(enemy), false);

		if(phase <= phGettingUnits)
		{
			notifyAllies(getPlayerName(_playerToNotify) & ": preparing drop", false);
		}
		else if(phase == phWaitAllies)
		{
			notifyAllies(getPlayerName(_playerToNotify) & ": ready to drop", false);
		}
		else if(phase == phLoadingTransport)
		{
			notifyAllies(getPlayerName(_playerToNotify) & ": loading transport", false);
		}
		else if(phase == phSendDrop)
		{
			notifyAllies(getPlayerName(_playerToNotify) & ": transporting units", false);
		}
	}
}

function void notifyPower(int _targetPlayer)
{
	if(playerPower(me) <= noPower)
	{
		msg("nope", me , _targetPlayer);
	}
	else if(playerPower(me) <= lowPower)
	{
		msg("not much", me , _targetPlayer);
	}
	else	//high power
	{
		msg("yeah", me , _targetPlayer);
	}
}

function void notifyEnemyAtBase()
{
	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(ally[_temp])
		{
			if(attackedCount == 0)		//first time
			{
				_temp2 = random(3);	//100%
				if(_temp2 == 0)
				{
					msg("oh no, here we go..." ,me , _temp);
				}
				else if(_temp2 == 1)
				{
					msg("it started" ,me , _temp);
				}
				else if(_temp2 == 2)
				{
					msg("they are at my base" ,me , _temp);
				}
			}
			else if((attackedCount > 0) and (attackedCount < 4))
			{
				_temp2 = random(5);
				if(_temp2 == 0)
				{
					msg("not again..." ,me , _temp);
				}
				else if(_temp2 == 1)
				{
					msg("they're after my base" ,me , _temp);
				}
				else if(_temp2 == 2)
				{
					msg("incoming" ,me , _temp);
				}
			}
			else if((attackedCount >= 4) and (attackedCount < 10))
			{
				_temp2 = random(6);
				if(_temp2 == 0)
				{
					msg("this is getting annoying..." ,me , _temp);
				}
				else if(_temp2 == 1)
				{
					msg("this sucks!" ,me , _temp);
				}
				else if(_temp2 == 2)
				{
					msg("duh..." ,me , _temp);
				}
				else if(_temp2 == 3)
				{
					msg("thery're after my base again" ,me , _temp);
				}
			}
			else
			{
				_temp2 = random(8);
				if(_temp2 == 0)
				{
					msg("why is it always my base???" ,me , _temp);
				}
				else if(_temp2 == 1)
				{
					msg("this sucks..." ,me , _temp);
				}
				else if(_temp2 == 2)
				{
					msg("duh..." ,me , _temp);
				}
				else if(_temp2 == 3)
				{
					msg("sooner or later they're gonna get me" ,me , _temp);
				}
				else if(_temp2 == 4)
				{
					msg("today is not my day..." ,me , _temp);
				}
				else if((_temp2 == 5) or (_temp2 == 6))
				{
					msg("they already attacked me " & attackedCount & " times!!! ... yes, I count!" ,me , _temp);
				}

			}
		}
		_temp = _temp + 1;
	}

	timeNotifyEnemyInBase = maxTimeNotifyEnemyInBase;
}

event defendBase(inactive)
{
	local	int		_cmdIndex,_edgeX,_edgeY,_numAttacked,_x,_y,_bucket;

	// if attacking en enemy, check if it's still safe to do so otherwise retreat
	/* if(baseDefendObj != NULLOBJECT)
	{
		if(numEnemyWeapObjInRange(me, baseDefendObj.x, baseDefendObj.y, (6 * 128), false, true) >=
			(groupSizeCmds(defendGr,true,false,true) - 1))
		{
			//dbg("NOT SAFE TO FOLLOW ATTACKER ANYMORE", me);

			//calc perim coords
			x = baseDefendObj.x;
			y = baseDefendObj.y;

			circlePerimPoint(baseX, baseY, ref x, ref y, (baseRange + defendCorridor / 2));	//move defense locations to the base perimeter

			// return those who were attacking him back to the base
			_bucket = initIterateGroupCmd(defendGr,true,true,false);
			droid = iterateGroupCmd(defendGr,_bucket);
			while(droid != NULLOBJECT)
			{
				if((droid.target != NULLOBJECT) and (droid.target == baseDefendObj))
				{
					orderDroidLoc(droid, DORDER_MOVE, x, y);		//don't SCOUT
				}
				droid = iterateGroupCmd(defendGr,_bucket);
			}

		}
	} */

	/* Attack any base intruders */
	defendArea(defendGr, baseRange, baseX, baseY, defendCorridor, minDefenders);

	/* Make newly built droids leave the center of the base */
	_edgeX = defendX;
	_edgeY = defendY;

	// we were not attacked during this game so far, recall a location from past experience
	if(_edgeX <= 0)
	{
		if(getBaseDefendLocCount() > 0)		//any locations stored?
		{
			// highest priority location is always at the top
			if(recallBaseDefendLoc(me, 0, ref _x, ref _y, ref _numAttacked))
			{
				// did we really get attacked at this location?
				if(_numAttacked > 0 and _x > 0 and _y > 0)
				{
					// make defenders go to this location when they get built
					_edgeX = _x;
					_edgeY = _y;
				}
			}
		}
	}

	// now move defenders to this location
	if(_edgeX > 0 and _edgeY > 0){
		cleanBaseCenter(defendGr, baseRange, baseX, baseY, _edgeX, _edgeY, defendCorridor);
	}
}

function void cleanBaseCenter(GROUP _group, int _range, int _defendX, int _defendY,
								int _edgeX, int _edgeY, int _defendCorridor)
{
	local 	DROID	_droid;
	local	int 	_bucket;

	/* go to the defend area perimeter, if too close to the defend area center */
	_bucket = initIterateGroupCmd(_group,true,true,false);
	_droid = iterateGroupCmd(_group,_bucket);
	while(_droid != NULLOBJECT)
	{
		if( distBetweenTwoPoints(_droid.x, _droid.y, _defendX, _defendY) < (_range / 2))	//too close to the defend area center -> can stuck in it's our base
		{
			if( !droidActionAttacking(_droid) )	//retreat even if busy but not directly attacking
			{
				//make sure not going to the perimeter already
				// NOTE: all distances must match with those ones in defendArea()
				 if( ! ( !droidOrderIdle(_droid) and (_droid.orderx > 0) and	// moving
					( (distBetweenTwoPoints(_droid.orderx, _droid.ordery, _defendX, _defendY) <= (_range + _defendCorridor / 2)) and	// inside defence range
					 (distBetweenTwoPoints(_droid.orderx, _droid.ordery, _defendX, _defendY) >= (_range / 2))  )))		// not too close to the base
				{
					// move to base perimeter, just before base defenses
					goToPerim(_defendX, _defendY, _edgeX, _edgeY,
						(_range + _defendCorridor / 2 - 128), DORDER_MOVE, _droid);
				}
			}
		}
		_droid = iterateGroupCmd(_group,_bucket);
	}

}

function void defendArea(GROUP _defendGr, int _range, int _defendX, int _defendY, int _defendCorridor, int _minDefenders)
{
	local BASEOBJ _target;
	local DROID	_droid;
	local bool	_bHaveTarget,_bHaveCloserEnemy,_bEnemyInBase;
	local int	_targetX,_targetY,_result,_result2,_reactToEnemyCorridor, _dist,_order;
	local int	_moveCloserThreshold,_tempX,_tempY,_bucket;

	if(groupSizeCmds(_defendGr,true,false,true) == 0)	//TODO: commanders must retreat
	{
		exit;
	}

	_bHaveTarget = FALSE;
	_target = NULLOBJECT;
	_reactToEnemyCorridor = 10 * 128;		//when enemy in this range, we move closer to the edge of the defence radius
	_order = DORDER_SCOUT;
	_moveCloserThreshold = 5 * 128;		//if new enemy is closer by this than the old one, then make sure we assign it as a new target

	/* Check if have to defend anything */

	//look at all visible objects close to base
	_target = getClosestEnemy(_defendX, _defendY,  _range + _defendCorridor + _reactToEnemyCorridor, FALSE, FALSE, me);
	if(_target != NULLOBJECT)
	{
		//result = isInMyBase(obj.x, obj.y);		//check in base

		//if(distBetweenTwoPoints(_target.x, _target.y, _defendX, _defendY) <= _range)		//within defend location
		//{
			_bHaveTarget = TRUE;
			_targetX = _target.x;
			_targetY = _target.y;
		//}
	}

	//attack
	if(_bHaveTarget)	//found target
	{
		/* if outside of the base and too dangerous to attack directly, move to the perimeter */
		_bEnemyInBase = FALSE;	//outside?
		if(distBetweenTwoPoints(_defendX, _defendY, _targetX, _targetY) >
			(_range + _defendCorridor))
		{
			_bEnemyInBase = TRUE;

			//calc perim coords
			_tempX = _targetX;
			_tempY = _targetY;
			circlePerimPoint(_defendX, _defendY, ref _tempX, ref _tempY, (_range + _defendCorridor / 2));	//move defense locations to the base perimeter

			/* If for base defenders, then remember defend location for newly built units */
			if(_defendGr == defendGr)
			{
				defendX = _tempX;
				defendY = _tempY;
			}
		}

		_result = numFriendlyWeapObjInRange(me, _targetX, _targetY, (10 * 128), false, true);
		_result2 = numEnemyWeapObjInRange(me, _targetX, _targetY, (10 * 128), false, true);

		if((groupSizeCmds(_defendGr,true,false,true) >= _minDefenders) or (_result >= _result2))	//don't send one by one or if dangerous
		{
			_bucket = initIterateGroupCmd(_defendGr,true,true,true);
			_droid = iterateGroupCmd(_defendGr,_bucket);
			while(_droid != NULLOBJECT)
			{
				_order = DORDER_SCOUT;		//default defend order

				/* if unit already going to defend loc, check if there's actually an enemy left at that loc */
				_bHaveCloserEnemy = FALSE;

				//if we have an enemy inside, then cancel order to the perim
				if(_bEnemyInBase and (_droid.orderx > 0) and (numEnemyWeapObjInRange(me, _droid.orderx, _droid.ordery, (7 * 128), false, true) == 0))
				{
					_bHaveCloserEnemy = TRUE;
				}

				/* Check if there's a new target which is closer to the base heart */
				if(not _bHaveCloserEnemy)		//won't move defender already anyway
				{
					if(_droid.orderx > 0)
					{
						_dist = distBetweenTwoPoints(_defendX, _defendY, _droid.orderx, _droid.ordery) - distBetweenTwoPoints(_defendX, _defendY, _targetX, _targetY);
						if(_dist > _moveCloserThreshold)		//if much closer
						{
							_bHaveCloserEnemy = TRUE;		//move back a bit
							_order = DORDER_MOVE;	//make sure will go directly to the closest enemy
							dbg("FOUND A CLOSER ENEMY!!!", me);
						}
					}
				}

				//nothing or returning to base
				if(droidOrderIdle(_droid) or (_droid.order == DORDER_MOVE) or _bHaveCloserEnemy)
				{
					//don't touch if attacking arty and don't make it 'break-dance', if already there
					if((_droid.order != DORDER_ATTACK) and (distBetweenTwoPoints(_droid.x, _droid.y, _targetX, _targetY) > _moveCloserThreshold))
					{
						orderDroidLoc(_droid, _order, _targetX, _targetY);
					}
				}

				_droid = iterateGroupCmd(_defendGr,_bucket);
			}
		}
	}

	/* check if defenders went too far from defend location */
	_bucket = initIterateGroupCmd(_defendGr,true,true,true);
	_droid = iterateGroupCmd(_defendGr,_bucket);
	while(_droid != NULLOBJECT)
	{
		if( (distBetweenTwoPoints(_droid.x, _droid.y, _defendX, _defendY) >
			(_range + _defendCorridor)))//too far from base
		{
			if( _droid.order != DORDER_ATTACK )	//retreat even if busy but not directly attacking
			{
				//make sure not returning already
				// if( ! ( !droidOrderIdle(_droid) and (_droid.orderx > 0) and	// moving
					// ( (distBetweenTwoPoints(_droid.orderx, _droid.ordery, _defendX, _defendY) <= (_range + _defendCorridor / 2)) and	// inside defence range
					// (distBetweenTwoPoints(_droid.orderx, _droid.ordery, _defendX, _defendY) >= (_range / 2))  )))		// not too close to the base
				if( ! ( !droidOrderIdle(_droid) and (_droid.orderx > 0) and	// moving
					 (distBetweenTwoPoints(_droid.orderx, _droid.ordery, _defendX, _defendY) <= (_range + _defendCorridor / 2) ) ))	// inside defence range
				{
					// move to base perimeter, just before base defenses
					goToPerim(_defendX, _defendY, _droid.x, _droid.y,
						(_range + _defendCorridor / 2 - TILE), DORDER_MOVE, _droid);

				}
			}
		}
		_droid = iterateGroupCmd(_defendGr,_bucket);
	}

	//dbg(" " & me & ")  END defendBase");
}

function void goToPerim(int _centerX, int _centerY, int _fromX,
						int _fromY, int _perimRange, int _order, DROID _droid)
{
	// find a closest point at a base perimeter to retreat to
	circlePerimPoint(_centerX, _centerY, ref _fromX, ref _fromY, _perimRange);

	// move
	orderDroidLoc(_droid, _order, _fromX, _fromY);
}

function void findFreeSpot(int _x, int _y)
{
	retInt = _x;
	retInt2 = _y;

	_temp = _x;
	_temp2 = _y;
	if(pickStructLocation(fac, ref _temp, ref _temp2, me))
	{
		retInt = _temp; retInt2 = _temp2;
		return;
	}

	return;
}

function void findFreeSpotMedium(int _x, int _y)
{
	retInt = _x;
	retInt2 = _y;

	_temp = _x;
	_temp2 = _y;
	if(pickStructLocation(powGen, ref _temp, ref _temp2, me))
	{
		retInt = _temp; retInt2 = _temp2;
		return;
	}

	return;
}

function void findFreeSpotSmall(int _x, int _y)
{
	retInt = _x;
	retInt2 = _y;

	_temp = _x;
	_temp2 = _y;
	if(pickStructLocation(wall, ref _temp, ref _temp2, me))
	{
		retInt = _temp; retInt2 = _temp2;
	}
}

function void startCollecting()
{
	setState(stCollecting);

	dbg("COLLECT: started collecting state", me);

	setCollectingLoc();

	startCollectingPhase();

}

function void startCollectingPhase()
{
	phase = phCollecting;

	orderGroupLocCmd(sendAttackGr, DORDER_MOVE, collectX, collectY);	//use move, cause far away units may keep attacking forever

	collectTime = maxCollectTime;

	dbg("COLLECT: started collecting at " & collectX / 128 & " - " & collectY / 128, me);
}

function void setCollectingLoc()
{
	collectX = groupCMD_x(sendAttackGr); collectY = groupCMD_y(sendAttackGr);

	dbg("setCollectingLoc() - mostOfGroup(): " & collectX / 128 & " - " & collectY / 128, me);

	//result3 = findFreeSpot(collectX, collectY);			//a lot of free space
	//collectX = retInt;	collectY = retInt2;

	dbg("setCollectingLoc() - set collect at " & collectX / 128 & " - " & collectY / 128, me);
}

//gathered units or time is up
function bool canStopCollecting()
{
	//return - 0 or 1

	/* time up */
	if(collectTime <= 0)
	{
		return(TRUE);
	}

	//temp = finishedCollecting();

	return(finishedCollecting());
}

//gathered units
function bool finishedCollecting()
{
	//return - 0 or 1

	/* most of them collected */
	if(distBetweenTwoPoints(collectX, collectY, groupCMD_x(sendAttackGr), groupCMD_y(sendAttackGr)) < (5 * 128))
	{
		return(TRUE);
	}

	return(FALSE);
}

function bool enoughDroppers()
{
	if((groupSizeCmds(attackGr,true,false,true) + groupSizeCmds(sendAttackGr,true,false,true) +
		groupSizeCmds(defendGr,true,false,true) - numDefenders) >= numDroppers)
	{
		return(TRUE);
	}

	return(FALSE);
}

function bool alliesReadyToDrop()
{
	_temp = 0;
	_temp2 = 0;

	while(_temp < multiPlayerMaxPlayers)
	{
		if(allianceExistsBetween(me , _temp))
		{
			if(allyState[_temp] == stDrop)		//gonna drop
			{
				if(allyEnemy[_temp] == enemy)	//dropping the same enemy as me
				{
					if(allyPhase[_temp] < phWaitAllies)
					{
						return(FALSE);		//not ready yet
					}
				}
			}
		}
		_temp = _temp + 1;
	}

	return(TRUE);		//all ok
}

function int getNumTransporters()
{
	_temp = 0;

	//Iterate through all player droids
	InitEnumDroids(me,me);
	_droid = EnumDroid();
	while(_droid != NULLOBJECT)
	{
		if(_droid.droidType == DROID_TRANSPORTER)
		{
			_temp = _temp + 1;
		}

		_droid = EnumDroid();
	}

	return(_temp);
}

function bool enoughTransporters()
{
	temp = numTransporters;

	temp2 = getNumTransporters();

	if(temp2 >= temp)
	{
		return(TRUE);
	}

	return(FALSE);
}

function void buildTransporters()
{
	temp = numTransporters;

	/* how many got already */
	temp2 = getNumTransporters();
	//temp2 = temp2 + numTemplatesInProduction(tmplUnitransporter,me);	//FIXME

	//if(temp2 >= temp){exit;}

	/* build transporters */
	initEnumStruct(FALSE,vtolfac,me,me);
	tempStruct = enumStruct();
	while((tempStruct != NULLOBJECT) and (temp2 < temp))
	{
		if(structureIdle(tempStruct))
		{
			//if(skCanBuildTemplate(me, tempStruct, tmplUnitransporter))
			if(skGetFactoryCapacity(tempStruct) >= 2)		//fully upgraded
			{
				dbg("started to build transporter", me);
				//buildDroid(tmplUnitransporter, tempStruct, me, 1);		//FIXME
				temp2 = temp2 + 1;
			}
		}

		tempStruct = enumStruct();
	}
}

function void fillDroppers()
{
	local	int 	_bucket;

	temp = groupSizeCmds(defendGr,true,true,true) - numDefenders;

	temp2 = 0;

	while((temp > 0) and (temp2 < numDroppers))	//leave 'numDefenders' number of units in the defendGr
	{
		temp4 = 99999;
		tempDroid2 = NULLOBJECT;

		/* get closest tank */
		_bucket = initIterateGroupCmd(defendGr,true,false,true);	//TODO: make work with commanders
		tempDroid = iterateGroupCmd(defendGr,_bucket);
		while(tempDroid != NULLOBJECT)
		{
			temp3 = distBetweenTwoPoints(baseX, baseY, tempDroid.x, tempDroid.y);
			if(temp3 < temp4)
			{
				temp4 = temp3;
				tempDroid2 = tempDroid;
			}
			tempDroid = iterateGroupCmd(defendGr,_bucket);
		}

		if(tempDroid2 != NULLOBJECT)	//got closest
		{
			groupAddDroid(sendAttackGr, tempDroid2);
		}
		else
		{
			temp2 = numDroppers;	//exit loop
		}

		temp = temp - 1;	//one less left in defendGr
		temp2 = temp2 + 1;	//one more loaded
	}

	selectGroup(sendAttackGr, TRUE);
}

function void dropLoadTransport()
{
	local	int 	_bucket;

	//transportGr

	dbg("loading total " & numTransporters & " transporters (" & groupSizeCmds(transportGr,true,true,true) & " units)",me);

	if(groupSizeCmds(transportGr,true,true,true) == 0){exit;}		//include commanders

	/* load transports */
	temp = 0;

	while(temp < maxTransporters)
	{
		if(transporter[temp] != NULLOBJECT)
		{
			temp5 = transporterCapacity(transporter[temp]);
			//dbg("transporterCapacity[" & temp & "] = " & temp5, me);

			while(temp5 > 0)
			{
				temp4 = 99999;
				tempDroid2 = NULLOBJECT;

				/* get closest tank */
				_bucket = initIterateGroupCmd(transportGr,true,false,true);	//TODO: make work with commanders
				tempDroid = iterateGroupCmd(transportGr,_bucket);
				while(tempDroid != NULLOBJECT)
				{
					if(tempDroid.order != DORDER_EMBARK)
					{
						//dbg("!= DORDER_EMBARK", me);

						temp3 = distBetweenTwoPoints(transporter[temp].x, transporter[temp].y, tempDroid.x, tempDroid.y);
						if(temp3 < temp4)
						{
							temp4 = temp3;
							tempDroid2 = tempDroid;
						}
					}
					tempDroid = iterateGroupCmd(transportGr,_bucket);
				}

				if(tempDroid2 != NULLOBJECT)	//got closest
				{
					//dbg("Unit embarking", me);
					orderDroidObj(tempDroid2, DORDER_EMBARK, transporter[temp]);
				}

				temp5 = temp5 - 1;
			}

		}
		temp = temp + 1;
	}
}

function bool transporterLoaded()
{
	/* check if anyone is still waiting to be loaded */
	if(groupSizeCmds(transportGr,true,true,true) <= numTransporters)	// > 90% loaded
	{
		dbg("transporter loaded!!!", me);
		return(TRUE);
	}

	/* check if loaded max number of droids (for example 20 for 2 transporters) */
	temp = numDroidsLoaded();
	temp2 = getNumTransporters();

	if(temp >= (temp2 * 10))
	{
		dbg("transporter loaded!!! 2", me);
		return(TRUE);
	}

	//dbg("transporter not loaded", me);
	return(FALSE);
}

//returns how many drois were loaded into transporters
function int numDroidsLoaded()
{
	/* load transports */
	_temp = 0;
	_temp2 = 0;		//how many loaded

	while(_temp < maxTransporters)
	{
		if(transporter[_temp] != NULLOBJECT)
		{
			_temp2 = (10 - transporterCapacity(transporter[_temp])) + _temp2;

		}
		_temp = _temp + 1;
	}

	return(_temp2);
}

function int numActiveEnemyDrop(int _enemyToCheck)
{
	if(_enemyToCheck < 0){return(maxAllyDroppers);}

	retInt = 0;
	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if((_temp != me) and (allianceExistsBetween(me , _temp)))
		{
			if((allyState[_temp] == stDrop) and (allyEnemy[_temp] == _enemyToCheck) and (allyPhase[_temp] >= phWaitAllies))	//will drop very soon
			{
				retInt = retInt + 1;
			}
		}
		_temp = _temp + 1;
	}

	return(retInt);
}

function int numAlliesDroppingPlayer(int _player)
{
	if(_player < 0){return(maxAllyDroppers);}

	retInt = 0;
	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if((_temp != me) and (allianceExistsBetween(me , _temp)))
		{
			if((allyState[_temp] == stDrop) and (allyEnemy[_temp] == _player))
			{
				retInt = retInt + 1;
			}
		}
		_temp = _temp + 1;
	}

	return(retInt);
}

function bool timeToDrop()
{
	//drop if we are further away from the enemy than all allies or if our turn has came

	if((curBase[enemy][0] <= 0) or (curBase[enemy][1] <= 0))
	{
		MsgBox("timeToDrop - curBase[enemy][x/y] <= 0 (" & me & ")");
		return FALSE;}

	if(enemy == none)
	{
		MsgBox("timeToDrop - no enemy set (" & me & ")");
		return FALSE;}

	_temp3 = me;
	_range = distBetweenTwoPoints(baseX, baseY, curBase[enemy][0], curBase[enemy][1]) + (3 * 128);	//+ (3 * 128) := reduce the cahnce that no one starts since all players store different ally coords

	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if((_temp != me) and (allianceExistsBetween(me , _temp)))
		{
			//if((allyState[_temp] == stDrop) and (allyEnemy[_temp] == enemy) and (allyPhase[_temp] >= phWaitAllies))	//check only those allies that are dropping the same enemy and are potentially ready
			if((allyState[_temp] == stDrop) and (allyEnemy[_temp] == enemy))
			{
				if(allyPhase[_temp] < phSync)	//someone not loaded transporters yet
				{
					return FALSE;
				}
				else
				{
					dbg("Ally phase is " & allyPhase[_temp], me);
				}

				if((curBase[_temp][0] > 0) and (curBase[_temp][1] > 0))		//know where this ally is
				{
					_temp2 = distBetweenTwoPoints(curBase[_temp][0], curBase[_temp][1], curBase[enemy][0], curBase[enemy][1]);

					/* is he farther away than all */
					if(_temp2 > _range)
					{
						_range = _temp2;
						_temp3 = _temp;		//remember furtherst ally
					}
				}
			}

		}
		_temp = _temp + 1;
	}

	if(_temp3 == me)	//no ally is farther than us or we're the only player dropping
	{
		dbg("timeToDrop - i'm furthest!!!!!", me);
		return TRUE;	//we are first
	}

	/* check if anyone has started transporting already */
	if(dropStartTime == none)
	{
		return(FALSE);		//wait for the furtherst player to start dropping
	}

	/* check how much time passed since first ally started drop, assuming sped = 1 tile/s */
	_temp = distBetweenTwoPoints(curBase[_temp3][0], curBase[_temp3][1], curBase[enemy][0], curBase[enemy][1]) - distBetweenTwoPoints(baseX, baseY, curBase[enemy][0], curBase[enemy][1]);	//dist diff ((ally - enemy) - (me - enemy))
	if((GAME_TIME_IN_SECS - dropStartTime) >= (_temp / 128))	//more time passed in secs than the diff in tiles between (furtherst ally - enemy) and (me - enemy)
	{
		dbg("timeToDrop() - syncing drop!!!!!", me);
		return(TRUE);	//now!!
	}

	return(FALSE);		//not yet, wait to sync drop
}

function void doDrop()
{
	if((transportX <= 0) or (transportY <= 0))
	{
		MsgBox("doDrop - transportX <= 0 (" & me & ")");
		return;
	}

	dbg("doDrop!!!", me);

	notifyStartDrop();		//tell we are starting to drop now

	/* if some units could not be loaded into transporters, add to defenders */
	if(groupSizeCmds(transportGr,true,true,true) > 0)		//TODO: deal with commanders
	{
		_temp = groupSizeCmds(transportGr,true,true,true);
		groupAddGroupCmd(defendGr, transportGr);
		dbg(" " & _temp & " units could not be loaded", me);
	}

	temp = 0;
	while(temp < numTransporters)
	{
		if(transporter[temp] != NULLOBJECT)
		{
			orderTranspDisembark(transporter[temp], transportX, transportY);
		}
		temp = temp + 1;
	}

	/* return those who were not loaded back to defenders */
	groupAddGroupCmd(defendGr, transportGr);
}

//---------------------------------------------
//	order transporter to send
//---------------------------------------------
function void orderTranspDisembark(DROID _transporter, int _coordx, int _coordy)
{
	bTempResult = chooseValidLoc(ref temp2, ref temp3, _coordx, _coordy, me, -1);	//no threat check
	if(bTempResult)
	{
		dbg("ordered to disembark", me);
		orderDroidLoc(_transporter, DORDER_DISEMBARK, temp2, temp3);
	}
	else
	{
		dbg("couldn't find a valid location for DISEMBARK!!!!!!!!!!!", me);
	}
}

event transLanded(inactive)
{
	dbg("Transporter landed", me);

	if(groupSizeCmds(tempGr,true,true,true) == 0){exit;}

	if((state == stNone) or defending())		//not doing anything, so unload to defenders
	{
		groupAddGroupCmd(defendGr, tempGr);
	}
	else
	{
		dbg("Added " & groupSizeCmds(tempGr,true,true,true) & " units to sendAttackGr", me);
		groupAddGroupCmd(sendAttackGr, tempGr);	//TODO: won't work with commanders?
	}

	/* check if have to fly it back to the base */
	if(not isInMyBase(droid.x, droid.y))
	{
		dbg("ordering transporter back to base", me);

		findFreeSpotSmall(baseX, baseY);
		temp2 = retInt;	temp3 = retInt2;

		orderDroidLoc(droid, DORDER_MOVE, temp2, temp3);
	}
}

function bool checkTransportersLanded()
{
	local bool	_bLanded;

	_bLanded = TRUE;	//all landed
	temp = 0;

	while(temp < numTransporters)
	{
		if(transporter[temp] != NULLOBJECT)
		{
			if(transporterCapacity(transporter[temp]) < 10)	//not all unloaded
			{
				_bLanded = FALSE;
			}
		}
		temp = temp + 1;
	}

	return(_bLanded);
}

function int setNumDroppers()
{
	retInt = maxDroppers;

	/* check how much we will have to invest into this drop */
	if(playerPower(me) < highPower)
	{
		temp = numAvailableAttackers();

		/* attack force*/
		if((retInt - temp) > 10)		//can't afford building this many
		{
			retInt = medDroppers;
			dbg("Medium droppers", me);
		}

		temp = calcNumRequiredTransporters(retInt);

		temp2 = getNumTransporters();

		/* check transporters */
		if((temp - temp2) >= 1)		//allow to build only 1 new transp for every drop
		{
			retInt = (temp2 + 1) * 10;	//as many as we have transporters already + 1
			//if(temp2 <= 0)			//no transporters yet
			//{
			//	retInt = minDroppers;	//smallest drop possible
			//	dbg("Min droppers", me);
			//}

			dbg("Min droppers", me);

			/* make sure we stay in bounds */
			if(retInt > maxDroppers)
			{
				retInt = maxDroppers;
			}
		}
	}

	return(retInt);
}

function int calcNumRequiredTransporters(int _numUnits)
{
	/* decide how many transporters we need */
	_retInt = _numUnits / 10;
	if((_retInt * 10) != _numUnits)		//fix integer div
	{
		_retInt = _retInt + 1;
	}

	if(_retInt > maxTransporters)
	{
		_retInt = maxTransporters;
	}

	return(_retInt);
}

function void prepareTransporters()
{
	temp = 0;

	while(temp < numTransporters)
	{
		if(transporter[temp] != NULLOBJECT)
		{
			if(groupSizeCmds(transportGr,true,true,true) > 0)
			{
				temp2 = groupCMD_x(transportGr);
				temp3 = groupCMD_y(transportGr);

				circlePerimPoint(baseX, baseY, ref temp2, ref temp3, baseRange);

				findFreeSpotMedium(temp2, temp3);
				temp2 = retInt;	temp3 = retInt2;

				orderDroidLoc(transporter[temp], DORDER_MOVE, temp2, temp3);
			}
		}

		temp = temp + 1;
	}
}

function void updateDropPhase()
{
	/* check if already can build transporter */
	if(phase == phGettingTech)
	{
		//if(researchFinished(resUnitTransporter, me))
		//{
			phase = phGettingUnits;
		//}
	}

	if(phase == phGettingUnits)
	{
		result3 = getNumTransporters();

		/* if we hit unit limit, we'll never be able to build transporters */
		if((result3 < numTransporters) and (getDroidCount(me) >= unitLimit))
		{
			if(result3 > 0)		//got at least 1 transp
			{
				numTransporters = result3;		//continue with whatever we have
				numDroppers = numTransporters * 10;
			}
		}

		/* check if have enough units and transp for drop */
		//result = enoughDroppers();
		//result2 = enoughTransporters();

		if(enoughDroppers() and enoughTransporters())
		{
			/* notify allies and start waiting for other allies */
			notifyReadyToDrop();
			prepareTransporters();	//make sure units can reach them
			tWaitAlliesDrop = tMaxWaitAlliesDrop;		//start wait-for-allies timer

			phase = phWaitAllies;		//wait for others
		}
	}

	if(phase == phWaitAllies)
	{
		/* check if other allies are also ready to drop */
		if(alliesReadyToDrop() or (tWaitAlliesDrop <= 0))	//all ready or waited for too long
		{
			fillDroppers();

			startTransportState(sendAttackGr, curBase[enemy][0], curBase[enemy][1]);
		}
	}

	/* we are back from transport state */
	if(phase == phTransportDone)
	{
		stopDropState();		//can stop drop now and resume any paused state (if any)
	}
}

function void updateTransport()
{
	if(phase == phLoadingTransport)
	{
		if(transporterLoaded())				//loaded
		{
			phase = phSync;
			tSyncDrop = tMaxSyncDrop;		//start sync with allies countdown
			notifyLoadedTransporters();
			//exit;		//if just finished dropping enemy, give allies time to reset their states, otherwise will think they are still dropping some enemy
		}
		else if((tWaitLoadDrop <= 0) or (dropStartTime != none))		//waited too long, or someone has started drop already!!!, drop now
		{
			temp = numDroidsLoaded();

			temp2 = numAlliesDroppingPlayer(enemy);

			if((temp >= (numDroppers * 30 / 100)) or ((temp2 > 0) and (temp > 0)))				// 30% of all droppers were loaded or not the only one dropping and loaded something
			{
				phase = phSync;
				tSyncDrop = tMaxSyncDrop;		//start sync with allies countdown
				notifyLoadedTransporters();
				//exit;		//if just finished dropping enemy, give allies time to reset their states, otherwise will think they are still dropping this enemy
			}
			else
			{
				cancelTransportState();	//couldn't load enough
			}
		}
		else
		{
			dropLoadTransport();
		}
	}

	/* syncronize drop with allies, wait if needed */
	if(phase == phSync)
	{
		if(timeToDrop() or (tSyncDrop <= 0))		//can drop now or waited too long
		{
			if(tSyncDrop <= 0)
			{
				dbg("tSyncDrop timeout - time to drop!!!!", me);
			}
			else
			{
				dbg("timeToDrop() - time to drop!!!!", me);
			}

			phase = phSendDrop;		//on the way to the enemy
			doDrop();
		}
		else
		{
			dbg("waiting for my turn to drop", me);
		}
	}

	/* watch for transporters to arrive */
	if(phase == phSendDrop)
	{
		if( checkTransportersLanded() )		//all unloaded
		{
			dbg("Transporter landed!!!!!!!!!!!", me);
			stopTransportState();
		}
	}

	//dbg("phase = " & phase, me);
}

function void startTransportState(GROUP _groupToTransport, int _destinationX, int _destinationY)
{
	dbg("Starting transport phase!!!!!!", me);

	transportX = _destinationX;
	transportY = _destinationY;
	transportGr = _groupToTransport;

	temp = getNumTransporters();
	if(temp == 0)
	{
		cancelTransportState();
		return;
	}

	if(state != stNone)
	{
		saveCurrentState();
	}

	endState();		//init vars of the original state

	setState(stTransporting);
	phase = phLoadingTransport;

	tWaitLoadDrop = tMaxWaitLoadDrop;

	dropLoadTransport();
}

function void saveCurrentState()
{
	savedState = state;
	//savedPhase = phase;
	//savedEnemy = enemy;
}

function void loadSavedState()
{
	dbg("loading saved state!!!!!!!!", me);

	if(savedState == stDrop)
	{
		/* after drop complete start attacking enemy */

		dbg("loaded drop state!!!!!!!!", me);

		setState(savedState);
	}
	else	//?, just init state and phase vars
	{
		stopTransportState();
	}

	/* clear vars */
	eraseLoadSavedState();
}

function void eraseLoadSavedState()
{
	savedState = stNone;
	savedPhase = phNone;
	savedEnemy = none;
}

function void resortTransporters()
{
	temp = 0;
	while(temp < maxTransporters)
	{
		if(transporter[temp] == NULLOBJECT)
		{
			/* check if we have a droid up in the array */
			temp2 = temp + 1;	//go up from current, assume bottom fixed
			while((temp2 < maxTransporters) and (transporter[temp] == NULLOBJECT))
			{
				if(transporter[temp2] != NULLOBJECT)
				{
					/* swap in array */
					transporter[temp] = transporter[temp2];
					transporter[temp2] = NULLOBJECT;
				}

				temp2 = temp2 + 1;
			}
		}

		temp = temp + 1;
	}
}


function void startDropPhase()
{
	if(enemy < 0){MsgBox("startDropPhase - enemy < 0"); return;}
	if((curBase[enemy][0] <= 0) or (curBase[enemy][1] <= 0)){MsgBox("startDropPhase - enemy coords < 0"); return;}
	if(not knowBase[enemy]){MsgBox("startDropPhase - knowBase[enemy] == FALSE"); return;}

	setState(stDrop);
	phase = phGettingTech;

	tempReinfCount[enemy] = 0;		//reset here
	dropStartTime = none;
	tSyncDrop = 0;

	/* decide how many units we will drop */
	numDroppers = setNumDroppers();

	/* decide how many transporters we need */
	numTransporters = calcNumRequiredTransporters(numDroppers);

	dbg("Preparing drop at " & getPlayerName(enemy) & " with " & numDroppers & " units and " & numTransporters & " transporters!!", me);

	sendForceX = curBase[enemy][0];
	sendForceY = curBase[enemy][1];

	resortTransporters();	//resort array

	updateDropPhase();
}

function void updateStateCoord(int _newx, int _newy)
{
	sendForceX = _newx;
	sendForceY = _newy;
}

/* Fill attackers, prepare commanders etc */
function void prepareAttackers(bool _bHighPriorityTask)
{
	local	int		_numNeedToBeAssigned;

	/* Unassign all units from all commanders in the defendGr  to the defendGr */
	unassignAllDroidsFromCMDsFromGroup(defendGr, defendGr);

	/* Add required number of units from defendGr to sendAttackGr (non-commanders only) */
	fillAttackers(numAttackersFromPriorty(_bHighPriorityTask));

	/* Make commanders fromattack group take over units without commander from attackGr */
	assignDroidsToBestCommandersFromGroup(attackGr,attackGr);

	/* Make commanders fromattack group take over units without commander from sendAttackGr */
	assignDroidsToBestCommandersFromGroup(attackGr,sendAttackGr);

	/* Count how many droids will end up being unassigned after using all commanders in  sendAttackGr and attackGr groups */
	_numNeedToBeAssigned = groupSizeCmds(sendAttackGr, true, false, false) +	//count unassigned droids
						   groupSizeCmds(attackGr, true, false, false) -
						   getFreeCmdsCapacityInGroup(sendAttackGr) -
						   getFreeCmdsCapacityInGroup(attackGr);

	/* Add commanders to the sendAttackGr until we have enough commanders to assign all droids to them */
	if(_numNeedToBeAssigned > 0){
		fillBestCommandersCapacity(_numNeedToBeAssigned, sendAttackGr, defendGr);
	}

	dbg("Num new commanders attacking: " &
		groupSizeCmds(sendAttackGr, false, true, false), me);

	/* Make new commanders from group sendAttackGr take over unassigned droids from sendAttackGr,
	  unassigned units from attackGr will be taken over after this new commanders have reached attack loc,
	  to make sure unassigned units will not travel back to the base to meet the need commander */
	assignDroidsToBestCommandersFromGroup(sendAttackGr, sendAttackGr);

	/* Make commanders left in the defendGr take over the rest of the unassigned droids from group defendGr */
	assignDroidsToBestCommandersFromGroup(defendGr, defendGr);

	/* NOTE: unassigned droids from attackGr will get assigned to the coming commanders
	 *  after commanders have reached destination point and get assigned to the attackGr */
}

function void startAttack(int _enemy, int _x, int _y)
{
	if(_enemy < 0){MsgBox("startAttack - _enemy < 0"); return;}
	if((_x <= 0) or (_y <= 0)){MsgBox("startAttack - enemy coords < 0"); return;}
	//if(not knowBase[enemy]){MsgBox("startAttack - knowBase[enemy] == FALSE"); return;}

	//if(state != stNone){return;}

	dbg("Starting attack at " & getPlayerName(_enemy) & " !!!!!", me);

	setState(stAttacking);

	enemy = _enemy;
	sendForceX = _x;
	sendForceY = _y;

	/* Set minimum number of defenders to leave in the base */
	updateNumDefenders();

	/* Assign attackers and commanders to groups */
	prepareAttackers(false);

	startMovePhase();

	/* reset notification stuff */
	bNotifiedReadyAttack = FALSE;
	notifyReadyAttackTime = 0;

	reinfCount[enemy] = reinfCount[enemy] + 1;
	tempReinfCount[enemy] = tempReinfCount[enemy] + 1;

	countTakeOil = 0;		//allow hunting oil again
}

//Attack enemy base with VTOLs
function void vStartAttackBase(int _enemy)
{
	if(_enemy < 0){MsgBox("startAttack - _enemy < 0"); return;}
	if((_x <= 0) or (_y <= 0)){MsgBox("startAttack - enemy coords < 0"); return;}
	if(not knowBase[_enemy]){return;}

	//if(state != stNone){return;}

	dbg("Starting attack at " & getPlayerName(_enemy) & " !!!!!", me);

	//vstate = stAttackBase;

	//venemy = _enemy;

	//sendForceX = curBase[venemy][0];
	//sendForceY = curBase[venemy][1];

	//VTOLAttackBase(venemy);
}

/*
function void vAttackBase(int _enemy)
{
	local BASEOBJ	_newTarget;

	if(vtolGr.members < minVtolAttackers)
	{
		vstopState();
		return;
	}

	//check if too well defended
	if(not vtolSafe(vsendForceX, vsendForceY))
	{
		vstopState();
		return;
	}

	//idle?
	if(idleGroupCmd(vtolGr) >= (vtolGr.members / 2))
	{
		// need new target
		_newTarget = vBaseTarget(_enemy);

		if(_newTarget == NULLOBJECT)
		{
			vstopState();	//nothing to attack
			return;
		}

		vDoAttackObj(vtolGr, _newTarget);
	}
}
*/

function void startMovePhase()
{
	if((sendForceX <= 0) or (sendForceY <= 0)){MsgBox("startMovePhase() - sendForceXY <= 0"); return;}

	orderGroupLocCmd(sendAttackGr, DORDER_SCOUT, sendForceX, sendForceY);

	reinfTime = maxReinfTime;	//start "cancel attack" countdown

	phase = phMoveToLoc;

	dbg("MOVE PHASE: started", me);
}

function void startTakingOil(STRUCTURE _enemyDerrick)
{
	local	int		_numAttackers;

	if(_enemyDerrick == NULLOBJECT){MsgBox("startTakingOil - derrick == NULLOBJECT"); return;}

	//if(enemy < 0){MsgBox("startTakingOil - enemy < 0"); exit;}
	//if((sendForceX <= 0) or (sendForceY <= 0)){MsgBox("startTakingOil - sendForceXY <= 0"); exit;}

	setState(stTakingOil);

	enemy = _enemyDerrick.player;
	tempReinfCount[enemy] = 0;		//reset

	sendForceX = _enemyDerrick.x;
	sendForceY = _enemyDerrick.y;

	/* Set minimum number of defenders to leave in the base */
	updateNumDefenders();

	dbg("Starting taking " & getPlayerName(enemy) & "'s oil at " & sendForceX / 128 & " - " & sendForceY / 128 & "!!!!!", me);

	/* Assign attackers and commanders to groups */
	prepareAttackers(false);

	startMovePhase();

	timeGuardPos = 0;	//cancel countdown
	tTakeOil = tMaxTakeOil;

	countTakeOil = countTakeOil + 1;	//remember how many times we took oil

	//phase = phMoveToLoc;
}

/* Changes state and returns old state */
function void setState(int _newState)
{
	local int	_oldState;

	/* Initialize state time */
	tState = 0;

	_oldState = state;
	state = _newState;

	//return _oldState;
}

/* Changes vtol state and returns old state */
function void vsetState(int _newState)
{
	local int	_oldState;

	/* Initialize state time */
	//tvState = 0;

	_oldState = vstate;
	vstate = _newState;

	//return _oldState;
}

//don't leave BBs in defend group
function int sortOutBBs()
{
	local	DROID	_bbDroid;
	local	int 	_bucket,_numBBs;

	_bucket = initIterateGroupCmd(defendGr,true,false,true);
	_bbDroid = iterateGroupCmd(defendGr,_bucket);
	while(_bbDroid != NULLOBJECT)
	{
		if(_bbDroid.weapon == weaponBB)
		{
			groupAddDroid(sendAttackGr,_bbDroid);
			_numBBs++;
		}
		_bbDroid = iterateGroupCmd(defendGr,_bucket);
	}

	return _numBBs;
}

function void doAttack()
{
	local	int 	_bucket;

	//dbg(" " & me & ")  doAttack()");

	//if(state != stAttacking){return;}

	//if going back to base, check if already there
	//-----------------------------------------------
/*
	if(phase == phRTB)
	{
		range = (20 * 128);		//attacker reached home base range
		initIterateGroup(sendAttackGr);
		droid = iterateGroup(sendAttackGr);
		while(droid != NULLOBJECT)
		{
			if(distBetweenTwoPoints(droid.x, droid.y, droid.orderx, droid.ordery) < range)
			{
				groupAddDroid(defendGr,droid);
			}//check if going back to base
			else if(distBetweenTwoPoints(baseX, baseY, droid.orderx, droid.ordery) >= range)
			{
				orderDroid(droid, DORDER_RTB);	//send back to base
			}

			droid = iterateGroup(sendAttackGr);
		}

		//Migration not over yet?
		if(sendAttackGr.members <= 5)
		{
			groupAddGroup(defendGr, sendAttackGr);
			phase = phNone;
			dbg("attackers backin the base !!!", me);
		}
	}
*/

	//all real attack stuff comes here
	//-----------------------------------------------


	if(enemy < 0){MsgBox("doAttack - enemy < 0");return;}

	/* check if someone has destroyed our enemy */
	//if(dead[enemy] or ((not knowBase[enemy]) and (phase < phAttackingLoc)))	//only if phAttacking < attacking => someone else did it
	if(dead[enemy] and (phase < phAttackingLoc))	//only if phAttacking < attacking => someone else did it
	{
		dbg("someone destroyed enemy, cancel attack", me);
		stopAttack();
		return;
	}

	if((curBase[enemy][0] <= 0) or (curBase[enemy][1] <= 0)){MsgBox("doAttack - enemy coords < 0"); return;}



	/* Update coordinates */
	//if(curBase[enemy][0] > 0 and curBase[enemy][1] > 0)	//only update if set?
	//{
		sendForceX = curBase[enemy][0];
		sendForceY = curBase[enemy][1];
	//}

	//------------------------------------------------------------------------------
	//if we lost enemy base, were looking for it and found it, switch back to attack
	//------------------------------------------------------------------------------
	if((phase == phSearchingForBase) and (seeBase[enemy]))
	{
		dbg("after revealing found enemy base again, attack (!!!!!!!!!!!!)", me);
		phase = phMoveToLoc;	//go to the new enemy base location

		taunt(enemy, TAUNT_REDISCOVERED_BASE, 40);
	}

	//--------------------------------------------------
	//send reinforcements
	//--------------------------------------------------
	//result = defendGr.members - numDefenders;	//available units
	//if((result >= minReinforcements) or ((result >= minReinforcements / 2) and (attackGr.members >= numAttackers / 2)) )	//enough reinf, or still many attackers and some reinf


	//------------------------------------------------
	//manage attack
	//------------------------------------------------

	//if there are enemy structures left, move closer to them to attack, don't run away

	//if((phase == phAttackingLoc) and (seeBase[enemy]))	//not revealing the base territory already

	if(phase != phSearchingForBase)		//not already revealing
	{
		if(not seeBase[enemy])	//no targets, check if any unrevealed territory left
		{
			//if this loc is not recalled from memory (loc will be invisible then)
			//if((curBase[enemy][0] != base[enemy][0]) or (curBase[enemy][1]) != base[enemy][1])
			if(mapRevealedInRange(sendForceX, sendForceY, (2 * 128), me))		//if revealed so can judge if there's nothing
			{
				dbg("ATTACK: No visible enemy structures left, revealing territory !!!!!", me);
				phase = phSearchingForBase;

				taunt(enemy, TAUNT_REDISCOVERED_BASE, 40);
			}
		}
	}


	//reveal territory near the enemy base
	if(phase == phSearchingForBase)
	{
		range = (16 * 128);		//search for enemy structures in en base range

		_bucket = initIterateGroupCmd(attackGr,true,true,true);
		droid = iterateGroupCmd(attackGr,_bucket);
		while(droid != NULLOBJECT)
		{
			if(droidOrderIdle(droid) and !droidActionAttacking(droid))
			{
				//reveal more territory in the range of the enemy base, no threat check
				if(fogTileInRange(ref x, ref y, droid.x, droid.y, sendForceX, sendForceY, range, me, -1))		//no threat check
				{
					orderDroidLoc(droid, DORDER_SCOUT, x, y);
				}
				else if(phase != phLostBase)
				{
					dbg("nothing to reveal anymore, lost enemy base !!!", me);
					phase = phLostBase;	//no move unrevealed territory
				}
			}
			droid = iterateGroupCmd(attackGr,_bucket);
		}
	}

	//dbg(" " & me & ")  END doAttack()");
}

/* range in world units!!!! */
function void findAttackBaseTarget(DROID _looker, int _x, int _y, int _radius)
{
	ASSERT(_looker != NULLOBJECT, "findAttackBaseTarget: _looker is NULLOBJECT", me);

	retObj = NULLOBJECT;

	//dbg(" " & me & ")              findAttackBaseTarget");

	//find a target
	if((_looker.order == DORDER_NONE) or (_looker.order == DORDER_SCOUT) or (_looker.order == DORDER_MOVE))
	//if(_looker.order != DORDER_ATTACK)
	{
		//dbg(" " & me & ")              no order");
		if(objHasWeapon(_looker))
		{
			//dbg(" " & me & ")              has weapon");

			/* Use weapon range if no radius specified */
			temp = _radius;
			if(_radius < 0)
			{
				_radius = objWeaponMaxRange(_looker);	//objWeaponMaxRange is in world units
				_radius = _radius + (2 * 128);	//target range = droid weapon range + 2 tiles
			}

			if(_radius > 0)
			{
				/* Use unit coords if no position set where to look for units */
				if(_x < 0)
					_x = _looker.x;

				if(_y < 0)
					_y = _looker.y;

				/* see any trucks? */
				tempDroid = getClosestEnemyDroidByType(_x, _y, _radius, DROID_CONSTRUCT, FALSE, me);

				if(tempDroid == NULLOBJECT)
				{
					/* any repairers? */
					tempDroid = getClosestEnemyDroidByType(_x, _y, _radius, DROID_REPAIR, FALSE, me);

					if(tempDroid != NULLOBJECT)
					{
						if(tempDroid.action == DACTION_REPAIR)	//only if repairing
						{
							retObj = tempDroid;
						}
					}

					if(retObj == NULLOBJECT)
					{
						if(((_looker.action == DACTION_NONE) or (_looker.action == DACTION_DROIDREPAIR)) and (_looker.order == DORDER_NONE))	//didn't see a target that is actually near it
						{
							retObj = getClosestEnemy(_x, _y, _radius, TRUE, FALSE, me);
						}
					}
				}
				else
				{
					retObj = tempDroid;
				}

			}
		}
	}
}

function void findBBAttackBaseTarget(DROID _looker)
{
	retObj = NULLOBJECT;

	//temp = (2 * 128);	//"reached the destination" range

	if(_looker.order != DORDER_ATTACK)
	{
		//dbg(" " & me & ")              BB no order");
		if(objHasWeapon(_looker))
		{
			//dbg(" " & me & ")              BB has weapon");

			temp = objWeaponMaxRange(_looker);	//objWeaponMaxRange is in world units
			if(temp > 0)
			{
				//dbg(" " & me & ")              BB has range");

				temp2 = (temp + (3 * 128));	//target range = droid weapon range + 3 tiles

				tempStruct = getClosestEnemyStructByType(_looker.x, _looker.y, temp2, REF_DEFENSE, me);
				if(tempStruct == NULLOBJECT)
				{
					tempStruct = getClosestEnemyStructByType(_looker.x, _looker.y, temp2, REF_WALL, me);
					if(tempStruct == NULLOBJECT)
					{
						tempStruct = getClosestEnemyStructByType(_looker.x, _looker.y, temp2, REF_WALLCORNER, me);
					}

					if(tempStruct == NULLOBJECT)
					{
						tempStruct = getClosestEnemyStructByType(_looker.x, _looker.y, temp2, -1, me);	//any structure
						if(tempStruct != NULLOBJECT)
						{
							//dbg(" " & me & ")  BB found some structure");
							retObj = tempStruct;
						}
					}
					else
					{
						//dbg(" " & me & ")  BB found wall");
						retObj = tempStruct;
					}
				}
				else
				{
					//dbg(" " & me & ")  BB found defense");
					retObj = tempStruct;
				}

			}
		}
	}
}

function void checkStopAttack()
{
	if(state != stAttacking){return;}	//exit if doAttack() already called stopAttack()

	if(enemy < 0)
	{
		MsgBox("checkStopAttack() - enemy < 0");
		cancelAttack();
		return;
	}

	//------------------------------------------------------------------------------
	//Check if we failed
	//------------------------------------------------------------------------------
	if((reinfTime <= 0) and (phase < phAttackingLoc) and
		(groupSizeCmds(sendAttackGr,true,false,true) <= minAttackers))	//not actively attacking or searching for base
	{
		dbg("cancelling attack !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!", me);

		numPlayerAttackers[enemy] = min(minAttackers, numPlayerAttackers[enemy] + random(attackersIncrease));

		cancelAttack();
	}

	//------------------------------------------------------------------------------
	//Check we succeeded
	//------------------------------------------------------------------------------
	else if((phase == phLostBase) and (not seeBase[enemy]))	//no enemy structures left (found)
	{
		dbg("cancelling attack, RTB", me);

		//knowBase[enemy] = FALSE;	//disabled 15.05.05 because phSearchingFor base was skipped because of this

		killedBase[enemy] = TRUE;	//remember this one's done, but doesn't have to be completely dead, so no dead[x] = TRUE;

		notifyPlayerBaseDestroyed(enemy);

		stopAttack();
	}
}


function void gatewayDefenses()
{
	result = numTrucksSameOrder(DORDER_LINEBUILD);

	if(result > 0){return;}		//max 1 truck can be busy with gateway defenses

	droid = closestIdleTruck(baseX, baseY);

	if(droid == NULLOBJECT)
	{
		return;
	}

	bResult = TRUE;

	x = baseX;
	y = baseY;

	count = numGatewayDef - 1;
	count2 = none;
	while(bResult and (count >= 0) )
	{
		if(isStructureAvailable(gatewayDef[count],me))
		{
			count2 = count;
			bResult = FALSE;	//found best one
		}
		count = count - 1;
	}
	if(not bResult)
	{
		skDefenseLocationB(ref x,ref y,wall,gatewayDef[count2],droid,me);
	}
}

//---------------------------------------------------------
//	Store experience
//---------------------------------------------------------
function void storeBaseDefLocEv()
{
	if(obj2 == NULLOBJECT)
	{
		MsgBox("storeBaseDefLocEv - obj2 is NULLOBJECT");
		return;
	}

	//Don't store if not enough time passed since the last save, but store new locations in any case
	if((getBaseDefendLocIndex(me, obj2.x, obj2.y) < 0) or (storeBaseDefTime[obj2.player] <= 0))
	{
		//move coords closer to base

		//temp = obj.x;
		//temp2 = obj.y;

		learnBaseDefendLoc(me, obj2.player, obj2.x, obj2.y);

		storeBaseDefTime[obj2.player] = storeTime;		//start countdown
	}

}

function void storeOilDefLocEv()
{
	if(obj2 == NULLOBJECT)
	{
		MsgBox("storeOilDefLocEv - obj2 is NULLOBJECT");
		return;
	}

	//Don't store if not enough time passed since the last save, but store new locations in any case
	if((getOilDefendLocIndex(me, obj2.x, obj2.y) < 0) or (storeOilDefTime[obj2.player] <= 0))
	{
		learnOilDefendLoc(me, obj2.player, obj2.x, obj2.y);

		storeOilDefTime[obj2.player] = storeTime;		//start countdown
	}
}


//---------------------------------
//Go meet ally's force
//---------------------------------
function void joinForces(int _joinPlayer, int _x, int _y)
{
	dbg("joining forces with " & _joinPlayer, me);

	setState(stJoiningForces);
	enemy = _joinPlayer;
	phase = phMoveToLoc;

	timeGuardPos = 0;		//reset countdown

	sendForceX = _x;
	sendForceY = _y;

	fillAttackers(numAttackersFromPriorty(false));

	msg("coming" , me, enemy);	//allyInThreat
}

//make sure group is going to the right place
function void coordinateSendMovement(int _sendX, int _sendY, int _range,
										int _order, GROUP _coordinateGr)
{
	local 	DROID 	_droid;
	local	int 	_bucket;

	_bucket = initIterateGroupCmd(_coordinateGr,true,true,true);
	_droid = iterateGroupCmd(_coordinateGr,_bucket);
	while(_droid != NULLOBJECT)
	{
		/* too far away and not going there */
		if(distBetweenTwoPoints(_sendX, _sendY, _droid.x, _droid.y) > _range)
		{
			if(_droid.orderx > 0)	//has move order
			{
				/* busy and going to wrong palce */
				if(distBetweenTwoPoints(_sendX, _sendY, _droid.orderx, _droid.ordery) > _range)	//don't touch if already on the way back
				{
					orderDroidLoc(_droid, _order, _sendX, _sendY);
				}
			}
			else if((_droid.order == DORDER_NONE) or (_droid.order == DORDER_GUARD))	//idle	//TODO: can be idle and have some other order
			{
				orderDroidLoc(_droid, _order, _sendX, _sendY);
			}
		}

		_droid = iterateGroupCmd(_coordinateGr,_bucket);
	}
}

//check if units reached destination, if yes, add to a different group
function bool checkReachedDestination(int _destX, int _destY, GROUP _toCheckGr,
										GROUP _toAddToGr, int _range)
{
	local	DROID	_droid;
	local	bool	_bNewReached;
	local	int 	_bucket;

	_bNewReached = false;

	_bucket = initIterateGroupCmd(_toCheckGr,true,true,false);
	_droid = iterateGroupCmd(_toCheckGr,_bucket);
	while(_droid != NULLOBJECT)
	{
		//Check if reached destination
		if(distBetweenTwoPoints(_destX, _destY, _droid.x, _droid.y) <= _range)
		{
			dbg("attacker reached", me);

			_bNewReached = true;		//new unit has reached the destination point

			if(_toCheckGr == sendAttackGr){
				selectDroid(_droid, FALSE);	//deselect since left sendAttackGr
			}

			//add droid to the destination group
			if(_droid.droidType == DROID_COMMAND){
				cmdGr[ cmdToIndex(_droid) ] = _toAddToGr;	//change commander group

				dbg("added commander " & cmdToIndex(_droid) & " to attackGr", me);
			}else{
				groupAddDroid(_toAddToGr, _droid);	//add to the new group
			}
		}

		_droid = iterateGroupCmd(_toCheckGr,_bucket);
	}

	return _bNewReached;
}

function void updateDrop()
{
	if(dead[enemy])
	{
		cancelState();	//have to cancel to unload units
	}

	updateDropPhase();
}

event coordinatePhases(inactive)
{
	local	int		_sendRange,_sendersOrder,_reachedDestinationRadius,_bucket;
	local	bool	_bStopped,_bReachedDestination;

	if(state == stNone)
		exit;	//attackers idling

	/* main stuff begins here */
	if((enemy < 0) and !defendingOil())
	{
		MsgBox(" " & me & " coordinatePhases() - no player set");
		exit;
	}

	/* Set radius of the destination point units can't go outside and order to give senders */
	_sendRange = (TILE * 6);
	_reachedDestinationRadius = REACHED_DEST_RANGE;	//Units have reached destination when they are within this range from the destination
	_sendersOrder = DORDER_SCOUT;
	if(state == stHelpingAlly)
	{
		_sendersOrder = DORDER_MOVE;		//don't waste time on the way
		_sendRange = sendHelpRange;			//give helpers move freedom to pursue attackers around ally's base
		_reachedDestinationRadius = sendHelpRange;		//Don't need to come as close, start helping defend sooner
	}
	else if(defendingOil())
	{
		_sendersOrder = DORDER_MOVE;
		_reachedDestinationRadius = REACHED_DEF_OIL_RANGE;
	}

	if((sendForceX <= 0) or (sendForceY <= 0))
	{
		if(state == stHelpingAlly)
			msg("I can't see your  base" , me, enemy);	//allyInThreat

		dbg("coordinatePhases - (sendForceX <= 0) or (sendForceY <= 0)", me);
		cancelState();
		exit;
	}

	/* drop phase */
	if(state == stDrop)
	{
		updateDrop();
		exit;
	}

	/* transport phase */
	if(state == stTransporting)
	{
		updateTransport();
		exit;
	}

	if(defending())
		exit;		//defenders are sent to defend automatically

	/* make sure sendAttackGr droids are going to the destination */
	coordinateSendMovement(sendForceX, sendForceY, _sendRange, _sendersOrder, sendAttackGr);

	/* don't drift too far away from the defend location if defending oil or joining forces */
	if(phase == phGuardingPos)
	{
		coordinateSendMovement(sendForceX, sendForceY, _sendRange, DORDER_SCOUT, attackGr);
	}

	/* add to attackGr when new sendAttackGr droids reached the destination point */
	if(checkReachedDestination(sendForceX, sendForceY, sendAttackGr, attackGr, _reachedDestinationRadius))
	{
		//New units have been added to the attackGr, assign any unassigned droids to commanders
		assignDroidsToBestCommandersFromGroup(attackGr, attackGr);
	}

	//check if we have to switch from phMoveToLoc to the next phase, if at least one uniz has reached destination
	_bReachedDestination = ((groupSizeCmds(attackGr,true,false,true) > 0) and (phase == phMoveToLoc));

	/* start action when first unit reached the destination point */
	if((state == stTakingOil) or (state == stAttacking)
		or (state == stHelpingAlly) or defendingOil())
	{
		if(_bReachedDestination)
		{
			dbg("MANAGE UNITS: reached destination !!!!!", me);
			phase = phAttackingLoc;
		}
	}
	/* start action when *most* of the units are there */
	else if(state == stJoiningForces)
	{
		if(phase == phMoveToLoc)
		{
			if(groupSizeCmds(attackGr,true,false,true) >= (groupSizeCmds(sendAttackGr,true,false,true) * 3))	//most of units arrived
			{
				msg("ok, i'm there" , me, enemy);
				timeGuardPos = maxTimeGuardPos;
				phase = phGuardingPos;
				//exit;				//must exit since vars are reset
			}
		}
	}

	/* Check if have to switch back to phMoveToLoc if no attackers left */
	if(((phase == phAttackingLoc) or (phase == phGuardingPos)) and
		(groupSizeCmds(attackGr,true,false,true) == 0))
	{
		dbg("no attackers, phase = phMoveToLoc !!!!!!!!", me);
		phase = phMoveToLoc;
		timeGuardPos = 0;		//reset the oil guarding time
	}


	/* Manage attack */
	if((state != stHelpingAlly) and ((phase == phAttackingLoc)
		or (phase == phGuardingPos)))	//we are at the destination, stHelpingAlly is handled in manageHelpAlly()
	{
		_bucket = initIterateGroupCmd(attackGr,true,true,true);
		droid = iterateGroupCmd(attackGr,_bucket);
		while(droid != NULLOBJECT)
		{
			//find a target to attack
			if(droid.weapon == weaponBB){
				findBBAttackBaseTarget(droid);
			}else{
				findAttackBaseTarget(droid, -1, -1, -1);
			}

			//attack enemy target
			if(retObj != NULLOBJECT){
				orderDroidObj(droid, DORDER_ATTACK, retObj);
			}

			//too far from attack location?
			//if( droidOrderIdle(droid) or !droidActionAttacking(droid) )
			if( droidOrderIdle(droid))
			{
				//set range
				if(objHasWeapon(droid)){
					range = objWeaponMaxRange(droid);
				}else{	//repairs etc
					range = (TILE * 8);
				}

				// allow to travel further away if attacking or repairing
				if(droidActionAttacking(droid) or droidActionDroidRepair(droid)){
					range = range + (TILE * 12);
				}

				if(distBetweenTwoPoints(droid.x, droid.y, sendForceX, sendForceY) > range)
				{
					//make sure it's not far away because going around a big ramp: check destination
					if( (droid.orderx == 0) or
						(distBetweenTwoPoints(droid.orderx, droid.ordery, sendForceX, sendForceY) > range) )	//not heading to the right location
					{
						dbg("too far from attack loc, send back", me);
						orderDroidLoc(droid, DORDER_SCOUT, sendForceX, sendForceY);
					}
				}
			}

			droid = iterateGroupCmd(attackGr,_bucket);
		}
	}

	/* check if lost enemy base or ally we are helping disallied */
	if(state == stHelpingAlly)	//will reveal territory if lost base, don't cancel attack here
	{
		if(not knowBase[enemy])		//no visible structures left for this player
		{
			//if(state == stHelpingAlly)
			//{
				msg("I don't see your  base" , me, enemy);	//allyInThreat
			//}

			dbg("coordinatePhases - not haveBase", me);
			stopAllyDefense();
			exit;
		}

		//did player disally while we are helping him?
		if(not ally[enemy])		//no visible structures left for this player
		{
			msg("backstabber!!!", me, enemy);	//allyInThreat
			breakAlliance(me, enemy);
			cancelAllyDefense();
			exit;
		}
	}
	else if(state == stTakingOil)
	{
		//see if it's hopeless to go on
		if((groupSizeCmds(sendAttackGr,true,false,true) +
			groupSizeCmds(attackGr,true,false,true)) < minOilAttackers)
		{
			dbg("TAKE OIL: little attackers left, cancel", me);

			taunt(enemy, TAUNT_FAILURE, 30);

			stopTakingOil();

			exit;
		}

		//see if we can stop guarding this oil resource already
		if(!_bStopped and (phase == phGuardingPos) and (timeGuardPos <= 0))		//guarding oil long enough
		{
			dbg("TAKE OIL: waiting time is up!!!!!!!!!!!!!", me);

			taunt(enemy, TAUNT_SUCCESS, 20);

			stopTakingOil();

			exit;
		}

		/* something went wrong or we failed */
		if(!_bStopped and tTakeOil <= 0)
		{
			dbg("TAKE OIL: takeoil timeout!!!!!!!!!!!!!", me);

			stopTakingOil();
			exit;
		}

		//check if we can cancel guarding oil since have defenses
		//if(numStructsByTypeInRange(me, me, REF_DEFENSE, sendForceX, sendForceY, (8 * 128)) >= 1)
/* 		if(!_bStopped and numFriendlyWeapStructsInRange(me, sendForceX, sendForceY,  (8 * 128), true) >= 1)	//also include ally's defenses
		{
			//if(numEnemyObjInRange(me, sendForceX, sendForceY, (8 * 128), FALSE) == 0)
			if(numEnemyWeapObjInRange(me, sendForceX, sendForceY, (8 * 128), false, true) == 0)
			{
				dbg("TAKE OIL: oil is well-defended, rtb!!!!!!!!!!!!!", me);
				stopTakingOil();
				exit;
			}
		} */

		//see if it's hopeless to go on
		if(!_bStopped and (groupSizeCmds(attackGr,true,false,true) +
			groupSizeCmds(sendAttackGr,true,false,true)) <
			numEnemyWeapObjInRange(me, sendForceX, sendForceY, (8 * 128), false, true))
		{
			dbg("TAKE OIL: they have more than us", me);

			taunt(enemy, TAUNT_FAILURE, 40);

			stopTakingOil();
			exit;
		}


		//see if we killed all defenses and can start guard oil countdown
		if(!_bStopped and (phase != phGuardingPos))	//not set yet
		{
			//if(numEnemyObjInRange(me, sendForceX, sendForceY, (8 * 128), FALSE) == 0)	//enemy derrick is destroyed and no enemy defenses left
			if(numEnemyWeapObjInRange(me, sendForceX, sendForceY, (8 * 128), false, true) == 0)
			{
				if(groupSizeCmds(attackGr,true,false,true) > 0)	//if we reached destination
				{
					taunt(enemy, TAUNT_SUCCESS, 40);

					dbg("TAKE OIL: no enemies, started guarding", me);
					timeGuardPos = maxTimeGuardPos;
					phase = phGuardingPos;
				}
			}
		}

		if(_bStopped)
		{
			if(canStartTakingOil() and (THROW_DICE <= CHANCE_COUNTER_OIL)) // enough units?
			{
				if(initializeStartTakingOil(sendForceX, sendForceY, MAX_COUNTER_OIL_DISTANCE))
				{
					exit;	// exit here if we started attacking enemy oil
				}
			}
		}

		if(_bStopped)
		{
			exit;
		}
	}
	else if(state == stJoiningForces)	//check if waited long enougn
	{
		/* see if we can stop waiting at joining pos already */
		if((phase == phGuardingPos) and (timeGuardPos <= 0))
		{
			dbg("JOIN FORCES: waiting time is up!!!!!!!!!!!!!", me);
			if(random(2) == 1)
			{
				msg("I'm going back" , me, enemy);
			}
			stopJoiningForces();
			exit;
		}
	}
	else if(defendingOil())
	{
		// sucess is handled in everySecEv()

		// see if it's hopeless to go on
		if((groupSizeCmds(sendAttackGr,true,false,true) +
			groupSizeCmds(attackGr,true,false,true)) < MIN_OIL_DEFENDERS)
		{
			dbg("DEFENDING OIL: little attackers left, cancel", me);

			taunt(enemy, TAUNT_POSSESSION_LOSS, 50);

			stopDefendingOil();
			_bStopped = true;
		}

		// see if we want to counter-oil
		if(_bStopped and (state == stNone))	// if idle
		{
			if(canStartTakingOil() and (THROW_DICE <= CHANCE_COUNTER_OIL)) // enough units?
			{
				if(initializeStartTakingOil(sendForceX, sendForceY, MAX_COUNTER_OIL_DISTANCE))
				{
					exit;	// exit here if we started attacking enemy oil
				}
			}
		}

		//must exit here, since stopped defending oil
		if(_bStopped)
		{
			exit;
		}
	}

	/* check if we can send reinforcements, use more units if state == stHelpingAlly */
	if(canSendReinf(state == stHelpingAlly))		//got enough
	{
		fillReinforcements(state == stHelpingAlly);
	}
}

function void saveExperience()
{
	if(not bLearn){return;}

	savePlayerAIExperience(me, FALSE);	//silent save

	timeSaveExperience = maxTimeSaveExperience;

	dbg("Saved AI Experience (*)", me);
}

/* Returns name of the passed group */
function string groupToString(GROUP _group)
{
	local	string	_sGroup;

	_sGroup = "Unknown";

	if(_group == defendGr){
		_sGroup = "defendGr";
	}else if(_group == buildGr){
		_sGroup = "buildGr";
	}else if(_group == sendAttackGr){
		_sGroup = "sendAttackGr";
	}else if(_group == scoutGr){
		_sGroup = "scoutGr";
	}else if(_group == enemyScoutGr){
		_sGroup = "enemyScoutGr";
	}else if(_group == vtolGr){
		_sGroup = "vtolGr";
	}else if(_group == attackGr){
		_sGroup = "attackGr";
	}else if(_group == defendRepairGr){
		_sGroup = "defendRepairGr";
	}
	return _sGroup;
}

function string droidToGroupName(DROID _droid)
{
	local	GROUP	_group;

	if(_droid.droidType == DROID_COMMAND){
		return groupToString( cmdGr[ cmdToIndex(_droid) ] );
	}

	return groupToString( _droid.group );
}

//---------------------------------------------------------
//Don't trigger experience callbacks too frequently
//---------------------------------------------------------
event everySecEv(inactive)
{
	local	float		_newCurResUrgency;

	// if our oil derrick was attacked, remember how long the attack lasts already,
	// to be able to judge if the derrick is really under attack or whether it was just
	// an enemy unit passing by and shooting at the derrick
/* 	if(tOilAttackBegin > 0){
		tOilAttackBegin++;		// remember how long it has been attacked already
	} */

	// if derrick under siege wasn't attacked for certain time, assume it wasn't under siege
	if((tLastOilAttack > 0) and
		(GAME_TIME_IN_SECS > (tLastOilAttack + MAX_TIME_OIL_NOT_ATTACKED)))
	{
		if(!defendingOil())
		{
			resetOilDefendCoords();

			dbg("derrick siege threat timed out", me);
		}
		else if(defendingOil())
		{
			// make sure threat is really gone
			if(numFriendlyWeapStructsInRange(me, sendForceX, sendForceY,  (8 * TILE), true) >= 1)
			{
				if(numEnemyWeapObjInRange(me, sendForceX, sendForceY, (8 * TILE), false, true) == 0)
				{
					taunt(enemy, TAUNT_SUCCESS, 70);

					stopDefendingOil();

					dbg("THREAT IS GONE - STOPPED DEFENDING OIL", me);
				}
			}
		}
	}



	if(watchWindowDebug == WATCH_DEBUG_CMDS)
	{
		setDebugMenuEntry("min/max trucks: " & minTrucks & "/" & maxTrucks , 6);
		setDebugMenuEntry("oil trucks: " & maxBuildOilTrucks, 7);
		setDebugMenuEntry("base/oil def: " & maxBaseDefenseTrucks & "/" & maxOilDefenseTrucks, 8);
		setDebugMenuEntry("st/ph/enemy/al: " & state & "/" & phase & "/" & enemy & "/" & alert, 9);

	 	setDebugMenuEntry("defendGr: " & groupSizeCmds(defendGr,true,false,false) & "/" & groupSizeCmds(defendGr,true,false,true) &
			"/" & numDefenders & "- cmd:" & groupSizeCmds(defendGr,false,true,false), 0);
		if(cmds[0] == NULLOBJECT)
		{
			setDebugMenuEntry("cmd0:" , 1);
		}else{
			setDebugMenuEntry("cmd0: " & cmds[0].group.members & "/" & cmdDroidMaxGroup(cmds[0]) & " - " & getDroidRank(cmds[0]) & " - " & droidToGroupName(cmds[0]) , 1);
		}
		if(cmds[1] == NULLOBJECT)
		{
			setDebugMenuEntry("cmd1:" , 2);
		}else{
			setDebugMenuEntry("cmd1: " & cmds[1].group.members & "/" & cmdDroidMaxGroup(cmds[1]) & " - " & getDroidRank(cmds[1]) & " - " & droidToGroupName(cmds[1])  , 2);
		}
		if(cmds[2] == NULLOBJECT)
		{
			setDebugMenuEntry("cmd2:" , 3);
		}else{
			setDebugMenuEntry("cmd2: " & cmds[2].group.members & "/" & cmdDroidMaxGroup(cmds[2]) & " - " & getDroidRank(cmds[2]) & " - " & droidToGroupName(cmds[2])  , 3);
		}
		if(cmds[3] == NULLOBJECT)
		{
			setDebugMenuEntry("cmd3:" , 4);
		}else{
			setDebugMenuEntry("cmd3: " & cmds[3].group.members & "/" & cmdDroidMaxGroup(cmds[3]) & " - " & getDroidRank(cmds[3]) & " - " & droidToGroupName(cmds[3])  , 4);
		}
		if(cmds[4] == NULLOBJECT)
		{
			setDebugMenuEntry("cmd4:" , 5);
		}else{
			setDebugMenuEntry("cmd4: " & cmds[4].group.members & "/" & cmdDroidMaxGroup(cmds[4]) & " - " & getDroidRank(cmds[4]) & " - " & droidToGroupName(cmds[4])  , 5);
		}

		//Display group of the selected droid
		setDebugMenuEntry("unit group:" , 6);
		InitEnumDroids(me, me);
		droid = EnumDroid();
		while(droid != NULLOBJECT)
		{
			if(droid.selected){
				setDebugMenuEntry("unit group: " & droidToGroupName(droid), 6);
				droid = NULLOBJECT;
			}else{
				droid = EnumDroid();
			}
		}
	}

	/* Update research urgency */
	_newCurResUrgency = fCurResUrgency + (fNumDefaultResearch - (float)numBusyByType(resFac));	//fMinResearch = average, find out far we are from the average now, remember we need to make more later if lower than fMinResearch currently
	//can only be set manually outside of the bounds!
	if(_newCurResUrgency > fMaxResUrgency)		//going outside of the highest boundry
	{
		if(_newCurResUrgency > fCurResUrgency){	//moving up
			_newCurResUrgency = fmax(fCurResUrgency,fMaxResUrgency);	//trim to the highest value or to fCurResUrgency, if it was set manually to a higher value than the high boundry
		}
	}
	else if(_newCurResUrgency < fMinResUrgency)		//going outside of the lowest boundry
	{
		if(_newCurResUrgency < fCurResUrgency){	//moving down
			_newCurResUrgency = fmin(fCurResUrgency,fMinResUrgency);	//trim to the lowest value or to fCurResUrgency, if it was set manually to a lower value than the low boundry
		}
	}

	fCurResUrgency = _newCurResUrgency;		//Update

	/* Update duration of current state */
	tState++;

	/* Update Reinforcement Countdown */
	if(reinfTime > 0)
		reinfTime = reinfTime - 1;

	/* lasSat rechargement */
	if((lasSatState[me] == lsRecharging) or (lasSatState[me] == lsRequesterWaitingRecharging))	//only recharge if we built lasSat already and are not recharged already (would reset waiting state)
	{
		tLasSat = tLasSat + 1;		//continue recharging
	}

	/* wait for allies' lassat to recharge */
	//if(lasSatState[me] == lsWaiting)
	if(tLasSatCountdown >= 0)		//if we turned on the countdown for something (!= off)
	{
		tLasSatCountdown = tLasSatCountdown - 1;
	}

	/* requester has fired, now we fire with a little delay for more effectiveness, must be fired here, because every sec is important for the sync */
/*
	if(lasSatState[me] == lsDelayedFiring)
	{
		if(tLasSatCountdown <= 0)
		{
			lasSatTarget = findLasSatTarget(lasSatEnemy);
			if(lasSatTarget != NULLOBJECT)
			{
				fireLasSat(lasSatTarget);
			}
		}
	}
*/


	if(helpTime > 0)
		helpTime = helpTime - 1;

	if(timeGuardPos > 0)
		timeGuardPos = timeGuardPos - 1;

	if(requestHelpTime > 0)
		requestHelpTime = requestHelpTime - 1;

	if(collectTime > 0)
		collectTime = collectTime - 1;

	if(timeNotifyEnemyInBase > 0)
		timeNotifyEnemyInBase = timeNotifyEnemyInBase - 1;

	if(tWaitAlliesDrop > 0)
		tWaitAlliesDrop = tWaitAlliesDrop - 1;

	if(tWaitLoadDrop > 0)
		tWaitLoadDrop = tWaitLoadDrop - 1;

	if(tSyncDrop > 0)
		tSyncDrop = tSyncDrop - 1;

	if(tTakeOil > 0)
		tTakeOil = tTakeOil - 1;

	if(timeSaveExperience > 0)
	{
		timeSaveExperience = timeSaveExperience - 1;

		if(timeSaveExperience <= 0)
		{
			saveExperience();
		}
	}

	if(notifyReadyAttackTime > 0)
	{
		notifyReadyAttackTime = notifyReadyAttackTime - 1;

		if(notifyReadyAttackTime == 0)	//remember countdown is finished
		{
			bNotifiedReadyAttack = TRUE;
			dbg("bNotifiedReadyAttack == TRUE", me);
		}
	}

	//store exrepience countdown for every player
	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(storeOilDefTime[_temp] > 0)
		{
			storeOilDefTime[_temp] = storeOilDefTime[_temp] - 1;
		}

		if(storeBaseDefTime[_temp] > 0)
		{
			storeBaseDefTime[_temp] = storeBaseDefTime[_temp] - 1;
		}

		if(allyOfferTime[_temp] > 0)
		{
			allyOfferTime[_temp] = allyOfferTime[_temp] - 1;
		}

		if(tRequestStatus[_temp] > 0)
		{
			tRequestStatus[_temp] = tRequestStatus[_temp] - 1;
		}

		if(tWaitPlayerReply[_temp] > 0)
		{
			tWaitPlayerReply[_temp] = tWaitPlayerReply[_temp] - 1;
		}

		_temp = _temp + 1;
	}

	tLastResearch++;	//will be reset by doResearch if research is not idle

	// notify allies if we are idle for certain amout of time
	// can't do that immediately when we become idle, since can switch
	// to some other state right after that - prevent flooding console
	// with state changes notifications
	if((state == stNone) and (GAME_TIME_IN_SECS > 10))	// skip startup
	{
		if(tState == 6)	// do only once per idle state
		{
			notifyIdle(false);
		}
	}
}

function bool checkFollowAttackRequest(int _attackRequester, bool _bHighPriorityTask)
{
	if(defending() or (state == stAttacking) or
		(state == stDrop) or (state == stTransporting) or
		((state == stHelpingAlly) and (enemy != _attackRequester)))
	{
		notifyStatus(_attackRequester);
		return(FALSE);
	}

	if(not haveTheoretilcallyMinAttackers(_bHighPriorityTask))
	{
		msg("let me get more units", me, _attackRequester);
		return(FALSE);
	}

	return(TRUE);
}

function bool isCurrentOrder(int _state, int _enemy)
{
	local int _dummy;	//FIXME
	_dummy = 0;
	return ((_state == state) and (enemy == _enemy));
}

function bool defending()
{
	return (state == stDefending);
}

function bool helpingAlly()
{
	return (state == stHelpingAlly);
}

function bool defendingOil()
{
	return (state == stDefendingOil);
}

function bool canAlly(int _player)
{
	if(allianceExistsBetween(_player ,me))
	{
		return(FALSE);		//already allied
	}

	/* check if attacked by this player */
	if(defending())
	{
		if(numPlayerWeapObjInRange(_player, me, baseX, baseY, baseRange + (5 * 128), false, true) > 5)	//attacking us
		{
			return(TRUE);
		}
	}

	if((state != stNone) and (enemy == _player))
	{
		return(FALSE);
	}

	/* check not allied to too many players already */
	if((numAllies(me) + 1) >= (multiPlayerMaxPlayers / 2))
	{
		return(FALSE);
	}

	return(TRUE);
}

//decide if last beacon was placed long ago
function bool beaconTimeout(int _player)
{
		if((tBeacon[_player] > 0) and (( tBeacon[_player] + tBeaconTimeout) < GAME_TIME_IN_SECS))	//not too long ago
		{
			return TRUE;	//this beacon is still 'fresh'
		}

		return FALSE;
}

function bool haveBeacon(int _player)
{
		if((tBeacon[_player] > 0) and (not beaconTimeout(_player)))
		{
			return TRUE;	//have beacon for this player
		}

		return FALSE;
}

function void makeAlliances()
{
	/* find closest player */
	temp = bestAlliancePlayer();
	if(temp == none)
	{
		temp = random(multiPlayerMaxPlayers);
	}

	if(temp == me){return;}
	if(allianceExistsBetween(me, temp)){return;}	//my ally
	if(allyOfferTime[temp] > 0){return;}		//offered already


	/* don't offer alliance to a player we are attacking */
	if((state != stNone) and (enemy == temp))
	{
		return;
	}

	doOfferAlliance(temp);
}

function void doOfferAlliance(int _alliancePlayer)
{
	allyOfferTime[_alliancePlayer] = maxAllyOfferTime;

	msg("ally?" , me, _alliancePlayer);
}

function int bestAlliancePlayer()
{
	//return	- closest enemy index
	retInt = none;

	_temp3 = 99999;
	_temp = 0;
	_temp4 = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(knowBase[_temp] and (not dead[_temp]) and (not allianceExistsBetween(me, _temp)) and (_temp != me))
		{
			if(allyOfferTime[_temp] <= 0)
			{
				if(not((state != stNone) and (enemy == _temp)))		//attacking him?
				{
					intOK[_temp4] = _temp;	//store this one
					_temp4 = _temp4 + 1;	//how many available

					_temp2 = distBetweenTwoPoints(baseX, baseY, curBase[_temp][0], curBase[_temp][1]);
					if(_temp2 < _temp3)
					{
						_temp3 = _temp2;
						retInt = _temp;		//remember closest
					}
				}
			}
		}

		_temp = _temp + 1;
	}

	if((_temp4 > 0) and (random(4) <= 1))	//found at least 1 and 50%
	{
		retInt = intOK[random(_temp4)];		//choose one of the available
	}


	return(retInt);		//return closest or random available
}

event allianceOffered(inactive)
{
	if(temp2 != me){exit;}	//offered not to me

	//if(DEBUG_MSG and (not isHumanPlayer(temp))){exit;}	//don't ally with AIs for now

	if(not canAlly(temp))		//shouldn't ally
	{
		exit;
	}

	doAlly(temp);
}

event droidSeen(inactive)
{
	//droid	- that was seen
	//obj	- who saw

	if(droid == NULLOBJECT)
	{
		exit;
	}

	if(not isVtol(droid))
	{
		exit;
	}

	if(not hasVTOLs[droid.player])
	{
		hasVTOLs[droid.player] = TRUE;

		dbg(getPlayerName(droid.player) & " got VTOLs", me);

		/* notify allies about enemy using VTOLs */
		if(not allianceExistsBetween(me, droid.player))
		{
			notifyPlayerHasVTOLs(droid.player);
		}
	}
}

event objectSeen(inactive)
{
	//obj	- what was seen
	//obj2	- who saw

	if((obj == NULLOBJECT) or (obj2 == NULLOBJECT))
	{
		exit;
	}

	if((obj.player > 7) or (obj2.player > 7))	//skip scavengers
	{
		exit;
	}

	/* ignore walls and defenses */
	if(obj.type == OBJ_STRUCTURE)
	{
		_structure = objToStructure(obj);

		temp = getStructureType(_structure);
		if((_temp == 7) or (_temp == 8) or (_temp == 6) or (_temp == 6))	//wall, cornerwall, defense, rearm
		{
			exit;
		}
	}

	if(dead[obj.player])	//if we thought he was dead
	{
		rememberPlayerIsAlive(obj.player);

		//dbg("saw player " & obj.player & "'s object at " & (obj.x / 128) & " - " & (obj.y / 128), me);
		notifyPlayerAlive(obj.player);
	}
}

function void rememberPlayerIsAlive(int _alivePlayer)
{
	if(gameTime < 200){return;}	//engine bugs at startup

	dbg(getPlayerName(_alivePlayer) & " IS ALIVE!!!!!!!!!+++++++++++", me);

	dead[_alivePlayer] = FALSE;
	killedBase[_alivePlayer] = FALSE;
}

function void doAlly(int _playerOffered)
{
	createAlliance(_playerOffered, me);

	ally[_playerOffered] = TRUE;
	allyOfferTime[_playerOffered] = 0;	//reset, when disally, can immediately offer alliance again

	if((state != stNone) and (enemy == _playerOffered))
	{
		stopState();	//stop if were attacking him
	}

	/* Request help if in danger */
	if(state != stNone)
	{
		notifyStatus(_playerOffered);
	}
}

function void buildAA()
{
	best = findBestAA();
	if(best == none){return;}

	range = MAX_BASE_PERIM_AA_DEF;	//too many on spot range

	temp = 0;
	while(temp < multiPlayerMaxPlayers)
	{
		if(!allianceExistsBetween(me, temp))
		{
				if(knowBase[temp] and !dead[temp] and hasVTOLs[temp])	//found his base and saw him using VTOLs
				{
					/* project enemy base to base perimeter */
					x = curBase[temp][0];	y = curBase[temp][1];
					circlePerimPoint(baseX, baseY, ref x, ref y, aaRange);

					/* make sure not too many AA defenses at that spot already */
					if(numAAinRange(me, me, x, y, range) < MAX_BASE_PERIM_AA_DEF)
					{
						buildX = x;	buildY = y;
						/* make sure we can build and won't be built too far away from orig loc */
						if(!pickStructLocation(AA[best], ref buildX, ref buildY, me))
						{
							return;
						}

						if(distBetweenTwoPoints(buildX, buildY, x, y) > range)	//build loc moved too far away
						{
							return;	//original site was probably blocked, don't build too far away from orig site
						}

						/* it worked, build AA */
						buildOnMap(AA[best], buildX, buildY, 2);
					}
				}
		}
		temp++;
	}
}

function int findBestAA()
{
	//return	- defense index

	/* find best defense */
	_temp2 = none;
	_temp = 0;
	while(_temp < numAA)
	{
		if(isStructureAvailable(AA[_temp],me))
		{
			_temp2 = _temp;		//Best defense
		}
		_temp = _temp + 1;
	}

	return(_temp2);
}

event consoleEv(consoleTr)
{

	//turn on 'autogame'
	if(cstr == "autogame on" && (msgPlayer2 == me))
	{
		if(debugModeEnabled() && myResponsibility(me))
		{
			if(not bRunning)		//make sure current machine is responsible for this AI and it's not already active
			{
				console(getPlayerName(me) & " activated");
				mainInitialize();
			}
		}
	}

	//turn off 'autogames'
	if(cstr == "autogame off" && debugModeEnabled()  && (msgPlayer2 == me))
	{
		if(bRunning)		//make sure this AI is active
		{
			console(getPlayerName(me) & " deactivated");

			shutDown();
		}
	}

	if(not DEBUG_MSG){exit;}
	if(msgPlayer2 != me){exit;}

	if(strcmp(cstr, "/baserange"))
	{
		dbg("baseRange: " & (baseRange / 128), me);
	}
	else if(strcmp(cstr, "/request help"))
	{
		requestHelp();
	}
	else if(strcmp(cstr, "/defendcoord"))
	{
		dbg("x: " & (groupCMD_x(defendGr) / 128) & " y: " & (groupCMD_y(defendGr) / 128), me);
	}
	else if(strcmp(cstr, "/state"))
	{
		dbg("state: " & state, me);
	}
	else if(strcmp(cstr, "/phase"))
	{
		dbg("phase: " & phase, me);
	}
	else if(strcmp(cstr, "/stop"))
	{
		stopState();
	}
	else if(strcmp(cstr, "/cancel"))
	{
		cancelState();
	}
	else if(strcmp(cstr, "/numtrucks"))
	{
		_temp2 = numBuildersInProduction(me);
		_temp = groupSizeCmds(buildGr,true,false,true);
		dbg("Trucks: " & _temp & "/" & _temp2, me);
	}
	else if(strcmp(cstr, "/see enemy?"))
	{
		if(enemy >= 0)
			dbg("seeBase[" & enemy & "] = " & seeBase[enemy], me);

		if(enemy == none)
			dbg("no enemy", me);
	}
	else if(strcmp(cstr, "/addallylassat"))
	{
		_temp = 0;
		while(_temp < 8)
		{
			if(allianceExistsBetween(_temp ,me) and me != _temp)
			{
				x = curBase[_temp][0];
				y = curBase[_temp][0];
				if(pickStructLocation(lasSat, ref x, ref y, _temp))
				{
					addStructure( lasSat, _temp, x, y);
				}
			}
			_temp = _temp + 1;
		}
	}
	else if(strcmp(cstr, "/addlassat"))
	{
		x = baseX;
		y = baseY;
		if(pickStructLocation(lasSat, ref x, ref y, me))
		{
			addStructure(lasSat, me, x, y);
			lasSatState[me] = lsRecharging;
		}
	}
	else if(strcmp(cstr, "/numfacs"))
	{
		temp = getNumStructures(fac,me);
		dbg("num facs: " & temp, me);
	}
	else if(strcmp(cstr, "/numtransp"))
	{
		dbg("numTransporters: " & numTransporters, me);
	}
	else if(strcmp(cstr, "/transpstatus"))
	{
		_temp = transporterCapacity(transporter[0]);
		dbg("action: " & transporter[0].action & ", order: " & transporter[0].order & ", capacity :" & _temp, me);
	}
/*
	else if(strcmp(cstr, "/numres"))
	{
		_temp = numResearchLeft(me, resUnitTransporter);
		dbg("num res until transport: " & _temp, me);
	}
*/
	else if(strcmp(cstr, "/numrepprod"))
	{
		_temp = totalRepairersInProduction();
		dbg("repair units in production: " & _temp, me);
	}

	else if(strcmp(cstr, "/allystates"))
	{

		dbg("0: " & allyState[0], me);
		dbg("1: " & allyState[1], me);
		dbg("2: " & allyState[2], me);

		dbg("0: " & allyPhase[0], me);
		dbg("1: " & allyPhase[1], me);
		dbg("2: " & allyPhase[2], me);

		dbg("0: " & allyEnemy[0], me);
		dbg("1: " & allyEnemy[1], me);
		dbg("2: " & allyEnemy[2], me);
	}

	else if(strcmp(cstr, "/alert?"))
	{
		if(alert)
		{
			dbg("yes, alert", me);
		}
		else
		{
			dbg("no, no alert", me);
		}
	}
	else if(strcmp(cstr, "/takeoil"))
	{
		dbg("numTakeOil: " & numTakeOil & ", countTakeOil: " & countTakeOil, me);
	}
	else if(strcmp(cstr, "/sendForce"))
	{
		dbg("sendForceX: " & sendForceX / 128 & ", sendForceY: " & sendForceX / 128, me);
	}
	else if(strcmp(cstr, "/addpower"))
	{
		addPower(3000, me);
	}
	else if(strcmp(cstr, "/temp"))
	{
		count = 0;
		while(count <= 7)
		{
			//count2 = checkPlayerDead(count);
			dbg(getPlayerName(count) & " is dead = " & checkPlayerDead(count), me);
			count = count + 1;
		}
	}
	else if(strcmp(cstr, "/temp2"))	//4
	{
		count = 0;
		while(count <= 7)
		{
			dbg("knowBase " & getPlayerName(count) & " is = " & knowBase[count], me);
			count = count + 1;
		}
	}
	else if(strcmp(cstr, "/temp3"))	//0
	{
		count = 0;
		while(count <= 7)
		{
			dbg("seeBase " & getPlayerName(count) & " is = " & seeBase[count], me);
			count = count + 1;
		}
	}
	else if(strcmp(cstr, "/temp4"))	//-7
	{
		count = 0;
		while(count <= 7)
		{
			if(mapRevealedInRange(curBase[count][0],curBase[count][1], (2 * 128), me))
			{
				dbg("base revealed for " & count, me);
			}
			else
			{
				dbg("base not revealed for " & count, me);
			}
			count = count + 1;
		}
	}
	else if(strcmp(cstr, "/temp5"))
	{
		count = 0;
		while(count <= 7)
		{
			//count2 = canSeePlayer(count);		//can see any other objects?

			if(not canSeePlayer(count))
			{
				dbg("can't see " & getPlayerName(count), me);
			}
			else
			{
				dbg("can see " & getPlayerName(count), me);
			}
			count = count + 1;
		}
	}
	else if(strcmp(cstr, "/temp6"))	//0
	{
		count = 0;
		while(count <= 7)
		{
			dbg("dead " & count & " is = " & dead[count], me);
			count = count + 1;
		}
	}
	else if(strcmp(cstr, "/temp7"))	//0
	{
		count = 0;
		while(count <= 7)
		{
			if(allianceExistsBetween(count ,me))
			{
				MsgBox("dropBeacon for " & count);
				dropBeacon("help", count, me, baseX, baseY,0);
			}
			count = count + 1;
		}

	}
	else if(strcmp(cstr, "/fast"))
	{
		//maxTrucks = 4;
		//minTrucks = 2;

		numDefenders = 2;
		minAttackers = 3;
		numAttackers = 3;

		minReinforcements = 7;

		maxOilScouts = 1;

		numOilScouts = 1;

		dbg("FAST ATTACK MODE ON", me);
	}
	else if(strcmp(cstr, "/range on"))
	{
		//showRangeAtPos(baseX, baseY, baseRange + defendCorridor);
		if(sendForceX > 0)
		{
			if(helpingAlly()){
				showRangeAtPos(sendForceX, sendForceY, sendHelpRange);
			}else{
				showRangeAtPos(sendForceX, sendForceY, REINF_ENEMY_COUNT_RANGE);
			}
		}
	}
	else if(strcmp(cstr, "/save"))
	{
		saveExperience();
	}
	else if(strcmp(cstr, "/save"))
	{
		saveExperience();
	}
	else if(strcmp(cstr, "/range off"))
	{
		showRangeAtPos(sendForceX, sendForceY, -1);
	}
	else if(strcmp(cstr, "/msg on"))
	{
		dbgMsgOn(me, TRUE);
		console("turned on debug messages");
	}
	else if(strcmp(cstr, "/msg off"))
	{
		console("turned off debug messages");
		dbgMsgOn(me, FALSE);
	}
	else
	{
			/************************/
			/*	 offer 		*/
			/************************/
		temp2 = 0;
		while(temp2 < 8)
		{
			if(strcmp(cstr, "/offer " & temp2))
			{
				if(temp2 != me)
				{
					doOfferAlliance(temp2);
				}
				else
				{
					dbg("can't ally myself", me);
				}

				exit;
			}
			temp2 = temp2 + 1;
		}
	}

}

event beaconEv(inactive)
{
	local	int _players;
	local	string _processedString;

	if(msgPlayer >= 8)
	{
		MsgBox("beaconTr - msgPlayer >= 8");
		exit;
	}

	/* Get target players */
	_processedString = cstr;
	//_players = getTargetPlayers(ref _processedString);

	//dbg("beaconEv()!!!! = " & cstr & ", from " & msgPlayer, me);

	beaconX[msgPlayer] = x;
	beaconY[msgPlayer] = y;
	tBeacon[msgPlayer] = GAME_TIME_IN_SECS;	//remember when got this msg, so can make it timeout

	processCommand(cstr, msgPlayer, TRUE);
	//dbg("beaconEv()!!!! END = " & cstr & ", from " & msgPlayer, me);
}

event multiMsgEv(inactive)
{
	local	int _players;
	local	string _processedString;
	if(msgPlayer == me)
		exit;

	/* Get target players */
	_processedString = cstr;
//	_players = getTargetPlayers(ref _processedString);

	dbg(" " & me & " multiMsgEv() = " & cstr & ", from " & msgPlayer, me);

	//dbg("multiMsgEv() = " & cstr & ", from " & msgPlayer, me);

	/* See if sender was referring to us */
	processCommand(cstr, msgPlayer, FALSE);


	//dbg("processDebugCommand() start = " & cstr & ", from " & msgPlayer, me);
	//process debug messages
	if(DEBUG_COMMANDS)
	{
		processDebugCommand(msgPlayer, cstr);
	}
	//dbg("multiMsgEv() END = " & cstr & ", from " & msgPlayer, me);
}

function void processDebugCommand(int _msgPlayer, STRING _cstr)
{
	if(strcmp(_cstr, "stop"))
	{
		stopState();
	}
	else if(strcmp(cstr, "see enemy?"))
	{
		if(enemy >= 0)
			dbg("seeBase[" & enemy & "] = " & seeBase[enemy], me);

		if(enemy == none)
			dbg("no enemy", me);
	}
	else if(strcmp(_cstr, "status?"))
	{
		if(alert){msg("alert = TRUE" , me, _msgPlayer);}	//alert
		else{msg("alert = FALSE" , me, _msgPlayer);}

		if(lowMilitary){msg("lowMilitary = TRUE" , me, _msgPlayer);}	//lowMilitary
		else{msg("lowMilitary = FALSE" , me, _msgPlayer);}

		msg("power = " & playerPower(me) , me, _msgPlayer);	//power
		msg("state: " & state, me, _msgPlayer);
		msg("phase: " & phase, me, _msgPlayer);
		msg("numres: " & numBusyByType(resFac), me, _msgPlayer);
	}
	else if(strcmp(cstr, "range on"))
	{
		showRangeAtPos(baseX, baseY, baseRange + defendCorridor);
	}
	else if(strcmp(cstr, "range off"))
	{
		showRangeAtPos(baseX, baseY, -1);
	}
	else if(strcmp(cstr, "msg on"))
	{
		dbgMsgOn(me, TRUE);
	}
	else if(strcmp(cstr, "msg off"))
	{
		dbgMsgOn(me, FALSE);
	}
	else if(strcmp(_cstr, "num res?"))
	{
		msg("num res=" & numBusyByType(resFac), me, _msgPlayer);
	}
	else if(strcmp(cstr, "fast"))
	{
		numDefenders = 2;
		minAttackers = 3;
		numAttackers = 3;

		minReinforcements = 7;

		maxOilScouts = 1;

		numOilScouts = 1;

		dbg("FAST ATTACK MODE ON", me);
	}
	else if(strcmp(cstr, "numres"))
	{
		temp = numBusyByType(resFac);
		dbg("numres: " & temp, me);
	}
}

//function void processCommand(int _msgPlayer, STRING _cstr, bool _bBlipMessage, string _processedString, int _targetPlayers)
function void processCommand(string _message, int _sender, bool _bBlipMessage)
{
	local	int 		_numMsgs,_curMsg,_addressedPlayers,_x,_y,_player;
	local	string		_msg,_processedString;

	//dbg("processCommand(" & _message & ", " & _sender & ")", me);

	if(dead[_sender] and (multiPlayerAlliancesType != ALLIANCES_TEAMS)){	//if we thought he was dead and teams are off
		rememberPlayerIsAlive(_sender);
	}

	/* Extract semantic information */
	_curMsg = 0;
	_numMsgs = processChatMsg(_message);

	debug(me & ") processCommand: '" & _message & "' from " & _sender);
	dbg("processCommand: '" & _message & "' from " & _sender, me);
	dbg("got " & _numMsgs & " commands", me);

	if(_message == "are you aiv?" or _message == "are you aivolution?")
	{
		notifyAll("yes");
	}

	/* Process all messages */
	while(_curMsg < _numMsgs)
	{
		if(chatCmdIsPlayerAddressed(_curMsg, me))
		{
			dbg("i'm addressed", me);
			_msg = getChatCmdDescription(_curMsg);

			if(_msg == "ally me")
			{
				if(alliancesLocked())
				{
					return;
				}

				if(allianceExistsBetween(_sender ,me) and (random(2) == 1))
				{
					msg("already allied" , me, _sender);
				}

				if(not canAlly(_sender))		//shouldn't ally
				{
					if(random(2) == 1){msg("no" , me, _sender);}
					return;
				}

				msg("ok" , me, _sender);

				doAlly(_sender);
			}

			/* ally mesages only */
			if(not allianceExistsBetween(me , _sender))
				return;

			if(_msg == "go?")
			{
				allyState[_sender] = stNone;
				allyPhase[_sender] = phNone;
				allyEnemy[_sender] = none;

				/* tell him we are busy */
				if(not checkFollowAttackRequest(_sender, true))
				{
					return;
				}

				/* tell him we are ready */
				msg("where" , me, _sender);
			}
			if(_msg == "go center")
			{
				/* tell him we are busy */
				if(not checkFollowAttackRequest(_sender, true))
					return;

				/* cancel current state since not doing anything important */
				if(state != stNone)
					cancelState();

				joinForces(_sender, mapWidth*64,  mapHeight*64);		//to center

				return;
			}
			else if(_msg == "status?")
			{
				if(state == stNone)
				{
					notifyIdle(false);
				}
				else
				{
					notifyStatus(_sender);
				}
			}
			else if(_msg == "pumping units")
			{
				allyState[_sender] = stNone;
				allyPhase[_sender] = phNone;
				allyEnemy[_sender] = none;
			}
			else if(_msg == "stop")
			{
				if((state != stNone) and (enemy == _sender))
				{
					msg("ok" , me, _sender);
					stopState();
				}
			}
			else if(_msg == "got power?")
			{
				notifyPower(_sender);
			}
			//else if(strcmp(_msg, "cya"))	//player has lost
			//{
			//	if(allianceExistsBetween(me , _sender))
			//	{
			//		dead[_sender] = TRUE;
			//
			//		allyState[_sender] = stNone;
			//		allyPhase[_sender] = phNone;
			//		allyEnemy[_sender] = none;
			//	}
			//}
			else if(_msg == "go!")
			{
				/* tell him we are busy */
				if(not checkFollowAttackRequest(_sender, true))
					return;

				/* cancel current state since not doing anything important */
				if(state != stNone)
					cancelState();

				/* know location? */
				if(not haveBeacon(_sender))
				{
					if(random(5) == 0)
					{
						msg("I can't read your thoughts", me, _sender);
					}
					msg("drop a beacon", me, _sender);
					return;
				}

				joinForces(_sender, beaconX[_sender], beaconY[_sender]);		//not to center
				return;
			}

			else if(_msg == "help me")
			{
				allyState[_sender] = stDefending;	//remember he's in trouble
				allyEnemy[_sender] = none;
				allyPhase[_sender] = phNone;

				if(_bBlipMessage)	//processing message from blip
				{
					curHelpX[_sender] = x;
					curHelpY[_sender] = y;
				}

				/* got beacon msg and are already doing this command => just correct the coords */
				if(isCurrentOrder(stHelpingAlly, _sender))
				{
					if(_bBlipMessage)	//processing message from blip
					{
						updateStateCoord(beaconX[_sender], beaconY[_sender]);
						helpTime = maxHelpTime;		//reset help timeout timer

						if(random(2)==0)
						{
							msg("roger", me, _sender);
						}
						return;
					}
					else	/* if a message, not a blip */
					{
						helpTime = maxHelpTime;		//reset help timeout timer
						msg("I am!", me, _sender);
						return;
					}
				}

				if(state == stHelpingAlly)		/* busy with something else */
				{
					//msg("defending player " & enemy & " already", me, _sender);
					notifyStatus(_sender);
					return;
				}

				if(defending())
				{
					//msg("there're after me too, you better help me", me, _sender);	//TODO: temporal solution
					//msg("there're after me too", me, _sender);
					return;
				}

				temp = totalWeapUnits();
				if(temp < minAllyHelpers)
				{
					msg("have nothing", me, _sender);
					return;
				}

				if(curHelpX[_sender] <= 0)
				{
					msg("give vision", me, _sender);
					return;
				}

				if(state != stNone)
				{
					pauseState();		//resume when done helping
				}

				msg("coming, hold on", me, _sender);

				startHelpAlly(_sender, curHelpX[_sender], curHelpY[_sender]);
			}
			else if(_msg == "i'm ok")
			{
				allyState[_sender] = stNone;
				allyPhase[_sender] = phNone;
				allyEnemy[_sender] = none;

				if((state == stHelpingAlly) and (enemy == _sender))
				{
					msg("roger", me, _sender);
					stopAllyDefense();
				}

				/* remind allies we are in trouble */
				if(defending())
					requestHelp();
			}
			else if(_msg == "give vision")
			{
				giftRadar(me, _sender, FALSE);
			}
			else if(_msg == "can't see him")		//a reply after "go x"
			{
				//if(state == stAttacking)
				//{
				//	msg("go", me, _sender);		//just follow my units
				//}

				//todo: del
				//MsgBox("test");

				giftRadar(me, _sender, FALSE);
			}
			else if(_msg == "let's lassat someone")
			{
				lasSatState[_sender] = lsWaitingReply;

				if(lasSatState[me] == lsReady)
				{
					msg("ok", me, _sender);
					dbg("have a lassat requester********", me);
					lasSatState[me] = lsWaitingForRequester;	//join the strike
				}
				else if(lasSatState[me] == lsRecharging)	//tell him to wait, if we are almost finished recharging
				{
					if((tLasSatReady - tLasSat) < tLasSatWaitAlliesMax)	//not much left
					{
						lasSatState[me] = lsRequesterWaitingRecharging;
						msg("wait, lassat almost ready", me, _sender);
					}
				}
			}
			else if(_msg == "wait, lassat almost ready")
			{
				dbg("LASSAT: " & getPlayerName(_sender) & "has joined us********", me);
				lasSatState[_sender] = lsRequesterWaitingRecharging;	//remember ally is almost done recharging

			}
			else if(_msg == "lassat ready")
			{
				dbg("LASSAT: " & getPlayerName(_sender) & " waits for us********", me);
				lasSatState[_sender] = lsWaitingForRequester;	//remember ally is waiting for the requester to start lassat strike
			}
			else if(_msg == "defending my oil")
			{
				allyState[_sender] = stDefendingOil;
				allyPhase[_sender] = phMoveToLoc;
				allyEnemy[_sender] = none;
			}
			else
			{
					/************************/
					/*	 ally 		*/
					/************************/
				if(DEBUG_MSG)
				{
					temp2 = 0;
					while(temp2 < 8)
					{
						if(_msg == "ally " & temp2 & "!")
						{
							if(temp2 != me)
							{
								doAlly(temp2);
							}
							else
							{
								dbg("can't ally myself", me);
							}

							return;
						}
						temp2 = temp2 + 1;
					}
				}

					/*************************/
					/*        go player         */
					/*************************/

				//if(match(_processedString,"go <player>", ref _player))
				if((_msg == "attack player") and (getNumArgsInCmd(_curMsg) == 1))
				{
					//get player index
					if(getChatCmdParam(ref _player, _curMsg, 0))
					{
						dbg("*************go " & _player, me);

						if((_player == me) or (ally[_player]))
						{
							notifyAllies(getPlayerName(_player) & "???", false);
							return;
						}

						if(dead[_player])
						{
							notifyAllies(getPlayerName(_player) & " is dead", false);
							return;
						}

						/* got beacon msg and are already doing this command => just correct the coords */
						if(isCurrentOrder(stAttacking, _player))
						{
							if(_bBlipMessage)	/* processing beacon msg */
							{
								updateStateCoord(beaconX[_sender], beaconY[_sender]);
								if(random(2)==0)
								{
									notifyAllies("roger", false);
								}
								return;
							}
							else	/* if a normal msg, and we are already doind it, say so, since the destination can only be tweaked with a beacon */
							{
								notifyAllies("I am", false);
								return;
							}
						}		/* we are doing something else already */
						else if(not checkFollowAttackRequest(_sender, true))
						{
							return;
						}

						/* know location? */
						if(haveBeacon(_sender))
						{
							_x = beaconX[_sender];
							_y = beaconY[_sender];
						}
						else	/* no beacon provided, use the current enemy location */
						{
							if(killedBase[_player] and (not seeBase[_player]))	/* we have no idea where the enemy has rebuilt the base */
							{
								notifyAllies(getPlayerName(_sender) & ", drop a beacon", false);
								return;
							}
							else if(curBase[_player][0] > 0)	/* remember or can directly see it */
							{
								_x = curBase[_player][0];
								_y = curBase[_player][1];
							}
							else
							{
								notifyAllies(getPlayerName(_sender) & ", drop a beacon", false);
								return;
							}
						}

						/* cancel current state since not doing anything important */
						if(state != stNone)
						{
							cancelState();
						}

						if(killedBase[_player])
						{
							notifyAllies(getPlayerName(_sender) & ", ok, but haven't we destroyed " & getPlayerName(_player) & "'s base already?", false);
						}
						else
						{
							notifyAllies("ok" , false);
						}

						allyState[_sender] = stAttacking;
						allyEnemy[_sender] = _player;
						allyPhase[_sender] = phMoveToLoc;	//or phAttackingLoc

						offeredEnemy = _player;	//remember the offer

						startAttack(_player, _x, _y);
						notifyAllies("attacking " & getPlayerName(_player), TRUE);
						return;
					}
				}

					/*************************/
					/* 	going player	 */
					/*************************/

				//if(match(_processedString,"going <player>", ref _player))
				if((_msg == "attacking player?") and (getNumArgsInCmd(_curMsg) == 1))
				{
					//get player index
					if(getChatCmdParam(ref _player, _curMsg, 0))
					{
						dbg("*************going " & _player, me);

						allyState[_sender] = stAttacking;
						allyEnemy[_sender] = _player;
						allyPhase[_sender] = phMoveToLoc;	//or phAttackingLoc

						if(_player == me)
						{
							notifyAllies(getPlayerName(_sender) & ", you bastard!", false);
							breakAlliance(me, _sender);
							return;
						}

						if(ally[_player]){return;}		//just exit quietly

						if(dead[_player])
						{
							notifyAllies("isn't " & getPlayerName(_player) & " dead already?", false);
							return;
						}

						/* ignore if busy */
						if((state != stNone) and (enemy != _sender) and (phase != phGuardingPos))	//not idle and not dealing with this player somehow (defending etc) or psGuardingPos (is low prior)
						{
							return;			//just exit
						}

						/* also ignore if we are already attacking the SAME enemy, or "gonna take enemy derrick" msg is not gonna work properly */
						if(enemy == _player)
						{
							return;
						}

						if(not haveTheoretilcallyMinAttackers(true))
						{
							return;		//ignore
						}

						/* know location? */
						if(haveBeacon(_sender))
						{
							_x = beaconX[_sender];
							_y = beaconY[_sender];
						}
						else	/* no beacon provided, use the current enemy location */
						{
							if(killedBase[_player] and (not seeBase[_player]))	/* we have no idea where the enemy has rebuilt the base */
							{
								notifyAllies(getPlayerName(_sender) & ", drop a beacon", false);
								return;
							}
							else if(curBase[_player][0] > 0)	/* remember or can directly see it */
							{
								_x = curBase[_player][0];
								_y = curBase[_player][1];
							}
						}

						if(state != stNone)	//stop if dealing with the one who messaged
						{
							cancelState();
						}

						//enemy = _player;
						startAttack(_player, _x, _y);
						notifyAllies("attacking " & getPlayerName(_player), TRUE);
						return;
					}
				}

					/*****************************/
					/* 	x got VTOLs 	 */
					/*****************************/
				//if(match(_msg,"<player> got vtols", ref _player))
				if((_msg == "player has vtols") and (getNumArgsInCmd(_curMsg) == 1))
				{
					//get player index
					if(getChatCmdParam(ref _player, _curMsg, 0))
					{
						dbg("*************" & getPlayerName(_player) & " got vtols", me);

						if(random(2) == 0)
						{
							if(hasVTOLs[_player])
							{
								notifyAllies("I know", false);
							}
							else
							{
								notifyAllies("ok", false);
							}
						}

						hasVTOLs[_player] = TRUE;
						return;
					}
				}

					/*************************/
					/* 	take enemy oil x 	 */
					/*************************/

				//if(match(_processedString,"gonna get <player>'s derrick", ref _player))
				if((_msg == "getting player oil") and (getNumArgsInCmd(_curMsg) == 1))
				{
					//get player index
					if(getChatCmdParam(ref _player, _curMsg, 0))
					{
						dbg("*************gonna get " & getPlayerName(_player) & "'s derrick", me);

						allyState[_sender] = stTakingOil;
						allyEnemy[_sender] = _player;
						allyPhase[_sender] = phMoveToLoc;	//or phAttackingLoc

						if(_player == me)
						{
							notifyAllies(getPlayerName(_sender) & ", you bastard!", false);
							breakAlliance(me, _sender);
							return;
						}

						if(ally[_player])
							return;		//just exit quietly

						/* ignore if already attacking this enemy somehow */
						if(enemy == _player)
							return;

						if(dead[_player])
						{
							notifyAllies("isn't " & getPlayerName(_player) & " dead already?", false);
							return;
						}

						/* ignore if busy */
						if((state != stNone) and (enemy != _sender) and (phase != phGuardingPos))	//not idle and not dealing with this player somehow (defending etc) or psGuardingPos (is low prior)
						{
							return;			//just exit
						}


						/* do we want to attack enemy's oil? */
						if(random(10) <= 6)
						{
							/* do we have enough units to start start attacking enemy derrick alone? */
							if(haveTheoretilcallyMinAttackers(true))	/* don't need too many for the derrick, hence "true" */
							{
								/* find a derrick */
								structure = findEnemyDerrick(_player);	/* find enemy derrick to attack */
								if(structure != NULLOBJECT)
								{
									/* don't go on if we know where ally is attacking oil and this oil is too close to the derrick we have choosen to attack */
									if(not (haveBeacon(_sender) and distBetweenTwoPoints(beaconX[_sender], beaconY[_sender], structure.x, structure.y) < (25 * 128)))
									{
										cancelState();		//stop if doing anything unimportant

										startTakingOil(structure);
										notifyTakeOil(structure.player, structure.x, structure.y);
										return;
									}
								}
							}
						}

						/* didn't start attacking derrick, decide if we want (and can) to attack the base directly */
						if(knowBase[_player] and haveTheoretilcallyMinAttackers(false))
						{
							cancelState();	/* stop if doing anything unimportant */
							startAttack(_player, curBase[_player][0], curBase[_player][1]);
							dropAllyBeacon("attacking " & getPlayerName(_player), curBase[_player][0], curBase[_player][1]);
							notifyAllies("attacking " & getPlayerName(_player), TRUE);
							return;
						}

						return;
					}
				}
					/*************************/
					/* 	lassat player x 	 */
					/*************************/

				//if(match(_processedString,"lassat <player>", ref _player))
				if((_msg == "lassat player") and (getNumArgsInCmd(_curMsg) == 1))
				{
					//get player index
					if(getChatCmdParam(ref _player, _curMsg, 0))
					{
						dbg("*******lassat " & _player, me);

						/* remember he just lassatted */
						lasSatState[_sender] = lsRecharging;
						lasSatEnemy = _player;

						/* if we were waiting for him to start the attack, start delayed attack */
						if(lasSatState[me] == lsWaitingForRequester)
						{
							lasSatState[me] = lsDelayedFiring;
							tLasSatCountdown = 1 + (me * 9) + random(2);		//every ally (except for requester) fires with delay of at least 1 sec to be more effective (to finish damaged structures) (lassat delay == 8-9 sec)
						}
						return;
					}
				}

			}
			//else
			//{
			//	dbg("unknown message", me);
			//}
		}
		else
		{
			dbg("i'm not addressed", me);
		}
		_curMsg++;
	}

	//dbg("processCommand(" & _message & ", " & _sender & ") END------", me);
}

event	keyPressed(CALL_KEY_PRESSED, ref temp, ref temp2)
{
	//console("Key pressed: " & temp & ", meta key: " & temp2);
	if(DEBUG_MSG)
	{
		if (temp != KEY_ESC)
		{
			if(temp == KEY_SPACE)		//space
			{
				toggleDebugMenu();
			}
			else if(temp == KEY_D and temp2 == KEY_LCTRL)
			{
				dbg("Damaged selected object by 10%", me);
				InitEnumDroids(me, me);
				droid = EnumDroid();
				while(droid != NULLOBJECT)
				{
					if(droid.selected)
					{
						forceDamageObject(droid, 10);
					}
					droid = EnumDroid();
				}
			}

		}
	}

	if(DEBUG_ALL)
	{
		if(temp == KEY_P and (temp2 == KEY_RCTRL or temp2 == KEY_LCTRL))
		{
			addPower(1000, me);
			console("add power");
		}

		if(temp == KEY_N)
		{
			watchWindowDebug = modulo(watchWindowDebug + 1, 3);
		}
	}
}

function void toggleDebugMenu()
{
	debugMenuUp = not debugMenuUp;
	debugMenu(debugMenuUp);
}

/* Returns true if AI has all vital structures */
function bool haveMinimalStructures()
{
	local	int			_index;
	local	STRUCTURE	_structure;

	_index = 0;
	while(_index < numVitalStructs)
	{
		if( (getNumStructures(minimalStruct[_index], me) + numStatBusy(minimalStruct[_index], FALSE))
				< numMinimalStruct[_index] )
		{
			return FALSE;
		}
		_index++;
	}

	return TRUE;
}

function void checkMinimalStructures()
{
	local	int			_index,_maxTrucks,_maxStructsAtATime,_numStructsAtATime;
	local	bool		_bStartedBuild;
	local	STRUCTURE	_structure;
	local	FEATURE		_oil;

	_maxStructsAtATime = 2;
	_numStructsAtATime = 0;

	_index = 0;
	while((_index < numVitalStructs) and (_numStructsAtATime < _maxStructsAtATime))
	{
		if( (getNumStructures(minimalStruct[_index], me) +
			numStatBusy(minimalStruct[_index], false)) < numMinimalStruct[_index] )
		{
			//see how many trucks are allowed to build this structure
			_maxTrucks = maxVitalBuilders[_index];
			if(_maxTrucks == -1){
				_maxTrucks = groupSizeCmds(buildGr,true,false,true); //use all trucks
			}

			//if it's a derrick
			if(minimalStruct[_index] == derrick)
			{
				_oil = findBestOilToBuildOn(baseX, baseY, -1);

				if(_oil != NULLOBJECT){
					dbg("Building minimal base - oil", me);

					bDummy = buildUsingClosestTruck(derrick, _oil.x, _oil.y, _maxTrucks);	//Can skip "buildOnMap" for oil
				}
			}
			else
			{
				_bStartedBuild = buildInBase(minimalStruct[_index], _maxTrucks);

				if(_bStartedBuild){
					_numStructsAtATime++;

					dbg("Building minimal base " & _index, me);
				}
			}
		}
		_index++;
	}
}

function bool droidActionAttacking(DROID _droid)
{
	if(_droid.order == DORDER_ATTACK){
		return true;
	}

	if(_droid.action == DACTION_ATTACK or
	   _droid.action == DACTION_ROTATETOATTACK or
	   _droid.action == DACTION_MOVETOATTACK){
		return true;
	}

	return false;
}

function bool droidOrderIdle(DROID _droid)
{
	if(_droid.order == DORDER_NONE){
		return true;
	}

	if(_droid.order == DORDER_GUARD){
		return true;
	}

	if(_droid.order == DORDER_RTB){
		return true;
	}

	return false;
}

function bool droidActionDroidRepair(DROID _repairer)
{
	if(_repairer.action == DACTION_DROIDREPAIR){
		return true;
	}

	if(_repairer.action == DACTION_MOVETODROIDREPAIR){
		return true;
	}

	return false;
}

function int numVisibleOilResInRange(int _x, int _y, int _range)
{
	local	int			_numOil;
	local	FEATURE		_oil;

	initGetFeature(oilRes,me,me);
	_oil = getFeature(me);
	while(_oil != NULLOBJECT)
	{
		if((_range <= 0) or (distBetweenTwoPoints(_x, _y, _oil.x, _oil.y) < _range))
		{
			_numOil++;
		}
		_oil = getFeature(me);
	}

	return _numOil;
}

function int numDerricksInRange(int _targetPlayer, int _x, int _y, int _range)
{
	local	int				_numDerricks;
	local	STRUCTURE		_derrick;

	_numDerricks = 0;

	initEnumStruct(false,derrick,_targetPlayer,me);
	_derrick = enumStruct();
	while(_derrick != NULLOBJECT)
	{
		if((_range <= 0) or
			(distBetweenTwoPoints(_x, _y, _derrick.x, _derrick.y) < _range))
		{
			_numDerricks++;
		}
		_derrick = enumStruct();
	}

	return _numDerricks;
}

/* Returns total number (occupied and non-occupied) of oil resources that can be seen by a player */
function int numTotalOilInRange(int _x, int _y, int _range)
{
	return numVisibleOilResInRange(_x, _y, _range) +
			numDerricksInRange(me, _x, _y, _range);
}

function BASEOBJ closerObject(BASEOBJ _obj1, BASEOBJ _obj2, int _x, int _y)
{
	if(_obj1 == NULLOBJECT and _obj2 == NULLOBJECT){
		return _obj1;	//NULLOBJECT
	}

	if(_obj1 == NULLOBJECT){
		return _obj2;
	}

	if(_obj2 == NULLOBJECT){
		return _obj1;
	}

	if(distBetweenTwoPoints(_obj1.x, _obj1.y, _x, _y)
		< distBetweenTwoPoints(_obj2.x, _obj2.y, _x, _y))
	{
		return _obj1;
	}

	return _obj2;
}

// decide if we have to defend oil derrick
function void dealWithOilAttacked(int _oilx, int _oily)
{
	local	BASEOBJ		_oilLocation;

	if(isInMyBase(_oilx, _oily)){
		return;
	}

	// remember when oil derrick under attack was attacked last time
	if(tOilAttackBegin > 0)		// noticed some oil derrick being under attack
	{
		// check if same derrick was attacked again
		_oilLocation = closerObject(closestDerrick(_oilx, _oily),
					closestOilResource(_oilx, _oily), _oilx, _oily);

		if(_oilLocation != NULLOBJECT)
		{
			if(distBetweenTwoPoints(lastOilAttackedX, lastOilAttackedY,
				_oilLocation.x, _oilLocation.y) <= RANGE_ALL_OIL_DEFENSES)
			{
				// remember last time derrick under siege was attacked
				tLastOilAttack = GAME_TIME_IN_SECS;
			}
		}
	}

	// if it's a beginning of the attack, remember coordinates and when derrick was attacked
	if(tOilAttackBegin <= 0)
	{
		// find derrick in danger
		_oilLocation = closerObject(closestDerrick(_oilx, _oily),
					closestOilResource(_oilx, _oily), _oilx, _oily);

		// make sure found derrick is not too far away
		if(_oilLocation != NULLOBJECT)
		{
			if(distBetweenTwoPoints(_oilx, _oily, _oilLocation.x,
					_oilLocation.y) <= RANGE_ALL_OIL_DEFENSES)
			{
				tOilAttackBegin = GAME_TIME_IN_SECS;
				tLastOilAttack = GAME_TIME_IN_SECS;

				lastOilAttackedX = _oilLocation.x;
				lastOilAttackedY = _oilLocation.y;
			}
		}
	}

	// check if we have to defend attacked oil
	if((tOilAttackBegin > 0) and	// it wasn't just a random bullet, the derrick is really under siege
		(GAME_TIME_IN_SECS > (tOilAttackBegin + MIN_TIME_OIL_ATTACKED_DELAY)))
	{
		if(canStartDefendingOil())
		{
			if(checkOilThreat(lastOilAttackedX, lastOilAttackedY))
			{
				// start defending oil
				initializeStartDefeindingOil(lastOilAttackedX, lastOilAttackedY);
			}
		}
	}
}

function bool canStartDefendingOil()
{
	//if(!defendingOil() and !helpingAlly() and !defending())		// not busy
	if(state == stNone)		// not busy
	{
		if(numAvailableAttackers() >= MIN_OIL_DEFENDERS)
		{
			return true;
		}
	}

	return false;
}

function bool checkOilThreat(int _oilx, int _oily)
{
	local	int		_enemyForce,_allyForce,_range,_tankShootRange;

 	_range = CHECK_OIL_THREAT_RANGE;
	_tankShootRange = (TILE * 7);		//doesn't make sense to change state if we can reach it anyway

	// make sure derrick is not in the base or within base defend range
	if(distBetweenTwoPoints(_oilx, _oily, baseX, baseY) >
		(baseRange + defendCorridor + _tankShootRange))	//not near my base
	{
		if(!isNearEnemyBase(_oilx, _oily))
		{
			_enemyForce = enemyWeapObjCostInRange(me, _oily,
				_oily, _range, false, true);

			_allyForce = friendlyWeapObjCostInRange(me, _oilx,
				_oily, _range, false, true);

			// make sure enemy force is stronger
			if((_enemyForce - _allyForce) > 0)
			{
				return true;
			}
		}
	}

	return false;
}

function bool canStartTakingOil()
{
	//if(!defendingOil() and !helpingAlly() and !defending())		// not busy
	if(numAvailableAttackers() >= numOilAttackers){
		return true;
	}

	// if(state != stNone){		// busy
		// return false;
	// }

	return false;
}

function bool initializeStartTakingOil(int _oilx, int _oily, int _maxRange)
{
	local	STRUCTURE	_enemyDerrick;

	// cancel state if busy and not doing anything important
	if(state != stNone){
		cancelState();
	}

	_enemyDerrick = findBestEnemyDerrick(none, numAvailableAttackers(),
			sendForceX, sendForceY, _maxRange);

	if(_enemyDerrick == NULLOBJECT)
	{
		return false;
	}

	startTakingOil(_enemyDerrick);

	return true;
}

// make necessary calculations to be able to start defending oil derrick
function void initializeStartDefeindingOil(int _oilx, int _oily)
{
	local	int		_maxDefendingOilTime;

	_maxDefendingOilTime = distBetweenTwoPoints(_oilx, _oily,
		baseX, baseY) / TILE + MIN_DEF_OIL_TIME;

	dbg("OIL IS THREATENED AT " & (_oilx / TILE) & "/" &
		(_oily / TILE) & " (" & _maxDefendingOilTime & " secs)", me);

	// cancel state if busy and not doing anything important
	if(state != stNone){
		cancelState();
	}

	startDefendingOil(_oilx, _oily, _maxDefendingOilTime);
}

function void startDefendingOil(int _derrickX, int _derrickY, int _maxTime)
{
	dbg("DEFENDING OIL!!!!!!!!!!!!!!!!!!!!!!!!!!", me);

	enemy = none;

	sendForceX = _derrickX;
	sendForceY = _derrickY;
	// circlePerimPoint(_derrickX, _derrickY, ref sendForceX, ref sendForceY, (TILE * 4));

	if((sendForceX <= 0) or (sendForceY <= 0))
	{
		MsgBox("startDefendingOil() - sendForceX <= 0");
		exit;
	}

	setState(stDefendingOil);
	phase = phMoveToLoc;

	maxStateTime = _maxTime;

	// Set minimum number of defenders to leave in the base
	updateNumDefenders();

	dbg("defending oil at " & _derrickX & "/" & _derrickY & " !!!!!!!!!!!!!!!!!!!!!!!!", me);

	/* Assign attackers and commanders to groups */
	prepareAttackers(false);

	startMovePhase();

	dropAllyBeacon("defending my oil", sendForceX, sendForceY);
}

/* Returns how many friendly units will be left after some period of time, given starting forces and forces effectivenesses */
function float secondLanchasterLaw(float _fAllyStartForce, float _fEnemyStartForce,
									int _time,					//time in seconds that has to pass
									float _allyEffectiveness,
									float _enemyEffectiveness)
{
	local	float _sqrtDivEffect,		//square root from (ally effectiveness / enemy effectiveness)
				  _sqrtMultTimeEffect;	//time multiplied with square root from (ally effectiveness * enemy effectiveness)

	// number of force won't change if enemy can't attack or if there are no enemies
	if(_fEnemyStartForce == 0.0 or _enemyEffectiveness == 0.0){
		return _fAllyStartForce;
	}

	_sqrtDivEffect = sqrt(_allyEffectiveness / _enemyEffectiveness);
	_sqrtMultTimeEffect = sqrt(_allyEffectiveness * _enemyEffectiveness) * (float)_time;

	return 0.5 * (( _fAllyStartForce - _sqrtDivEffect * _fEnemyStartForce) * exp(_sqrtMultTimeEffect) +
				  (_fAllyStartForce + _sqrtDivEffect * _fEnemyStartForce) * exp(-_sqrtMultTimeEffect));
}

function bool LanchasterVictory(float _fStartForceA, float _fStartForceB,
								float _fKillRateA, float _fKillRateB)
{
	//ASSERT(!(_fStartForceB > 0 and _fKillRateB <= 0.0), "_fKillRateB can't be 0", me);

	// avoid division by zero
/* 	if(_fStartForceB <= 0 or _fKillRateB <= 0.0){
		return true;
	}

	// check if force A is going to win
	if( ((float)_fStartForceA / (float)_fStartForceB) > sqrt(_fKillRateA / _fKillRateB)){
		return true;
	} */

	//in case one of the sides has 0 units both kill rates will be 0.0
	if(_fKillRateA == 0.0 and _fKillRateB == 0.0)
	{
		if(_fStartForceA > 0.0 and _fStartForceB <= 0.0){
			return true;
		}else if(_fStartForceA <= 0.0 and _fStartForceB > 0.0){
			return false;
		}
	}

	if( (sqrt(_fKillRateA) * _fStartForceA) >= (sqrt(_fKillRateB) * _fStartForceB) ){
		return true;
	}

	return false;
}

/* How much time does it take for side A to win? */
function int LanchasterTimeToWin(float _fStartForceA, float _fStartForceB,
								float _fKillRateA, float _fKillRateB)
{
	local	float	_fTimeToWin,_fKillFactor;

	if(_fStartForceA <= 0.0 or _fStartForceB <= 0.0 or _fKillRateB == 0.0){
		return 0;
	}

	_fKillFactor = (_fStartForceB / _fStartForceA) *
					sqrt(_fKillRateA / _fKillRateB);

	// avoid division by 0
	if( (1.0 - _fKillFactor) == 0.0){
		return 0;
	}

	_fTimeToWin = 1.0 / (2.0 * sqrt(_fKillRateA * _fKillRateB)) *
				log ( (1.0 + _fKillFactor) / (1.0 - _fKillFactor) );

	return (int)_fTimeToWin;
}

// firepower of a droid (including upgrades)
function float objBaseDamagePerSec(BASEOBJ _obj)
{
	local	float	_fFirePowerPerSec,_fFireRatePerSec,_fShortRangeDamagePerSec,
					_fLongRangeDamagePerSec,_fReloadTime,_fFirePause;

	// Make sure droid has a weapon
	if(_obj.weapon == NULLSTAT){
		return 0.0;
	}

	debug(_obj.firePause & "," & _obj.reloadTime & "," & _obj.numRounds &
			"," & _obj.damage & "," & _obj.shortHit & "," & _obj.longHit);

	// avoid division by 0
	if(_obj.firePause == 0){
		_fFirePause = 0.001;
	}else{
		_fFirePause = (float)_obj.firePause;
	}

	if(_obj.numRounds > 0){

		// avoid division by 0
		if(_obj.reloadTime == 0){
			_fReloadTime = 0.001;
		}else{
			_fReloadTime = (float)_obj.reloadTime;
		}

		_fFireRatePerSec = (1.0 / (_fReloadTime / 10.0) + ((_fFirePause / 10.0) * (float)(_obj.numRounds - 1))) / (float)_obj.numRounds;
	}else{
		_fFireRatePerSec = 1.0 / (_fFirePause / 10.0);
	}

	_fShortRangeDamagePerSec = _fFireRatePerSec * ((float)_obj.damage / 100.0 * (float)_obj.shortHit);
	_fLongRangeDamagePerSec = _fFireRatePerSec * ((float)_obj.damage / 100.0 * (float)_obj.longHit);

	_fFirePowerPerSec = (_fShortRangeDamagePerSec + _fLongRangeDamagePerSec) / 2.0;

	return _fFirePowerPerSec;
}

function float enemyFirepowerInRange(int _x, int _y, int _range)
{
	local	int		_enemy;
	local	float	_fFirePower;

	_fFirePower = 0.0;
	_enemy = 0;
	while(_enemy < MAX_PLAYERS)
	{
		if(_enemy != me and !allianceExistsBetween(_enemy, me))
		{
			_fFirePower = _fFirePower + playerFirepowerInRange(_enemy, _x, _y, _range);
		}
		_enemy++;
	}

	return _fFirePower;
}

function float friendlyFirepowerInRange(int _x, int _y, int _range)
{
	local	int		_allyOrMe;
	local	float	_fFirePower;

	_fFirePower = 0.0;
	_allyOrMe = 0;
	while(_allyOrMe < MAX_PLAYERS)
	{
		if(_allyOrMe == me or allianceExistsBetween(_allyOrMe, me))
		{
			_fFirePower = _fFirePower + playerFirepowerInRange(_allyOrMe, _x, _y, _range);
		}
		_allyOrMe++;
	}

	return _fFirePower;
}

function float playerFirepowerInRange(int _player, int _x, int _y, int _range)
{
	local	float		_fFirePower;
	local	DROID		_droid;
	local	STRUCTURE	_structure;

	_fFirePower = 0.0;

	InitEnumDroids(_player,me);
	_droid = EnumDroid();
	while(_droid != NULLOBJECT)
	{
		if(!isVtol(_droid))
		{
			if(objHasWeapon(_droid))
			{
				if(distBetweenTwoPoints(_x, _y, _droid.x, _droid.y) < _range)
				{
					_fFirePower = _fFirePower + objBaseDamagePerSec(_droid);
				}
			}
		}
		_droid = EnumDroid();
	}

	//iterate through all strucrures
	initEnumStruct(TRUE,derrick,_player,me);
	_structure = enumStruct();
	while(_structure != NULLOBJECT)
	{
		if(objHasWeapon(_structure))
		{
			if(structureComplete(_structure))
			{
				if(distBetweenTwoPoints(_x, _y, _structure.x, _structure.y) < _range)
				{
					_fFirePower = _fFirePower + objBaseDamagePerSec(_structure);
				}
			}
		}
		_structure = enumStruct();
	}

	return _fFirePower;
}

function float groupFirepower(GROUP _group)
{
	local	int		_bucket;
	local	float	_fFirePower;
	local	DROID	_droid;

	_fFirePower = 0.0;

	_bucket = initIterateGroupCmd(_group,true,true,true);
	_droid = iterateGroupCmd(_group, _bucket);
	while(_droid != NULLOBJECT)
	{
		_fFirePower = _fFirePower + objBaseDamagePerSec(_droid);
		_droid = iterateGroupCmd(_group, _bucket);
	}

	return _fFirePower;
}

function float groupHP(GROUP _group)
{
	local	int		_bucket;
	local	float	_fDroidHP;
	local	DROID	_droid;

	_fDroidHP = 0.0;

	_bucket = initIterateGroupCmd(_group,true,true,true);
	_droid = iterateGroupCmd(_group, _bucket);
	while(_droid != NULLOBJECT)
	{
		_fDroidHP = _fDroidHP + (float)_droid.hitPoints;
		_droid = iterateGroupCmd(_group, _bucket);
	}

	return _fDroidHP;
}


function int totalEnemyWeapObjHPInRange(int _x, int _y, int _range, bool _bVtols)
{
	local	int		_enemy,_enemyHP;

	_enemyHP = 0;
	_enemy = 0;
	while(_enemy < MAX_PLAYERS)
	{
		if(_enemy != me and !allianceExistsBetween(_enemy, me))
		{
			_enemyHP = _enemyHP + totalPlayerWeapObjHPInRange(_enemy, _x, _y, _range, _bVtols);
		}
		_enemy++;
	}

	return _enemyHP;
}

function int totalFriendlyWeapObjHPInRange(int _x, int _y, int _range, bool _bVtols)
{
	local	int		_allyOrMe,_friendlyHP;

	_friendlyHP = 0;
	_allyOrMe = 0;
	while(_allyOrMe < MAX_PLAYERS)
	{
		if(_allyOrMe == me or allianceExistsBetween(_allyOrMe, me))
		{
			_friendlyHP = _friendlyHP + totalPlayerWeapObjHPInRange(_allyOrMe, _x, _y, _range, _bVtols);
		}
		_allyOrMe++;
	}

	return _friendlyHP;
}


function int totalPlayerWeapObjHPInRange(int _player, int _x, int _y,
										 int _range, bool _bVtols)
{
	local	int			_hp;
	local	DROID		_droid;
	local	STRUCTURE	_structure;

	_hp = 0;

	InitEnumDroids(_player,me);
	_droid = EnumDroid();
	while(_droid != NULLOBJECT)
	{
		if(!isVtol(_droid) or _bVtols)
		{
			if(objHasWeapon(_droid))
			{
				if(distBetweenTwoPoints(_x, _y, _droid.x, _droid.y) < _range)
				{
					_hp = _hp + _droid.hitPoints;
				}
			}
		}
		_droid = EnumDroid();
	}

	//iterate through all strucrures
	initEnumStruct(TRUE,derrick,_player,me);
	_structure = enumStruct();
	while(_structure != NULLOBJECT)
	{
		if(objHasWeapon(_structure))
		{
			if(structureComplete(_structure))
			{
				if(distBetweenTwoPoints(_x, _y, _structure.x, _structure.y) < _range)
				{
					_hp = _hp + _structure.hitPoints;
				}
			}
		}
		_structure = enumStruct();
	}

	return _hp;
}

function bool isTankTemplate(TEMPLATE _tmpl)
{
	local	int	_tmplIndex,_techIndex;

	_techIndex = 0;
	while(_techIndex < numBranches)
	{
		_tmplIndex = 0;
		while(_tmplIndex < numTemplates[_techIndex])
		{
			if(_tmpl == tmpl[_techIndex][_tmplIndex])
			{
				return true;
			}
			_tmplIndex++;
		}

		_techIndex++;
	}

	return false;
}

function void resetOilDefendCoords()
{
	tOilAttackBegin = none;		// when enemy started attacking oil derrick
	tLastOilAttack = none;
	lastOilAttackedX = none;	// position of the attacked oil derrick
	lastOilAttackedY = none;
}

event evUpdateMapRevealFactor(inactive)
{
	updateMapRevealFactor();
}

function void updateMapRevealFactor()
{
	local	int		_x,_y,_numUnrevealedTiles,_totalTiles,_step;

	_numUnrevealedTiles = 0;

	_step = 3;

	_x = 1;
	while(_x < (mapWidth - 1))
	{
		_y = 1;
		while(_y < (mapHeight - 1))
		{
			if(!mapTileVisible(me, _x,_y))
			{
				_numUnrevealedTiles++;
			}
			_y = _y + _step;
		}
		_x = _x + _step;
	}

	_totalTiles = mapWidth * mapHeight;

	fMapRevealFactor = MAP_REVEAL_FAC_UBOUND -
					(float)(_totalTiles - max(0, _numUnrevealedTiles * _step)) /
					(float)_totalTiles;
}

function DROID closestEnemyDroidByType(int _x, int _y, int _range, int _type)
{
	local	DROID	_droid,_closestDroid;
	local	int		_closestDist,_tempDist,_enemy;

	_closestDist = 99999;
	_closestDroid = NULLOBJECT;

	_enemy = 0;
	while(_enemy < MAX_PLAYERS)
	{
		if(!allianceExistsBetween(_enemy, me) and _enemy != me)
		{
			InitEnumDroids(_enemy, me);
			_droid = EnumDroid();
			while(_droid != NULLOBJECT)
			{
				if(_type < 0 or _droid.droidType == _type)
				{
					_tempDist = distBetweenTwoPoints(_droid.x, _droid.y, _x, _y);
					if(_range < 0 or _tempDist < _range)
					{
						if(_tempDist < _closestDist)
						{
							_closestDist = _tempDist;
							_closestDroid = _droid;
						}
					}
				}
				_droid = EnumDroid();
			}
		}

		_enemy++;
	}

	return _closestDroid;
}
