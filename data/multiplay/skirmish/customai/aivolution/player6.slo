
#define	MAX_PLAYERS				8
#define	MIN_COUNTERATTACKERS	6
#define	TILE					128


public	int				player,numLego,numTemplates,numBaseStructs,numDef,numRes[2],
						numGatewayDef,numAA,numRepairTmpl,maxDamageLevels,damageLevel[4],
						numBranches,techTanks,techAir,numVtolTemplates;
public	TEMPLATE		truck,tmpl[2][40],tmplOK[8],tmplBB,tmplRep[5],vtoltmpl[2][5];
public	STRUCTURESTAT	fac,derrick,powGen,vtolfac,resFac,powMod,facMod,resMod,legoSt[4],
						baseStructs[10],def[6],gatewayDef[6],wall,AA[5],HQ,uplink,lasSat;
public	STRUCTURESTAT	ArgStrStat0;	//is private
public	FEATURESTAT		oilRes,ArgFeatStat0;

public	RESEARCHSTAT	research[3][50],resBB;
public	BODY			viperBody;
public	WEAPON			weaponBB;

//-----------------------
// private vars

private	float		testFloat;
private	int		count,count2,count3,count4,result,result2,result3,result4,ArgInt0,ArgInt1,ArgInt2,
				ArgInt3,retInt,retInt2,_retInt,scoutX,scoutY,range,x,y;
private	int		temp,temp2,temp3,temp4,temp5,temp6,enemyScoutStep,enemyScoutX,enemyScoutY,
				enemyScoutRange,maxEnemyScouts,minEnemyScouts,numOilDef,minOilDef,
				tempX,tempY,numEnemyScouts,intOK[10],best,maxBaseDef,minBaseDef,
				numBaseDef,reinfTime,maxReinfTime,sendForceX,sendForceY,helpTime,
				maxHelpTime,state,stNone,stAttacking,stDefending,stHelpingAlly,stJoiningForces,
				stTakingOil,tState,timeGuardPos,maxTimeGuardPos,minOilAttackers,collectX,collectY,
				collectTime,maxCollectTime,stCollecting,numTakeOil,maxTakeOil,countTakeOil,
				lastState,lastEnemy,lastStateTemp,lastEnemyTemp,maxBaseEnemies,defendX,defendY,timeSaveExperience,
				maxTimeSaveExperience,tempResult,tempResult2,dist,dist2,dist3,defWeight,
				weightDistFactor,_dist,_dist2,tLastBaseDefense,maxInitialBaseDef,curInitialBaseDef,maxInitialDefSites,
				vstate,lastvState,counterEnemy;
private	bool	bResult,bResult2,bResult3,bTempResult,alert,bigMap,ally[8],
				bTemp,bTemp2,bEnemyScoutHor,bEnemyScoutToRight,
				bEnemyScoutToBottom,seeBase[8],noBaseTargets,haveBB,
				bLearn,knowBase[8],lowMilitary,DEBUG_ALL,DEBUG_MSG,DEBUG_OBSERVE,modifierOn,bNotifiedReadyAttack,
				ArgBool0,ArgBool1,hasVTOLs[8],_bResult,_bResult2,
				DEBUG_POWER,DEBUG_COMMANDS,dead[8],killedBase[8],bDummy,initialDefensesFinished,
				bFirstTimeDefenders,ghostDead[120],debugMenuUp,bRunning;

private	int		me,baseX,baseY,maxTrucks,minTrucks,buildX,buildY,maxBuildOilTrucks,
				unitLimit,maxResearch,minResearch,numDefaultResearch,noPower,lowPower,minFacs,
				minx,miny,maxx,maxy,baseSq,scoutRange,scoutStep,maxScouts,minScouts,
				maxOilDef,base[8][2],enemy,numAttackers,maxAttackers,minAttackers,
				numDefenders,threatRange,minSendUnits,curBase[8][2],numScouts,maxBB,
				numBB,minBB,addScout,addScoutInterval,baseRange,highPower,muchoPower,requestHelpTime,maxRequestHelpTime,
				notifyReadyAttackTime,maxNotifyReadyAttackTime,defensesRange,
				minOilRecallPrior,oilExperRange,defendCorridor,allyOfferTime[8],maxAllyOfferTime,
				aaRange,maxDefenseTrucks,timeNotifyEnemyInBase,maxTimeNotifyEnemyInBase,
				attackedCount,allyState[8],allyPhase[8],allyEnemy[8],minAllyHelpers,
				minDefenders,maxBaseDefenseLoc,maxBaseDefenseTrucks,
				lasSatState[8],lasSatEnemy,tLasSat,tLasSatReady,tLasSatCountdown,
				tLasSatReplyMax,tLasSatWaitAlliesMax,lsNone,lsRecharging,
				lsReady,lsRequesterWaitingRecharging,lsWaitingReply,
				lsDelayedFiring,lsWaitingForRequester,lsWaiting,lsFiring;

private	int		phase,phNone,phMoveToBase,phAttackingBase,phSearchingForBase,phCollecting,
				phGuardingPos,phLostBase,phRTB,storeOilDefTime[8],storeBaseDefTime[8],
				storeTime,none,off,allyInThreat,msgPlayer,msgPlayer2,offeredEnemy,
				phGettingTech,phGettingUnits,phWaitAllies,phLoadingTransport,
				phSendDrop,phTransportDone,tWaitAlliesDrop,tMaxWaitAlliesDrop,tWaitLoadDrop,
				tMaxWaitLoadDrop,numDroppers,numTransporters,stDrop,maxTransporters,
				transportX,transportY,savedState,savedPhase,savedEnemy,stTransporting,
				reinfCount[8],tRequestStatus[8],tMaxRequestStatus,tWaitPlayerReply[8],tMaxWaitPlayerReply,
				maxDroppers,medDroppers,minDroppers,tSyncDrop,tMaxSyncDrop,dropStartTime,phSync,maxAllyDroppers,
				attacked[8],minReinfCount,maxReinfCount,tempReinfCount[8],
				maxDefendRepairers,_x,_y,_result,_result2,tTakeOil,tMaxTakeOil,tech,tLastResearch,
				tMaxResearchIdle,numCriticalResearch, sendHelpRange;

private	int		_temp,_temp2,_temp3,_temp4,_range;
private	int		beaconX[8],beaconY[8],tBeacon[8],curHelpX[8],curHelpY[8],tBeaconTimeout,maxGhosts,
				ghostx[120],ghosty[120],curResUrgency,tResUrgencyTrackInterval,maxResUrgency,
				minResUrgency,structNoLiveHealth,maxResHold;


private DROID			droid,droid2,droid3,tempDroid,tempDroid2,ArgDroid0,retDroid,transporter[10],
						_droid,_droid2,initialDefensesTruck;
private	STRUCTURE		structure,structure2,tempStruct,ArgStruct0,retStruct,_structure,_structure2,
						lasSatTarget;
private GROUP			buildGr,defendGr,vtolGr,sendAttackGr,attackGr,scoutGr,enemyScoutGr,
						tempGr,ArgGr,ArgGr2,transportGr,defendRepairGr;
private FEATURE			feature,feature2,retFeature,tempFeature;
private BASEOBJ			obj,obj2,tempObj,retObj,baseDefendObj;
private STRING			cstr,sVer,myName;

private	STRUCTURESTAT	ghostStat[120];

trigger selftestTr			(every, 50);
trigger	doScoutTr			(every, 40);
trigger droidBuiltTr		(CALL_NEWDROID,me, ref droid,ref structure);
trigger	structBuiltTr		(CALL_STRUCTBUILT, me, ref droid, ref structure);
trigger structureAttackedTr	(CALL_STRUCT_ATTACKED, me, ref structure, ref obj);
trigger droidAttackedTr		(CALL_DROID_ATTACKED, me, ref droid, ref obj);
trigger	objectAttackedTr	(CALL_ATTACKED, me, ref obj, ref obj2);
trigger consoleTr			(CALL_CONSOLE, ref msgPlayer2, ref cstr);
trigger multiMsgTr			(CALL_AI_MSG, me, ref msgPlayer, ref cstr);
trigger transLandedTr		(CALL_TRANSPORTER_LANDED_B, tempGr, me, ref droid);
trigger beaconTr			(CALL_BEACON, me, ref msgPlayer, ref x, ref y, ref cstr);
trigger	droidTakeOverTr		(CALL_UNITTAKEOVER, ref droid);
trigger	defendBaseTr		(every, 42);
trigger	doResearchTr		(every, 52);
trigger	defendOilTr			(every, 60);
trigger	buildNormalOilDefensesTr	(every, 80);
trigger	scoutForEnemyTr			(every, 56);
trigger	everySecTr				(every, 10);
trigger	coordinatePhasesTr		(every, 56);
trigger	repairDefendDroidsTr	(every, 54);
trigger	diffModTr				(every,600);
trigger allianceOfferedTr		(CALL_ALLIANCEOFFER,ref temp, ref temp2);
trigger droidSeenTr				(CALL_DROID_SEEN, me, ref droid, ref obj);
trigger objectSeenTr			(CALL_OBJ_SEEN, me, ref obj, ref obj2);
trigger	checkLostTr				(every, 120);
trigger structDestroyedTr		(CALL_STRUCT_DESTROYED, me, ref structure);
trigger	buildStructureModelTr	(wait, 10);

//=====================================================================
//	event declarations
//=====================================================================
event	selftest;
event	doScout;
event	droidBuilt;
event	structBuilt;
event	structDestroyed;
event	structureAttacked;
event	droidAttacked;
event	objectAttacked;
event	everySecEv;
event	consoleEv;
event	multiMsgEv;
event	beaconEv;
event	droidTakeOverEv;
event	transLanded;
event	defendBase;
event	doResearch;
event	defendOil;
event	buildNormalOilDefenses;
event	scoutForEnemy;
event	coordinatePhases;
event	repairDefendDroids;
event	diffMod;
event	allianceOffered;
event	droidSeen;
event	objectSeen;
event	checkLost;
event	buildStructureModel;

//=====================================================================
//	function declarations
//=====================================================================
function void	initialize();
function void	showVersion();
function void	mainInitialize();
function void	storeBase();
function void	unassignedDroids(GROUP defendersGr, GROUP buildersGr);
function void	fixGroups();


function void	doEconomy();
function void	doMilitary();
function void	doMilitaryMisc();
function void	updateLasSat();
function void	resetLasSat();
function bool	allyLasSatReady();
function STRUCTURE	findLasSatTarget(int _prefferedEnemy);
function STRUCTURE	mostDamagedBaseStructure(int _targetPlayer);
function void	notifyLassat(STRUCTURE _targetStructure);
//function void	fireLasSat(STRUCTURE _targetStructure);
function bool	pendingLasSatStrike();
function void	economySelftest();
function void	baseDetails();
function void	militarySelftest();
function bool	needTrucks();
function void	buildTrucks();
function void	buildBaseStructs();

function void	checkPowerGen();
function void	checkOil(bool _bInBaseOnly);
function void	upgradeFacPow();
function void	upgradeVtolFac();
function void	upgradeResFac();
function void	finishStructures();
function void	repairStructures();
function void	groupRepairGroup(GROUP _damagedGr, GROUP _repairerGr);
function int	numRepairersInProduction();

function void	startEnemyScout();
function void	getNextScoutCoord(int _lastX, int _lastY);
function void	closerTruck();

function void	buildInBase(STRUCTURESTAT _statToBuild);
function void	buildOnMap(STRUCTURESTAT _statToBuild, int _buildX, int _buildY);
function DROID	closestIdleTruck(int _x, int _y);
function bool	buildUsingClosestTruck(STRUCTURESTAT _statToBuild, int _buildX, int _buildY);
function void	findClosestOilToBuildOn(int _lookx, int _looky, int _maxRange);
function STRUCTURE	findBestEnemyDerrick(int _targetPlayer, int _numAttackers);
function int	posWeight(int _owner, int _x, int _y, int _range);
function int	oilWeight(int _owner, int _x, int _y);

//Functions

function int	numStatBusy(STRUCTURESTAT _structureToCheck);	//On the way or already a certain building type
function int	numStatMoveBusy(STRUCTURESTAT _structStatToCheck);	//On the way
function int	numTrucksBuilding();		//Number of trucks currently building something
function int	numBusyByType(STRUCTURESTAT _busyStructType);			//Num of certain structures busy
function int	numBuildSameBuilding(STRUCTURESTAT _checkStat, int _x, int _y);
function int	numTrucksSameOrderLoc(int _x, int _y, int _orderIndex);
function int	numTrucksOrderInRange(int _rangex, int _rangey, int _range, int _order);		//How many are building near this loc
function int	numTrucksSameOrder(int _orderIndex);
function int	numBuildingDefenses();		//How many building defenses
function int	numBuildingBaseDefenses();
function int	numBuildingNoBaseDefenses();
function bool	buildingSiteBlocked(DROID _truck, int _radius, int _x, int _y);
function int	numDefenses();
function int	numBaseDefenses();
function bool	isInMyBase(int _checkX, int _checkY);	//tests if x,y coords are in the base
function bool	isNearAnyBase(int _x, int _y);			//check if point is near someone's base
function bool	isNearEnemyBase(int _x, int _y);
function bool	isNearOil(int _x, int _y);
function bool	isBaseStruct(STRUCTURE _checkStruct);			//TRUE if one of the base structure types (like factory)
function int	findResearch(int _searchStart, int _techTree);
function void	getClosestCorner(int _x, int _y);		//corner, closest to x,y
function void	closestDerrick(int _x, int _y);
function void	findFreeSpot(int _x, int _y);
function void	findFreeSpotSmall(int _x, int _y);
function void	findFreeSpotMedium(int _x, int _y);
function int	repairStructure(STRUCTURE _damagedStruct, int _maxRepairers);

function void	buildTanks();
function void	buildVTOLs();
function void	buildDefenses();
function void	buildInitialDefenses(bool _bForceBuild);
function void	stopInitialDefenses();
function void	buildAA();
function void	gatewayDefenses();

function void	checkBase(int _player);
function bool	findBase(int _targetPlayer);
function bool	canSeePlayer(int _player);
function bool	checkPlayerDead(int _player);
function void	findAlternateTarget();
function void	updateMilitaryStatus();
function int	chooseEnemy();
function bool	canStartAttack();
function bool	canTheoreticallyStartAttack();		//count current attackers as well
function bool	haveTheoretilcallyMinAttackers(bool _bSafeToSendLittleAttackers);		// have *any* attackers? (count current attackers as well)
function int	numAvailableAttackers();
function int 	numAttackUnits();
function int	totalDroids();
function void	checkStopAttack();
function void	doAttack();
function void	startAttack(int _enemy, int _x, int _y);
function void	vStartAttackBase(int _enemy);
//function void	vAttackBase(int _enemy);
function void	sortOutBBs();
function void	checkBaseThreat();
function int	checkAllyThreat();
function int	findAllyInTrouble();
function void	startHelpAlly(int _allyToHelp, int _helpx, int _helpy);
function void	startDefending(int _counterEnemy);
function void	startTakeOil(STRUCTURE _enemyDerrick);
function STRUCTURE	findEnemyDerrick(int _targetPlayer);
function void	manageHelpAlly();
function void	fillAttackers(bool _highPriorityTask);
function void	fillReinforcements(bool _bHelping);

function void	fillHelpers();

function int	findBestAA();
function int	findBestDefense();

function void	setCollectingLoc();
function void	startCollectingPhase();		//gather together
function void	startCollecting();		//gather together

function bool	enoughReinf(bool _forHelping);		//have enough units tosend reinf?
function void	coordinateSendMovement(int _sendX, int _sendY, int _range, int _order, GROUP _coordinateGr);
function void	checkReachedDestination(int _destX, int _destY, GROUP _toCheckGr, GROUP _toAddToGr, int _range);

function void	updateTransport();
function void	updateDropPhase();

function void	startMovePhase();
function void	startTransportState(GROUP _groupToTransport, int _destinationX, int _destinationY);

function void	stopState();
function void	stopJoiningForces();
function void	stopDefending();
function void	stopTakingOil();
function void	stopAttack();
function void	stopCollecting();
function void	stopAllyDefense();
function void	stopTransportState();
function void	stopDropState();

function void	cancelState();
function void	cancelJoiningForces();
function void	cancelDefending();
function void	cancelTakingOil();
function void	cancelAttack();
function void	cancelCollecting();
function void	cancelAllyDefense();
function void	cancelTransportState();
function void	cancelDropState();

function void	endJoiningForces();
function void	endDefending();
function void	endTakingOil();
function void	endAttack();
function void	endAllyDefense();
function void	endTransportState();
function void	endDropState();

function void	pauseState();
function void	resumeState();
function void	erasePausedState();

function void	loadSavedState();
function void	saveCurrentState();
function void	eraseLoadSavedState();

function bool	canStopCollecting();	//finished gathering or time is up
function bool	finishedCollecting();	//finished gathering

function void	doAlly(int _playerOffered);

function void	requestHelp();
function void	requestStatus(int _player);
function void	checkRequestStatus();
function void	requestStartAttack(int _enemy, int _x, int _y);
function void	requestPrepareDrop();
function void	dropAllyBeacon(STRING _cstr, int _x, int _y);
function void	notifyAllies(STRING _cstr, bool _bUpdateRadar);
function void	notifyReadyAttack();
function void	notifyTakeOil(int _enemy, int _x, int _y);
function void	notifyStatus(int _playerToNotify);
function void	notifyStatusAll();
function void	notifyPower(int _targetPlayer);
function void	notifyPlayerHasVTOLs(int _playerWithVTOLs);
function void	notifyEnemyAtBase();
function void	notifyPlayerDead(int deadPlayer);
function void	notifyPlayerBaseDestroyed(int _destroyedPlayer);
function void	notifyPlayerAlive(int _alivePlayer);
function void	notifyPrepareDrop();
function void	notifyStartDrop();
function void	notifyCantDrop();
function void	notifyLost();

function void	refreshAllyRadar();
function void	rememberPlayerIsAlive(int _alivePlayer);

function bool	checkFollowAttackRequest(int _attackRequester, bool _bHighPriorityTask);

function int	bestAlliancePlayer();
function void	makeAlliances();
function bool	canAlly(int _player);
function void	doOfferAlliance(int _alliancePlayer);

function void	findAttackBaseTarget(DROID _looker, int _x, int _y, int _radius);
function void	findBBAttackBaseTarget(DROID _looker);

function void	storeBaseDefLocEv();
function void	storeOilDefLocEv();

//function void	accessAttackGr();
//function void	accessBuildGr();

function void	deselectAllDroids();
function void	goRTB();
function void	saveExperience();

function bool	alliesReadyToDrop();
function bool	timeToDrop();
function int	numAlliesDroppingPlayer(int _player);
function int	numActiveEnemyDrop(int _enemyToCheck);
function int	getNumTransporters();
function bool	enoughTransporters();
function void	buildTransporters();
function bool	enoughDroppers();
function void	dropLoadTransport();
function void	orderTranspDisembark(DROID _transporter, int _coordx, int _coordy);
function int	chooseEnemyToDrop();
function void	fillDroppers();
function bool	transporterLoaded();
function bool	checkTransportersLanded();
function void	doDrop();
function void	startDropPhase();
function void	prepareTransporters();
function int	setNumDroppers();
function int	calcNumRequiredTransporters(int _numUnits);
function int	numDroidsLoaded();
function void	joinForces(int _joinPlayer, int _x, int _y);
function void	requestEnemy(int _toAskPlayer);
//function void	processCommand(int _msgPlayer, STRING _cstr, bool _bBlipMessage, string _processedString, int _targetPlayers);
function void	processCommand(string _message, int _sender, bool _bBlipMessage);
function void	processDebugCommand(int _msgPlayer, STRING _cstr);
function void	assignDroid(DROID _droid);
function bool	beaconTimeout(int _player);
function bool	haveBeacon(int _player);
function void	updateBeacons();
function bool	isCurrentOrder(int _state, int _enemy);
function void	updateStateCoord(int _newx, int _newy);
function void 	defendArea(GROUP	_defendGr, int _range, int _defendX, int _defendY, int _defendCorridor, int _minDefenders);
function DROID getTruckByTarget(BASEOBJ _target);
function bool 	lowOnPower();
function void 	setState(int _newState);
function void	vsetState(int _newState);
function void	toggleDebugMenu();
function void	shutDown();
function void	oneTimeInitialize();

/*%? Help1	=	"Always turn on 'multiplayer mode' is you are going to use Aivolution
 in multiplayer mode (more than 1 human player), otherwise you might get asyncs. \nBy turning on this option
 you prfunction void Aivolution AI from reacting to any messages it receives, hence it is not able to cooperate with its allies anymore.
 This is a temporary solution until this AI is multiplayer enabled." */

//=====================================================================
//	Events
//=====================================================================
event powerup(CALL_GAMEINIT)
{
	DEBUG_ALL = FALSE;

	DEBUG_MSG = DEBUG_ALL;		//isHumanPlayer(player);
								/*%!	ID="DEBUG_MSG",
								MainDesc="DEBUG messages",
								type="asn",		//Assign
								tmpl="YesNo"	*/
	DEBUG_OBSERVE = DEBUG_ALL;	/*%!	ID="DEBUG_OBSERVE",
								MainDesc="DEBUG observe mode",
								type="asn",		//Assign
								tmpl="YesNo"	*/
	DEBUG_POWER = FALSE;		/*%!	ID="DEBUG_POWER",
								MainDesc="DEBUG power",
								type="asn",		//Assign
								tmpl="YesNo"	*/

	DEBUG_COMMANDS = DEBUG_ALL;		/*%!	ID="DEBUG_COMMANDS",
								MainDesc="DEBUG commands",
								type="asn",		//Assign
								tmpl="YesNo"	*/

	modifierOn = TRUE;

	bLearn = TRUE;		//Use experience?
	sVer = "1.34";

	bRunning = FALSE;	//remember this AI is inactive

	me = player;

	myName = getPlayerColourName(me) & "-Aiv";

	dbgMsgOn(me, DEBUG_MSG);


	/* Check if this AI is inactive */
	groupAddArea(tempGr, player, 0, 0, (mapWidth*128), (mapHeight*128));
	structure = getStructure(fac, me);

	bResult = TRUE;
	if((tempGr.members == 0) and (structure == NULLOBJECT))
	{
		bResult = FALSE;
	}
	
	//do common one-time initialization only if this player is loaded
	if(bResult){
		oneTimeInitialize();
	}

	if(myResponsibility(me) and ((me != selectedPlayer) or DEBUG_OBSERVE))
	{
		if(bResult)	//alive?
		{
			mainInitialize();
		}
		else
		{
			dbg("deactivated", me);
		}
	}
	else
	{
		dbg("not my responsibility", me);
	}
}

//if we have no trucks and no facs, deactivate events
event checkLost(inactive)
{
	/* any base structures left? */
	temp = 0;
	while(temp < numBaseStructs)
	{
		tempStruct = getStructureVis(baseStructs[temp], me, me);
		if(tempStruct !=NULLOBJECT)
		{
			exit;		//yes, have a base structure
		}
		temp = temp + 1;
	}

	//if((getDroidCount(me) == 0) and (getStructure(fac, me) == NULLOBJECT))
	if((getDroidCount(me) == 0) and
	not (multiPlayerGameType == SKIRMISH and multiPlayerAlliancesType == ALLIANCES_TEAMS))
	{
		shutDown();
	}
}

/*
 * Deactivete this AI
  */
function void shutDown()
{
	bRunning = FALSE;	//remember this AI is inactive

	console(getPlayerName(me) & " deactivated");

	notifyPlayerDead(me);

	setEventTrigger(selftest, inactive);	//Start
	setEventTrigger(doScout, inactive);
	setEventTrigger(doResearch, inactive);
	setEventTrigger(defendOil, inactive);
	setEventTrigger(buildNormalOilDefenses, inactive);
	setEventTrigger(defendBase, inactive);
	setEventTrigger(structureAttacked, inactive);
	setEventTrigger(droidAttacked, inactive);
	setEventTrigger(everySecEv, inactive);
	//setEventTrigger(consoleEv, inactive);				//allow AI to re-activate itself again
	setEventTrigger(multiMsgEv, inactive);
	setEventTrigger(beaconEv, inactive);
	setEventTrigger(droidTakeOverEv, inactive);


	setEventTrigger(objectAttacked, inactive);
	setEventTrigger(coordinatePhases, inactive);

	setEventTrigger(allianceOffered, inactive);
	setEventTrigger(droidSeen, inactive);
	setEventTrigger(objectSeen, inactive);
	setEventTrigger(structBuilt, inactive);
	setEventTrigger(structDestroyed, inactive);
	setEventTrigger(checkLost, inactive);
	setEventTrigger(transLanded, inactive);
	setEventTrigger(repairDefendDroids, inactive);
	setEventTrigger(droidBuilt, inactive);

	dbg("DEACTIVATED SCRIPT!!!!!!!!!!!!!!!!!!", me);
}

function void goRTB()
{
	local int _x, _y;
	groupAddGroup(sendAttackGr, attackGr);

	if(sendAttackGr.members != 0)	//don't access sendAttackGr.x if no members
	{
		_x = sendAttackGr.x;	_y = sendAttackGr.y;

		circlePerimPoint(baseX, baseY, ref _x, ref _y, baseRange);	//move locations to the derrick perimeter

		orderGroupLoc(sendAttackGr, DORDER_MOVE, _x, _y);
	}

	groupAddGroup(defendGr, sendAttackGr);
}

/* Initialization for both AI and human player, to be performed once only */
function void oneTimeInitialize()
{
	/* only change name if not human */
	if(not isHumanPlayer(me))
	{
		setPlayerName(me, myName);
	}
	
	fixGroups();
	
	storeBase();		//remember base location
	
	if(bLearn)
	{
		loadPlayerAIExperience(me, TRUE);
	}
	
	bigMap = FALSE;
	if((mapWidth * mapHeight) > 14400)
	{
		bigMap = TRUE;
	}
	
	/* Initialize ghost structures data */
	maxGhosts = 120;
	count = 0;
	while(count < maxGhosts)
	{
		ghostStat[count] = NULLSTRUCTURESTAT;
		ghostx[count] = -1;
		ghosty[count] = -1;
		ghostDead[count] = TRUE;
		count  = count +1 ;
	}
	


	maxBaseEnemies = 22;
	storeTime = 120;	//in seconds, how long to wait until next store if the same function void can be triggered

	reinfTime = 0;		//last time we send reinforcements
	maxReinfTime = 420;	// > 6 min

	helpTime = 0;		//last time we send reinforcements
	maxHelpTime = 400;	// > 6 min

	timeGuardPos = 0;
	maxTimeGuardPos = 180;	//attackers wait at current pos

	tTakeOil = 0;
	tMaxTakeOil = 400;

	requestHelpTime = 0;
	maxRequestHelpTime = 180;	//3 min

	collectTime = 0;
	maxCollectTime = 150;

	timeNotifyEnemyInBase = 0;
	maxTimeNotifyEnemyInBase = 300;	//5 mins

	maxTimeSaveExperience = 120;	//2 mins
	timeSaveExperience = maxTimeSaveExperience;	//skip first time

	maxAllyOfferTime = 500;		//>7 min

	tWaitAlliesDrop = 0;
	tMaxWaitAlliesDrop = 420;	//7 mins

	tSyncDrop = 0;
	tMaxSyncDrop = 300;		//in secs

	tWaitLoadDrop = 0;
	tMaxWaitLoadDrop = 150;		//in secs

	tMaxRequestStatus = 550;	//randomized after every execution of requestStatus()

	tMaxWaitPlayerReply = 30;	//in secs

	tLastBaseDefense = 0;	//when started to build a base defense last time

	dropStartTime = none;

	minReinfCount = 3;		//accept drop request if send minReinfToDrop reinforcements to this enemy and he's still alive
	maxReinfCount = minReinfCount + random(4) + 2;		//consider dropping an enemy if can't get him by land

	maxTakeOil = 6;		//max take oil reids we can make
	countTakeOil = 0;
	numTakeOil = random(maxTakeOil);

	maxDefendRepairers = 5;

	defWeight = 18;		//defense weight for distance calculation
	weightDistFactor = 250;	//factor for derrick weight calculation (divided by distance)

	notifyReadyAttackTime = 0;
	maxNotifyReadyAttackTime = 8 + random(12);	//should be different for each AI
	bNotifiedReadyAttack = FALSE;

	maxTransporters = 9;
	


	count = 0;
	while(count < 8)
	{
		storeOilDefTime[count] = 0;
		storeBaseDefTime[count] = 0;
		allyOfferTime[count] = 0;
		count = count + 1;
	}


	maxTrucks = 8;
	minTrucks = 6;				//Critical number
	maxDefenseTrucks = 2;	//4;		//Trucks building defenses at a time
	maxBaseDefenseTrucks = 1;

	/* Set research limits */
	maxResearch = getStructureLimit(resFac, me);	//use all we can
	minResearch = 2;
	if(maxResearch <= 0)
		dbg("*************maxResearch = 0 *************", me);
	numDefaultResearch = minResearch;

	/* Research urgency - controls how many research facilities are put to work */
	tResUrgencyTrackInterval = (60 * 7);	//How 'deep' our memory frame is, in secs - trimmed after tResUrgencyTrackInterval secs
	//it will take tResUrgencyTrackInterval seconds for maxResearch idle research facilities to reach highestResearchUrgency value
	maxResUrgency = numDefaultResearch * tResUrgencyTrackInterval;		// We haven't done much research lately, but trim it to some max value
	minResUrgency = (-maxResUrgency);		//We've done alot research lately, can't go lower than this though
	maxResHold = numDefaultResearch * 60 * 4;		//Max time to hold all research, until it can be forced, in secs (numDefaultResearch num of res facs can wait 4 mins)
	curResUrgency = maxResHold + (60 * 8);		//In 'secs', Increases with time when research is idle - make urgent at the beginning

	structNoLiveHealth = 9;	//When to demolish structure if it's low on hitpoints, in %

	offeredEnemy = none;	//last player an ally offered us to attack

	counterEnemy = none;		//enemy that currently attacked us (used for counter attacks)

	noPower = 70;
	lowPower = 200;
	highPower = 900;
	muchoPower = 2500;
	alert = FALSE;		//Emergency
	lowMilitary = FALSE;
	minFacs = 3;

	baseSq = 0;			//base square
	baseRange = 0;
	aaRange = 0;			//prim where to build base aa

	defensesRange = (6 * 128);
	oilExperRange = (2 * 128);	//how far from derrick to build defenses when recalled the loc

	minScouts = 2;
	maxScouts = 3;

	addScout = 0;
	addScoutInterval = 3;	//Every addScoutInterval's unit for scouts

	scoutStep = (25 * 128);		//inacrease search area by this value
	scoutRange = scoutStep;		//start with small area

	enemyScoutX = none;
	enemyScoutY = none;

	enemyScoutStep = (18 * 128);

	maxOilDef = 5;		/*%!	ID="maxOilDef",
						MainDesc="max oil defenses",
						type="asn",		//Assign
						val="5",
						ArgDesc="5 (Default)",
						val="0",
						ArgDesc="0",
						val="3",
						ArgDesc="3",
						val="7",
						ArgDesc="7",
						val="10",
						ArgDesc="10"	*/

	numOilDef = maxOilDef;
	minOilDef = 3;	/*%!	ID="minOilDef",
						MainDesc="min oil defenses",
						type="asn",		//Assign
						val="3",
						ArgDesc="3 (Default)",
						val="0",
						ArgDesc="0",
						val="5",
						ArgDesc="5",
						val="7",
						ArgDesc="7",
						val="10",
						ArgDesc="10"	*/


	minOilRecallPrior = 3;		//ignore derricks with lower defend priority

	maxInitialBaseDef = 2;		//max defenses per defend site
	curInitialBaseDef = 1;		//current number of defenses per defend site (rises slowly with time)
	maxInitialDefSites = 4;

	maxBaseDef = 7;		/*%!	ID="maxBaseDef",
						MainDesc="max choke point defenses",
						type="asn",		//Assign
						val="7",
						ArgDesc="7 (Default)",
						val="0",
						ArgDesc="0",
						val="3",
						ArgDesc="3",
						val="10",
						ArgDesc="10",
						val="13",
						ArgDesc="13"	*/

	minBaseDef = 5;		/*%!	ID="minBaseDef",
						MainDesc="min choke point defenses",
						type="asn",		//Assign
						val="5",
						ArgDesc="5 (Default)",
						val="0",
						ArgDesc="0",
						val="3",
						ArgDesc="3",
						val="10",
						ArgDesc="10",
						val="13",
						ArgDesc="13"	*/

	numBaseDef = maxBaseDef;

	maxBaseDefenseLoc = 6;			//build at max 6 locations

	minOilAttackers = 12;			//min units required before can start taking oil

	scoutX = 0;
	scoutY = 0;

	phNone			= 0;
	phCollecting		= 1;
	phMoveToBase		= 2;
	phAttackingBase		= 3;
	phSearchingForBase	= 4;
	phGuardingPos		= 5;
	phLostBase		= 6;
	phRTB			= 7;
	phGettingTech		= 8;
	phGettingUnits		= 9;
	phWaitAllies		= 10;
	phLoadingTransport	= 11;
	phSync			= 12;	//Synchronizing with allies
	phSendDrop		= 13;
	phTransportDone		= 14;	//signal for drop phase that transport phase is done successfully
	
	
	stNone			= 0;
	stAttacking		= 1;
	stDefending		= 2;
	stHelpingAlly		= 3;
	stJoiningForces		= 4;
	stTakingOil		= 5;
	stCollecting		= 6;
	stDrop			= 7;
	stTransporting		= 8;
	
	threatRange = (10 * 128);

	maxBuildOilTrucks = 5;	//How many trucks are allowed to be building derricks at a time
	unitLimit = getUnitLimit(me);

	tBeaconTimeout = 30;	//in secs

	tLastResearch = 0;					//when we did last research
	tMaxResearchIdle = 2 * 60;	//max time to suspend research for, 2 mins, in secs
	numCriticalResearch = 1;	//min research facilities to put to work if we did no research for long time

	initialDefensesFinished = FALSE;	//if finished building anti-rush defenses

	bFirstTimeDefenders = TRUE;
	
	tech = none;
	
	lsNone = 0;
	lsRecharging = 1;
	lsReady = 2;			//recharged
	//lsFinishingRecharging = 3;	//will finish recharging lassat soon
	lsRequesterWaitingRecharging = 4;	//someone requested a lassat strike and is waiting for us to finish recharging lassat
	lsWaitingReply = 5;		//wait to find out if anyone wants to join
	lsWaitingForRequester = 6;	//we finished recharging our lassat and are now waiting for the requester to start the strike
	lsDelayedFiring = 7;	//requester firedand we are about to do a delayed fire
	lsWaiting = 8;			//waiting for allies to fire
	lsFiring = 9;

	tLasSat = 0;			//how much time left till tLasSatReady (till recharged)
	tLasSatReady = 300;	//300;		//how long takes to recharge (in secs)
	tLasSatCountdown = off;	//used for misc stuff
	tLasSatReplyMax = 6;
	tLasSatWaitAlliesMax = 45;	//wait max x secs for allies' lasSat to fully recharge
	
	//initialize enemy and ally information
	count = 0;
	while(count < 8)	//multiPlayerMaxPlayers)
	{
		/* las sat */
		lasSatState[count] = lsNone;	//finished charging etc

		base[count][0] = none;		//x
		base[count][1] = none;		//y

		curBase[count][0] = none;		//x
		curBase[count][1] = none;		//y

		hasVTOLs[count] = FALSE;

		knowBase[count]= FALSE;
		seeBase[count] = FALSE;

		ally[count] = FALSE;
		dead[count] = (not playerLoaded(count));	//FALSE;

		if(dead[count])
		{
			dbg(getPlayerName(count) & " (" & count & ") is not loaded", me);
		}

		killedBase[count] = FALSE;

		attacked[count] = 0;		//num times attacked by this player
		reinfCount[count] = 0;
		tempReinfCount[count] = 0;	//how many times we sent reinfs after the last time we dropped this enemy (tempReinfCount is reset everytime AI does a drop on a certain player and starts over)

		tRequestStatus[count] = tMaxRequestStatus + random(700);
		tWaitPlayerReply[count] = 0;

		allyState[count] = stNone;
		allyPhase[count] = phNone;
		allyEnemy[count] = none;

		curHelpX[count] = -1;
		curHelpY[count] = -1;

		//init beacon stuff
		beaconX[count] = -1;
		beaconY[count] = -1;
		tBeacon[count] = -1;	//time of the last beacon msg

		//recall players base location
		if(bLearn)
		{
			if(recallPlayerBaseLoc(me, count, ref x, ref y))	//if this location stored
			{
				if(x <= 0 or y <= 0)
				{
					MsgBox("x or y <= 0");
				}
				base[count][0] = x;		//x
				base[count][1] = y;		//y

				curBase[count][0] = x;		//x
				curBase[count][1] = y;		//y

				curHelpX[count] = curBase[count][0];	//where to go help
				curHelpY[count] = curBase[count][1];

				knowBase[count] = TRUE;

				dbg("recalled base location for " & getPlayerName(count), me);
			}
		}

		count = count + 1;
	}
	
	base[me][0] = baseX;
	base[me][1] = baseY;

	minAllyHelpers = 5;

	minDefenders = 5;	//min defenders to leave in base when helping ally

	//attack stuff
	numDefenders = 11;	/*%!	ID="numDefenders",
						MainDesc="min base defenders",
						type="asn",		//Assign
						val="11",
						ArgDesc="11 (Default)",
						val="0",
						ArgDesc="0",
						val="5",
						ArgDesc="5",
						val="20",
						ArgDesc="20",
						val="30",
						ArgDesc="30"	*/

	defendCorridor = (5 * 128);	//range which defenders can stay in (baseRange)
	
	minAttackers = 10;
	maxAttackers = 300;	//(unitLimit - maxTrucks - numDefenders) * 3 / 4;
	numAttackers = 12 + random(15) + minAttackers; //random(8) + minAttackers;

	minSendUnits = 18 + random(8);
	
	//drop stuff
	maxDroppers = 40;
	if(random(2) == 0)
	{
		maxDroppers = maxDroppers + 10;
	}
	medDroppers = max(maxDroppers / 2, minDroppers);
	minDroppers = 10;					//1 transporter

	maxAllyDroppers = 3 + random(2);		//no more than x players
	
	//Bunker Buster
	minBB = 1;
	maxBB = 8;
	numBB = maxBB;

	haveBB = FALSE;
	
	attackedCount = 0;		// how many times was attacked
	
	//adapt for big maps
	if(bigMap)
	{
		enemyScoutStep = (25 * 128);

		maxTrucks = maxTrucks + 3;
		minTrucks = minTrucks + 1;

		maxDefenseTrucks = maxDefenseTrucks + 1;

		minScouts = minScouts + 1;
		maxScouts = maxScouts + 3;
		scoutStep = scoutStep + 17;
		scoutRange = scoutStep;

		minSendUnits = minSendUnits + random(2) + 3;
	}

	numScouts = maxScouts;
}

function void mainInitialize()
{
	bRunning = TRUE;	//remember this AI is active

	initialize();		//assign variables
	showVersion();
	startEnemyScout();
	selftest();			//Misc stuff

	setEventTrigger(selftest, selftestTr);	//Start
	setEventTrigger(doScout, doScoutTr);
	setEventTrigger(doResearch, doResearchTr);
	setEventTrigger(defendOil, defendOilTr);
	setEventTrigger(buildNormalOilDefenses, buildNormalOilDefensesTr);

	setEventTrigger(defendBase, defendBaseTr);
	setEventTrigger(structureAttacked, structureAttackedTr);
	setEventTrigger(droidAttacked, droidAttackedTr);
	setEventTrigger(everySecEv, everySecTr);
	//setEventTrigger(consoleEv, consoleTr);
	setEventTrigger(multiMsgEv, multiMsgTr);
	setEventTrigger(beaconEv, beaconTr);
	setEventTrigger(droidTakeOverEv, droidTakeOverTr);



	setEventTrigger(objectAttacked, objectAttackedTr);
	setEventTrigger(coordinatePhases, coordinatePhasesTr);

	setEventTrigger(allianceOffered, allianceOfferedTr);
	setEventTrigger(droidSeen, droidSeenTr);
	setEventTrigger(objectSeen, objectSeenTr);
	setEventTrigger(structBuilt, structBuiltTr);
	setEventTrigger(structDestroyed, structDestroyedTr);
	setEventTrigger(checkLost, checkLostTr);
	setEventTrigger(transLanded, transLandedTr);
	setEventTrigger(repairDefendDroids, repairDefendDroidsTr);
	setEventTrigger(droidBuilt, droidBuiltTr);
	setEventTrigger(buildStructureModel, buildStructureModelTr);



	//if(me != selectedPlayer)
	if(modifierOn)
	{
		setEventTrigger(diffMod, diffModTr);
	}
}

event buildStructureModel(inactive)
{
	local	STRUCTURE		_structure;
	local	int				i,j;

	i = 0;

	initEnumStruct(TRUE,wall,me,me);
	_structure = enumStruct();
	while((_structure != NULLOBJECT) and (i < maxGhosts))
	{
		/* Remember initial walls and defenses */
		if((_structure.stat == wall) or (_structure.stattype == REF_DEFENSE))
		{
			ghostStat[i] = _structure.stat;
			ghostx[i] = _structure.x;
			ghosty[i] = _structure.y;
			ghostDead[i] = FALSE;
			i = i + 1;
		}

		_structure = enumStruct();
	}

	dbg("Model saved (" & i  & ")", me);
}

function void showVersion()
{
	console("Aivolution AI active for player " & me & " (version " & sVer & ")");	//show to the local player
}

function void storeBase()
{
	local	STRUCTURE _structure;
	
	//find HQ
	_structure = getStructure(HQ, me);
	
	if(_structure != NULLOBJECT)
	{
		baseX = _structure.x;
		baseY = _structure.y;
	}
	else
	{
		initIterateGroup(buildGr);		// find idle droids in build group.
		droid = iterateGroup(buildGr);

		if(droid != NULLOBJECT){
			baseX = droid.x;
			baseY = droid.y;
		}
		else{
			baseX = (128*mapWidth)/2;
			baseY = (128*mapHeight)/2;}
	}
}

function void fixGroups()
{
	InitEnumDroids(me,me);
	tempDroid = EnumDroid();
	while(tempDroid != NULLOBJECT)
	{
		droidLeaveGroup(tempDroid);
		tempDroid = EnumDroid();
	}
}

//---------------------------------------------------------
//	Initializations
//---------------------------------------------------------
function void initialize()
{
	//if(IGNORE_MESSAGES)
	//{
	//	console("multiplayer mode on for Aivolution " & me & " (cooperation off)");
	//}

	dbg("ACTIVE!!!", me);

	unassignedDroids(defendGr, buildGr);		//assign all dorids to an approriate group

	cstr = "empty";
	baseDefendObj = NULLOBJECT;

	none = (-1);
	off = (-1);

	debugMenuUp = FALSE;

	phase = phNone;


	setState(stNone);
	lastState = stNone;

	vsetState(stNone);		//vtol state
	lastvState = stNone;

	/* las sat stuff */
	lasSatEnemy = none;

	curBase[me][0] = baseX;
	curBase[me][1] = baseY;
	curHelpX[me] = curBase[me][0];	//where to go help
	curHelpY[me] = curBase[me][1];

	enemy = none;
	lastEnemy = none;

	noBaseTargets = TRUE;		//didn't find any targets yet

	sendForceX = none;		//where to send the sendAttackGr units
	sendForceY = none;

	transportX = none;
	transportY = none;

	defendX = none;
	defendY = none;

	collectX = none;		//where to gather forces
	collectY = none;

	//help ally stuff
	allyInThreat = none;		//what ally is in danger now?
	sendHelpRange = 18 * 128;	//range units should stay inside when helping ally in his base

	//dbg(" " & me & ")  Num attackers: " & numAttackers);
}

event diffMod(inactive)
{
	skDifficultyModifier(me);
}

//---------------------------------------------------------
//	Deal with basic stuff
//---------------------------------------------------------
event selftest(inactive)
{
	baseDetails();
	updateBeacons();
	doEconomy();
	doMilitary();
}

function void updateBeacons()
{
	count = 0;
	while(count < 8)
	{
		if(beaconTimeout(count))	//last beacon timed out
		{
			dbg("beacon timeout for " & count, me);

			tBeacon[count] = -1;

			beaconX[count] = -1;
			beaconY[count] = -1;

			curHelpX[count] = curBase[count][0];	//restore base and help location
			curHelpY[count] = curBase[count][1];
		}
		count = count + 1;
	}
}

//---------------------------------------------------------
//	Deal with basic economy stuff
//---------------------------------------------------------
function void doEconomy()
{
		//dbg(" " & me & ")  doEconomy");
	if(DEBUG_POWER and (playerPower(me) <= lowPower))
	{
		addPower(highPower, me);
	}

	closerTruck();

		//dbg(" " & me & ")  economySelftest");

	economySelftest();

		//dbg(" " & me & ")  buildTrucks");

	if(needTrucks())
		buildTrucks();

		//dbg(" " & me & ")  checkPowerGen");

	checkPowerGen();

		//dbg(" " & me & ")  repair");

	if((buildGr.members >= minTrucks) or (state == stDefending))		//don't send if low on trucks
	{
		repairStructures();
		finishStructures();
	}

		//dbg(" " & me & ")  upgradeFacPow");
	//if(not alert)
	//{
		upgradeFacPow();
	//}

	if(state == stDrop)		//give it a higher priority if going to drop
	{
		upgradeVtolFac();
	}

	//dbg(" " & me & ")  checkOil");

	/* Build derricks */
	if(not structureLimitReached(derrick, me))	//don't try if can't
	{
		checkOil( ((state == stDefending) and (buildGr.members <= minTrucks)) );	//don't go away from base if in danger and low on trucks
	}

	buildBaseStructs();

	if((not alert) and (state != stDrop))
	{
		upgradeVtolFac();
	}

	if(not alert)
	{
		upgradeResFac();
	}
		//dbg(" " & me & ")  END doEconomy()");
}

function void economySelftest()
{
	if(gameTime < 30)
		exit;	//wait until power is initialized

	bResult = alert;		//remember last state

	/* if base is in danger ignore anything else */
	if((playerPower(me) <= highPower) and (defendGr.members < numDefenders))
	{
		if(gameTime > 4200)
		{
			if(not bResult){dbg("economy - not enough defenders       (!!!!!)", me);}

			alert = TRUE;
			lowMilitary = TRUE;
		}
	}

	/* restet lowMilitary */
	if(lowMilitary)
	{
		if(defendGr.members >= numDefenders)
		{
			lowMilitary = FALSE;		//reset here
			alert = FALSE;
			dbg("lowMilitary back to normal (!!!!!)", me);
		}
	}

	if(lowMilitary)
		exit;		//don't reset alert until lowMilitary is back to normal

	/* set numOilDef */
	if(playerPower(me) >= lowPower)
	{
		numOilDef = maxOilDef;
		numBaseDef = maxBaseDef;
	}
	else if(playerPower(me) <= noPower)		//no power
	{
		numOilDef = minOilDef;
		numBaseDef = minBaseDef;
	}

	/* set alert and lowMilitary */
	if(playerPower(me) >= lowPower)			//high power, back to normal
	{
		alert = FALSE;
	}
	else if(playerPower(me) <= noPower)		//no power
	{
		if((buildGr.members <= minTrucks) and needTrucks())
		{
			alert = TRUE;
			if(not bResult){dbg("economy low on trucks       (!!!!!)", me);}
		}

		if(not alert)
		{
			if((getNumStructures(fac,me) <= minFacs) or (getNumStructures(powGen,me) == 0))
			{
				alert = TRUE;
				if(not bResult){dbg("economy low on vital structures       (!!!!!)", me);}
			}
		}

		//if(not alert)
		//{
			if((gameTime > 4200) and (defendGr.members < numDefenders))
			{
				alert = TRUE;
				lowMilitary = TRUE;
				if(not bResult){dbg("economy - not enough defenders       (!!!!!)", me);}
			}
		//}
	}

	if(bResult and (not alert))
	{
		dbg("Economy back to normal         !!!!!!", me);
	}
}

//---------------------------------------------------------
//	Base size
//---------------------------------------------------------
function void baseDetails()
{
	maxy = 0; maxx = 0;
	miny = (mapHeight*128); minx = (mapWidth*128);

	baseRange = 1;	//avoid possible div by 0
	aaRange = 1;

	count = 0;
	while(count < numBaseStructs)
	{
		initEnumStruct(FALSE,baseStructs[count],me,me);
		structure = enumStruct();
		while(structure != NULLOBJECT)
		{
			if(structure.x < minx){minx = structure.x;}
			if(structure.x > maxx){maxx = structure.x;}
			if(structure.y < miny){miny = structure.y;}
			if(structure.y > maxy){maxy = structure.y;}

			result = distBetweenTwoPoints(baseX, baseY, structure.x, structure.y);
			if(result > baseRange){baseRange = result;}

			structure = enumStruct();
		}
		count = count + 1;
	}

	result = 7 * 128;

	minx = minx - result; maxx = maxx + result;
	miny = miny - result; maxy = maxy + result;

	if(minx < 0){minx = 128;}
	if(miny < 0){miny = 128;}
	if(maxx > (mapWidth * 128)){maxx = (mapWidth * 128) - 128;}
	if(maxy > (mapHeight * 128)){maxy = (mapHeight * 128) - 128;}

	aaRange = baseRange + 128;		//between the base and baseRange

	baseRange = baseRange + (5 * 128);


	//baseSq = ((maxx - minx) / 128) * ((maxy - miny) / 128);
}

//---------------------------------------------------------
//	Prepare scouting routines
//---------------------------------------------------------
function void startEnemyScout()
{
	minEnemyScouts = 1;
	maxEnemyScouts = 1;

	numEnemyScouts = maxEnemyScouts;

	enemyScoutRange = (13 * 128);		//revealed when within this range

	bEnemyScoutHor	= TRUE;

	//only one of these is actually used, depending on bEnemyScoutHor
	bEnemyScoutToBottom = TRUE;
	bEnemyScoutToRight = TRUE;

	getClosestCorner(baseX, baseY);			//find corner we are closest to
	x = retInt; y = retInt2;

	if(not mapRevealedInRange(x,y,enemyScoutRange,me))
	{
		//make this the first place scouts will visit
		enemyScoutX = x; enemyScoutY = y;
		//dbg("can visit corner", me);
	}
	else
	{
		dbg("can't visit corner", me);
	}

	setEventTrigger(scoutForEnemy, scoutForEnemyTr);
}

function void finishStructures()
{
	initIterateGroupB(buildGr, me);
	droid = iterateGroupB(buildGr, me);
	while(droid != NULLOBJECT)
	{
		if((droid.order == DORDER_NONE) or (droid.order == DORDER_RTB))
		{
			//Check all base structures first
			//-------------------------------------
			result = 99999;
			structure2 = NULLOBJECT;

			count = 0;
			while(count < numBaseStructs)
			{
				initEnumStruct(FALSE,baseStructs[count],me,me);
				structure = enumStruct();
				while(structure != NULLOBJECT)
				{
					if(not structureComplete(structure))
					{
						//Find closest one
						result3 = distBetweenTwoPoints(baseX, baseY, structure.x, structure.y);
						if(result3 < result)
						{
							//Make sure no one's building already
							//result2 = buildingSiteBlocked(NULLOBJECT, 128, structure.x, structure.y);
							//if(result2 == 0)
							if(not buildingSiteBlocked(NULLOBJECT, 128, structure.x, structure.y))
							{
								structure2 = structure;
								result = result3;
							}
						}
					}
					structure = enumStruct();
				}
				count = count + 1;
			}

			//Check all
			//------------------------------
			if(structure2 == NULLOBJECT)
			{
				initEnumStruct(TRUE,fac,me,me);	//all
				structure = enumStruct();
				while(structure != NULLOBJECT)
				{
					if(not structureComplete(structure))
					{
						//Find closest one
						result3 = distBetweenTwoPoints(baseX, baseY, structure.x, structure.y);
						if(result3 < result)
						{
							//Make sure no one's building already
							//result2 = buildingSiteBlocked(NULLOBJECT, 128, structure.x, structure.y);
							//if(result2 == 0)
							if(not buildingSiteBlocked(NULLOBJECT, 128, structure.x, structure.y))
							{
								//check for threat, since can be far from the base
								if(not threatInRange(me, structure.x, structure.y, threatRange, FALSE))
								{
									structure2 = structure;
									result = result3;
								}
							}
						}
					}
					structure = enumStruct();
				}
			}

			//Build it
			if(structure2 != NULLOBJECT)
			{
				bDummy = buildUsingClosestTruck(structure2.stat, structure2.x, structure2.y);
			}


		}
		droid = iterateGroupB(buildGr, me);
	}

}
function bool enoughReinf(bool _forHelping)
{
	local int _numAvailable, _minSendUnits;

	_numAvailable = defendGr.members - numDefenders;	//use less units
	if(_forHelping)		//use more units if helping
	{
		_numAvailable = defendGr.members - minDefenders;	//leave only minimal number of derenders
	}

	_minSendUnits = minSendUnits;
	if(_forHelping)
		_minSendUnits = 5;	//If we wait for more units ally can get killed

	if((_numAvailable >= _minSendUnits) or ((_numAvailable >= _minSendUnits / 2) and (attackGr.members >= numAttackers / 2)) )	//enough reinf, or still many attackers and some reinf
	{
		return TRUE;
	}

	return FALSE;
}

//----------------------------------------------------------
//			stop state
//----------------------------------------------------------
function void stopState()
{
	if(state == stAttacking)
	{
		stopAttack();
	}
	else if(state == stDefending)
	{
		stopDefending();
	}
	else if(state == stHelpingAlly)
	{
		stopAllyDefense();
	}
	else if(state == stJoiningForces)
	{
		stopJoiningForces();
	}
	else if(state == stTakingOil)
	{
		stopTakingOil();
	}
	else if(state == stCollecting)
	{
		stopCollecting();
	}
	else if(state == stTransporting)
	{
		stopTransportState();
	}
	else if(state == stDrop)
	{
		stopDropState();
	}
	else if(state != stNone)
	{
		MsgBox("stopState() - unknown state");
	}
}

function void cancelState()
{
	if(state == stAttacking)
	{
		cancelAttack();
	}
	else if(state == stDefending)
	{
		cancelDefending();
	}
	else if(state == stHelpingAlly)
	{
		cancelAllyDefense();
	}
	else if(state == stJoiningForces)
	{
		cancelJoiningForces();
	}
	else if(state == stTakingOil)
	{
		cancelTakingOil();
	}
	else if(state == stCollecting)
	{
		cancelCollecting();
	}
	else if(state == stTransporting)
	{
		cancelTransportState();
	}
	else if(state == stDrop)
	{
		cancelDropState();
	}
	else if(state != stNone)
	{
		MsgBox("cancelState() - unknown state");
	}
}

function void endState()
{
	if(state == stAttacking)
	{
		endAttack();
	}
	else if(state == stDefending)
	{
		endDefending();
	}
	else if(state == stHelpingAlly)
	{
		endAllyDefense();
	}
	else if(state == stJoiningForces)
	{
		endJoiningForces();
	}
	else if(state == stTakingOil)
	{
		endTakingOil();
	}
	else if(state == stTransporting)
	{
		endTransportState();
	}
	else if(state == stDrop)
	{
		endDropState();
	}
	else if(state != stNone)
	{
		MsgBox("endState() - unknown state");
	}
}


function void pauseState()
{
	if(state == stNone){exit;}

	/* only stAttacking is paused, otherwise just stop doing what we were doing */
	if(state != stAttacking)
	{
		cancelState();
		exit;
	}		//only stAttacking for now

	dbg("PAUSING CURRENT STATE!!!!!!!!!!!!!!!!!!", me);

	/* cancelState() will reset enemy and stat, so remember now */
	lastStateTemp = state;
	lastEnemyTemp = enemy;

	cancelState();

	lastState = lastStateTemp;
	lastEnemy = lastEnemyTemp;
}

function void resumeState()
{
	if(lastState == stAttacking)
	{
		if((not allianceExistsBetween(lastEnemy ,me)) and knowBase[lastEnemy])
		{
			dbg("Resuming attack: at enemy: " & lastEnemy, me);

			groupAddGroup(defendGr, attackGr);
			groupAddGroup(defendGr, sendAttackGr);

			setState(lastState);

			//HACK resume with curBase[], actually must remember last attack x and y
			if(knowBase[lastEnemy])
			{
				startAttack(lastEnemy, curBase[lastEnemy][0], curBase[lastEnemy][1]);
				requestStartAttack(lastEnemy, curBase[lastEnemy][0], curBase[lastEnemy][1]);
			}
		}
	}

	/* clear vars */
	erasePausedState();
}

function void erasePausedState()
{
	lastState = stNone;
	lastEnemy = none;
}

function int findAllyInTrouble()
{
	_temp = 0;
	_temp2 = 99999;
	_temp4 = none;	//ally in trouble
	while(_temp < multiPlayerMaxPlayers)
	{
		if(ally[_temp] and (not dead[_temp]) and (allyState[_temp] == stDefending))
		{
			//if(knowBase[_temp])
			if(curHelpX[_temp] > 0)	//have help location
			{
				//_temp3 = distBetweenTwoPoints(baseX, baseY, curBase[_temp][0], curBase[_temp][1]);
				_temp3 = distBetweenTwoPoints(baseX, baseY, curHelpX[_temp], curHelpY[_temp]);
				if(_temp3 < _temp2)		//this ally is closer
				{
					_temp4 = _temp;
					_temp2 = _temp3;
				}
			}
		}
		_temp = _temp + 1;
	}

	return(_temp4);
}

//----------------------------------------------------------
//			stop defending
//----------------------------------------------------------
function void stopDefending()
{
	local	bool	_busy;

	_busy = FALSE;

	endDefending();

	dbg("DEFEND: stopped", me);

	/* If we were doing something before defending, resume it */
	if(lastState != stNone)
	{
		_busy = TRUE;
		resumeState();
	}

	/* now that we are ok, check if can help our ally, if someone's in trouble */
	if(not _busy)	//didn't resume state
	{
		temp = totalDroids();
		if(temp > minAllyHelpers)
		{
			temp = findAllyInTrouble();		//see if any of our allies is in trouble
			if(temp != none)
			{
				msg("coming now, hold on", me, temp);

				_busy = TRUE;

				startHelpAlly(temp,curHelpX[temp],curHelpY[temp]);
			}
		}
	}

	/* Return to base if idle */
	if(not _busy)
	{
		goRTB();
	}

	/* play cool
	if(random(2) == 0)
	{
		if(random(2) == 0){notifyAllies("they suck", TRUE);}
		else{notifyAllies("bwuhaha", TRUE);}
	}*/

	/* Check ally status */
	checkRequestStatus();
}

function void cancelDefending()
{
	erasePausedState();		//don't resume since cancelled

	endDefending();

	goRTB();

	dbg("DEFEND: cancelled defending", me);
}

function void endDefending()
{
	deselectAllDroids();

	setState(stNone);

	phase = phNone;
	enemy = none;
	counterEnemy = none;

	sendForceX = none;
	sendForceY = none;

	requestHelpTime = 0;

	/* reset notification stuff */
	bNotifiedReadyAttack = FALSE;
	notifyReadyAttackTime = 0;
}


//----------------------------------------------------------
//			stop taking oil
//----------------------------------------------------------
function void stopTakingOil()
{
	dbg("TAKE OIL: stopped", me);

	endTakingOil();

	/* If we were doing something before helping ally, resume it */
	if(lastState != stNone)
	{
		resumeState();
	}
	else
	{
		goRTB();
		checkRequestStatus();
	}
}

function void cancelTakingOil()
{
	erasePausedState();		//don't resume since cancelled

	endTakingOil();

	goRTB();

	dbg("TAKE OIL: cancelled", me);
}

function void endTakingOil()
{
	deselectAllDroids();

	setState(stNone);

	phase = phNone;
	enemy = none;
	sendForceX = none;
	sendForceY = none;

	timeGuardPos = 0;
	tTakeOil = 0;

	/* reset notification stuff */
	bNotifiedReadyAttack = FALSE;
	notifyReadyAttackTime = 0;
}

//----------------------------------------------------------
//			stop joining forces
//----------------------------------------------------------
function void stopJoiningForces()
{
	dbg("JOINING FORCES: stopped", me);

	endJoiningForces();

	/* If we were doing something before defending, resume it */
	if(lastState != stNone)
	{
		resumeState();
	}
	else
	{
		goRTB();
	}
}

function void cancelJoiningForces()
{
	erasePausedState();		//don't resume since cancelled

	goRTB();

	endJoiningForces();

	dbg("JOINING FORCES: cancelled", me);
}

function void endJoiningForces()
{
	deselectAllDroids();

	setState(stNone);

	phase = phNone;
	enemy = none;
	sendForceX = none;
	sendForceY = none;

	timeGuardPos = 0;	//reset

	/* reset notification stuff */
	bNotifiedReadyAttack = FALSE;
	notifyReadyAttackTime = 0;
}

//----------------------------------------------------------
//			stop ally defense
//----------------------------------------------------------
function void stopAllyDefense()
{
	endAllyDefense();

	dbg("stopped helping ally !!!!!!!!!!!!!!!!!!!!!!!!", me);

	/* If we were doing something before helping ally, resume it */
	if(lastState != stNone)
	{
		resumeState();
	}
	else
	{
		goRTB();
	}
}

function void cancelAllyDefense()
{
	erasePausedState();		//don't resume since cancelled

	endAllyDefense();

	goRTB();

	dbg("ALLY DEFENSE: cancelled", me);
}

function void endAllyDefense()
{
	deselectAllDroids();

	enemy = none;			//allyInThreat

	helpTime = 0;

	/* reset notification stuff */
	bNotifiedReadyAttack = FALSE;
	notifyReadyAttackTime = 0;

	setState(stNone);

	phase = phNone; //phRTB;

	sendForceX = none;
	sendForceY = none;
}

//----------------------------------------------------------
//			stop attack
//----------------------------------------------------------
function void stopAttack()
{
	endAttack();

	dbg("ATTACK: stopped", me);

	/* If we were doing something before attacking, resume it */
	if(lastState != stNone)
	{
		resumeState();
	}
	else
	{
		goRTB();
		checkRequestStatus();
	}
}

function void cancelAttack()
{
	erasePausedState();		//don't resume since cancelled

	endAttack();

	goRTB();

	dbg("ATTACK: cancelled", me);
}

function void endAttack()
{
	deselectAllDroids();

	setState(stNone);

	enemy = none;

	phase = phNone; //phRTB

	reinfTime = 0;	//timer

	countTakeOil = 0;		//allow hunting oil again

	/* reset notification stuff */
	bNotifiedReadyAttack = FALSE;
	notifyReadyAttackTime = 0;

	sendForceX = none;
	sendForceY = none;

	numTakeOil = random(maxTakeOil);	//allow attacking oil again
}

//--------------------------------------
//	Transport
//--------------------------------------
function void stopTransportState()
{
	endTransportState();	//first end then load otherwise endTransportState will reset state

	phase = phTransportDone;	//make sure drop state knows that transport finished successfully
	loadSavedState();
}

function void cancelTransportState()
{
	dbg("cancelTransportState", me);

	eraseLoadSavedState(); 	//since cancelled

	temp = 0;
	while(temp < maxTransporters)
	{
		if(transporter[temp] != NULLOBJECT)
		{
			//temp = isInMyBase(transporter[temp].x, transporter[temp].y);
			if((not transporterFlying(transporter[temp])) and isInMyBase(transporter[temp].x, transporter[temp].y))	//landed inside of the base
			{
				dbg("unloading transporter", me);
				unloadTransporter(transporter[temp], transporter[temp].x, transporter[temp].y);
			}
			else	//Send to unload in the base
			{
				dbg("ordering transporter to disembark in the base", me);
				orderTranspDisembark(transporter[temp], baseX, baseY);		//make unload units in the base
			}

		}
		temp = temp + 1;
	}

	notifyCantDrop();

	checkRequestStatus();

	deselectAllDroids();
	goRTB();			//only sends sendAttackGr home, not transportGr

	prepareTransporters();	//send transporters back to base

	endTransportState();

	enemy = none;		//must be done here, since not done in endTransportState()
}

function void endTransportState()
{
	dbg("endTransportState", me);

	groupAddGroup(defendGr, transportGr);	//return unloaded units to defenders or if state cancelled

	transportX = none;
	transportY = none;

	tWaitLoadDrop = 0;

	setState(stNone);
	phase = phNone;

	//enemy = none;
}

//--------------------------------------
//	Drop
//--------------------------------------
function void stopDropState()
{
	endDropState();
	dbg("DROP: stopped !!!", me);

	/* If we were doing something before dropping, resume it */
	if(lastState != stNone)
	{
		resumeState();
	}
	else
	{
		/* we started the drop directly, not from a different state, so just start attacking the enemy */
		enemy = enemy;		//shouldn't change
		if(knowBase[enemy])
		{
			//HACK resume with curBase[], since didn't save last attack x and y coords
			startAttack(enemy, curBase[enemy][0], curBase[enemy][1]);
			requestStartAttack(enemy, curBase[enemy][0], curBase[enemy][1]);
		}
	}
}

function void cancelDropState()
{
	erasePausedState();		//don't resume since cancelled

	enemy = none;		//should be cleard here?

	dropStartTime = none;	//doesn't belong to endDropState()
	tSyncDrop = 0;		//doesn't belong to endDropState()

	endDropState();

	dbg("DROP: cancelled !!!", me);
}

function void endDropState()
{
	setState(stNone);
	phase = phNone;

	if(enemy != none)
	{
		tempReinfCount[enemy] = 0;		//start over
	}
}

//----------------------------------------------------------
//			stop collecting
//----------------------------------------------------------
function void stopCollecting()
{
	collectTime = 0;

	setState(stNone);
	phase = phNone;

	collectX = none;
	collectY = none;

	dbg("COLLECT: stopped", me);
}

function void cancelCollecting()
{
	stopCollecting();
}

function void setTechBranch()
{
	tech = 0;	//random(numBranches);	//FIXME
}

function void doMilitaryMisc()
{
	/* set tech branch */
	if((tech == none) and (gameTime > 100))
	{
		setTechBranch();	// decide what we will research
	}

	/* create alliances */
	if(not alliancesLocked() and (gameTime > 100))
	{
		if(numAllies(me) < (multiPlayerMaxPlayers / 2))	//not allied to too many players already
		{
			if(random(5) == 1)
			{
				makeAlliances();
			}
		}
	}

	militarySelftest();		//misc stuff


	/* Make sure we are not under heavy attack */
	if(gameTime > 1800)		//3 mins, in case bases are close to each other
	{
		checkBaseThreat();	//set or cancel base threat alert
	}


	/* find enemies and allies and their bases (targets) */
	updateMilitaryStatus();

	/* if we haven't heard anything from our allies for a long time, ask what they are doing */
	checkRequestStatus();
}

//---------------------------------------------------------
//	Deal with basic military stuff
//---------------------------------------------------------
function void doMilitary()
{
	/* should be done before any other military tasks */
	doMilitaryMisc();


	/* build anti-rush defenses */
	if(not initialDefensesFinished)
	{
		//dbg("buildInitialDefenses() - doMilitary()", me);
		buildInitialDefenses(FALSE);
	}

	if(gameTime >= 9000)	//max 15 mins
	{
		stopInitialDefenses();	//enough
	}

	/* manage helping ally process */
	if(state == stHelpingAlly)		//did we choose to defend him?
	{
		/* if checkAllyThreat detected that no enemies left and were helping ally, retreat back to base */
		//if(defendingAlly)
		//{

		if(helpTime > 0)	//help didn't timeout yet
		{
			manageHelpAlly();
		}
		else
		{
			dbg("DEFEND ALLY: time out, rtb!!!!!!!!!!!!!!!!!", me);
			msg("retreating for now, call me if you need me again" , me, enemy);	//allyInThreat
			stopAllyDefense();
		}
	}

	/* build units */
	if((tech == techAir) or (playerPower(me) > muchoPower))
	{
		buildVTOLs();
	}

	if((tech == techTanks) or (playerPower(me) > muchoPower))
	{
		buildTanks();
	}


	/* Build base defenses */
	if( ((gameTime / 10) - tLastBaseDefense) >  50)	//wait at least 40 secs
	{
		if(not((playerPower(me) <= lowPower) and (state == stDefending)))		//build defenses only if not low on power and not defending
		{
			buildDefenses();
		}
	}

	/* build AA defenses */
	if((not alert) and (state != stDefending))
	{
		buildAA();
	}

	/* build gateway defenses if enough power */
	if((not alert) and (playerPower(me) > highPower) and (gameTime > 12000))	//don't waste too much power on it; don't waste startup power
	{
		gatewayDefenses();
	}


	/* check if tired attacking an enemy and want to try to drop him instead */
	if(state == stAttacking)
	{
		if((tempReinfCount[enemy] >= maxReinfCount) and (attackGr.members <= 1))		//if we attacked too many times and current attack failed too
		{
			result2 = random(3);

			/* do drop */
/*
			if(result2 == 1)
			{
				result = numResearchLeft(me, resUnitTransporter);
				if(result <= 3)		//won't take too long
				{
					dbg("ATTACKED ENEMY TOO MANY TIMES: drop instead!!!", me);

					result = enemy;

					pauseState();

					enemy = result;		//same enemy
					requestPrepareDrop();
					startDropPhase();
				}
			}
*/
			/* wipe out some derricks */
			if(result2 == 0)
			{
				result = numAvailableAttackers();
				if(result >= minOilAttackers)
				{
					structure = findEnemyDerrick(enemy);

					//structure = retStruct;

					if(structure != NULLOBJECT)
					{
						dbg("ATTACKED ENEMY TOO MANY TIMES: wipeout oil instead!!!", me);
						pauseState();		//resume when done hunting enemy derricks

						startTakeOil(structure);
						notifyTakeOil(structure.player, structure.x, structure.y);
					}
				}
			}
		}
	}

	/* see if we want to drop someone ... just out of fun */
//todo: fix
/*
	if((state == stNone) and (random(10) > 6))
	{
		if((notifyReadyAttackTime <= 0) and (bNotifiedReadyAttack == FALSE))	//make sure not about to start attack
		{
			//result = enoughDroppers();
			if(enoughDroppers())
			{
				result = numResearchLeft(me, resUnitTransporter);
				if(result <= 6)		//won't take too long
				{
					result = chooseEnemyToDrop();
					if(result != none)		//found any enemy targets?
					{
						enemy = result;
						requestPrepareDrop();
						startDropPhase();
					}
				}
			}
		}
	}
*/

	/* build transporters if gonna drop */
/*
	if((state == stDrop) and researchFinished(resUnitTransporter, me))	//gonna drop and got unit transporter tech
	{
		//temp = enoughTransporters();
		if((not alert) and (not enoughTransporters()))
		{
			buildTransporters();
		}
	}
*/
	/* see if we want to blow up some enemy derricks */
	if(countTakeOil < numTakeOil)	//don't do too often
	{
		if((state == stNone) and (notifyReadyAttackTime <= 0) and (bNotifiedReadyAttack == FALSE))	//not busy and not about to start attack
		{
			result = numAvailableAttackers();
			if((random(10) < 7) and (result >= minOilAttackers))
			{
				structure = findEnemyDerrick(none);	//any player
				//structure = retStruct;

				if(structure != NULLOBJECT)
				{
					startTakeOil(structure);
					notifyTakeOil(structure.player, structure.x, structure.y);
				}
			}
		}
	}


	/* start land attack */
	if(state == stNone)
	{
		//result = canTheoreticallyStartAttack();	//enough units in total
		if(canTheoreticallyStartAttack())					//we can start
		{
			if(noBaseTargets)	//if couldn't find any enemy main bases
			{
				findAlternateTarget();	//find any other visible target
			}

			if(not noBaseTargets)	//notify only if can actually start attacking someone
			{
				if(bNotifiedReadyAttack or (not playerInAlliance(me)))	//already notified or no allies
				{
					result = chooseEnemy();	//should be able to find enemy if (not noBaseTargets)
					if(result != none)		//found any enemy targets?
					{
						//enemy = result;
						startAttack(result, curBase[result][0], curBase[result][1]);
						requestStartAttack(result, curBase[result][0], curBase[result][1]);
					}
					else
					{
						dbg("ATTACK: failed to find an enemy", me);
					}
				}
				else if(notifyReadyAttackTime <= 0)	//haven't started countdown already
				{
					notifyReadyAttack();		//notify allies and wait for orders
				}
			}
		}
	}

	/* Continue military actions if we are attacking */
	if(state == stAttacking)
	{
		doAttack();
		checkStopAttack();
	}

	/* remind allies we are in trouble */
	if(state == stDefending)
	{
		if(requestHelpTime <= 0)
		{
			requestHelp();	//do once in a while
		}
	}

	/* use lasSat */
	updateLasSat();
}

function bool pendingLasSatStrike()
{
	local int _tempPlayer;

	_tempPlayer = 0;
	while(_tempPlayer < 8)
	{
		if(allianceExistsBetween(_tempPlayer, me))
		{
			if(lasSatState[_tempPlayer] == lsWaitingReply)	//someone requested lassat strike?
			{
				return TRUE;
			}
		}
		_tempPlayer = _tempPlayer + 1;
	}

	return FALSE;
}

function void updateLasSat()
{
	local STRUCTURE _lasSatTarget;

	/* check if finished recharging lassat */
	if(lasSatState[me] == lsRecharging)	//only recharge if we built lasSat already and are not recharged already (would reset waiting state)
	{
		if(tLasSat >= tLasSatReady)		//ready
		{
			dbg("lassat ready**********************", me);
			lasSatState[me] = lsReady;
		}
	}

	if(lasSatState[me] == lsReady)
	{
		if(pendingLasSatStrike())
		{
			dbg("LASSAT: joining ****************", me);
			lasSatState[me] = lsRequesterWaitingRecharging;	//join and tell that lassat is ready
		}
		else
		{
			notifyAllies("let's lassat someone", TRUE);
			dbg("notified allies**********************", me);
			lasSatState[me] = lsWaitingReply;		//wait to find out if anyone wants to join
			tLasSatCountdown = tLasSatReplyMax;		//start countdown
		}
	}

	if(lasSatState[me] == lsWaitingReply)
	{
		if(tLasSatCountdown <= 0)		//waited enough for allies to reply to lassat request
		{
			dbg("notified allies countdown: time is up********", me);
			lasSatState[me] = lsWaiting;	//wait for allies to finish recharging lassat
			tLasSatCountdown = tLasSatWaitAlliesMax;			//start wait for allies countdown
		}
	}

// start 'someone requested lassat strike' code

	/* someone requested lassat and waiting for us to finish recharging lassat */
	if(lasSatState[me] == lsRequesterWaitingRecharging)
	{
		/* check if finished recharging lassat */
		if(tLasSat >= tLasSatReady)		//ready
		{
			notifyAllies("lassat ready", FALSE);	//tell them lassat is ready, so that requester can start the strike if everyone else is ready too
			lasSatState[me] = lsWaitingForRequester;
			tLasSatCountdown = tLasSatWaitAlliesMax;		//wait for requester to start lassat strike
		}
	}

	/* we finished recharging our lassat and are now waiting for the requester to start the strike */
	if(lasSatState[me] == lsWaitingForRequester)
	{
		/* check if we waited to long, if yes, start the attack on our own */
		if(tLasSatCountdown <= 0)	//requester got killed? etc
		{
			dbg("waited too long for the requester, firing*************", me);
			lasSatState[me] = lsFiring;	//just fire, don't wait anymore
		}
	}

// end 'someone requested lassat strike' code

	/* all allies ready to fire? */
	if(lasSatState[me] == lsWaiting)
	{
		//tLasSatCountdown = off;		//not needed anymore

		dbg("lsWaiting: waiting...********", me);
		if(allyLasSatReady() or (tLasSatCountdown <= 0))	//if everyone can fire or waited too long
		{
			if(allyLasSatReady())
			{
				dbg("lsWaiting: firing now0********", me);
			}
			else if(tLasSatCountdown <= 0)
			{
				dbg("lsWaiting: firing now1********", me);
			}

			lasSatState[me] = lsFiring;
		}
	}

	/* everyone's ready or waited too long, fireing now! */
/*
	if(lasSatState[me] == lsFiring)
	{
		_lasSatTarget = findLasSatTarget(enemy);

		if(_lasSatTarget != NULLOBJECT)
		{
			dbg("lsFiring: found target********", me);
			fireLasSat(_lasSatTarget);
		}
		else
		{
			dbg("lsFiring: couldn't find target********", me);
		}
	}
*/
}

/*
function void fireLasSat(STRUCTURE _targetStructure)
{
	//TODO: must select lasSat if debugging otherwise WZ wouldn't let fire if AI is played as selectedPlayer (human)
	//if(DEBUG_OBSERVE and (me == selectedPlayer))
	//{
	//	selectStructure(_targetStructure, TRUE);
	//}

	skFireLassat(me, _targetStructure);
	notifyLassat(_targetStructure);

	resetLasSat();		//reset all counters etc
	lasSatState[me] = lsRecharging;		//start recharging lassat (after resetLasSat() !)
}
*/

function void notifyLassat(STRUCTURE _targetStructure)
{
	notifyAllies("let's lassat " & getPlayerName(_targetStructure.player), TRUE);		//tell allies who to lassat

	dropAllyBeacon("lassat " & getPlayerName(_targetStructure.player), _targetStructure.x, _targetStructure.y);
}

function bool allyLasSatReady()
{
	local int _tempPlayer;

	/* did we wait too long for allies' lassat to finish recharging? */
	//if(tLasSatWaitAllies >= tLasSatWaitAlliesMax)
	//{
	//	return TRUE;
	//}

	/* find out if we are still waiting for someone's lassat to recharge */
	_tempPlayer = 0;
	while(_tempPlayer < 8)
	{
		if(allianceExistsBetween(_tempPlayer, me))
		{
			if(lasSatState[_tempPlayer] == lsRequesterWaitingRecharging)
			//if((lasSatState[_tempPlayer] != lsRecharging) and (lasSatState[_tempPlayer] != lsWaitingForRequester))//ignore those who don't strike with us
			{
				dbg("LASSAT: " & getPlayerName(_tempPlayer) & " not ready********", me);
				return FALSE;		//someone is still recharging lassat or this is the first time we are checking and thex haven't enterd "lsRequesterWaitingRecharging" yet
			}
		}

		_tempPlayer = _tempPlayer + 1;
	}

	return TRUE;
}

function void resetLasSat()
{
	local int _tempPlayer;

	lasSatState[me] = lsNone;
	lasSatEnemy = none;

	tLasSat = 0;				//start recharging
	tLasSatCountdown = off;		//reset the misc timer

	//_tempPlayer = 0;
	//while(_tempPlayer < 8)
	//{
	//	lasSatState[_tempPlayer] = lsNone;
	//	_tempPlayer = _tempPlayer + 1;
	//}
}

function STRUCTURE findLasSatTarget(int _prefferedEnemy)
{
	local int _tempPlayer,_bestDist,_tempDist;
	local	STRUCTURE	_targetStruct,_tempStruct;

	_targetStruct = NULLOBJECT;

	if(_prefferedEnemy >= 0)
	{
		_targetStruct = mostDamagedBaseStructure(_prefferedEnemy);
	}

	/* check all other enemies */
	if(_targetStruct == NULLOBJECT)
	{
		/* find closest target */
		_bestDist = 99999;
		_tempPlayer = 0;
		while(_tempPlayer < 8)
		{
			if((not allianceExistsBetween(_tempPlayer, me)) and (_tempPlayer != me))
			{
				_tempStruct = mostDamagedBaseStructure(_tempPlayer);


				if(_tempStruct != NULLOBJECT)
				{
	//dbg("mostDamagedBaseStructure(" & _tempPlayer & "): not NULL!! ", me);
					/* check if new one is closer */
					_tempDist = distBetweenTwoPoints(baseX, baseY, _tempStruct.x, _tempStruct.y);
					if(_tempDist < _bestDist)
					{
						//dbg("findLasSatTarget: assigned struct********", me);
						_targetStruct = _tempStruct;
						_bestDist = _tempDist;
					}
				}
				//else
				//{
				//	dbg("mostDamagedBaseStructure: NULL ", me);
				//}
			}

			_tempPlayer = _tempPlayer + 1;
		}
	}

	return _targetStruct;
}

function STRUCTURE mostDamagedBaseStructure(int _targetPlayer)
{
	local	int			_structTypeIndex,_lowestHP,_tempHP;
	local	STRUCTURE	_returnStruct,_tempStruct;

	_structTypeIndex = 0;
	_lowestHP = 99999;
	_returnStruct = NULLOBJECT;

	while(_structTypeIndex < numBaseStructs)
	{
		initEnumStruct(FALSE,baseStructs[_structTypeIndex],_targetPlayer,me);

		_tempStruct = enumStruct();
		while(_tempStruct != NULLOBJECT)
		{
			_tempHP = _tempStruct.health;
			if(_tempHP < _lowestHP)
			{
				_lowestHP = _tempHP;
				_returnStruct = _tempStruct;
			}

			_tempStruct = enumStruct();
		}

		_structTypeIndex = _structTypeIndex + 1;
	}

	return _returnStruct;
}

function int checkAllyThreat()
{
	//return value - player in danger

	range = (23 * 128);

	if(state == stHelpingAlly){return(enemy);}		//already defending

	count = 0;
	while(count < multiPlayerMaxPlayers)
	{
		if(ally[count])
		{
			if(knowBase[count])		//know where his base is?
			{
				result = numEnemyWeapObjInRange(me, curBase[count][0], curBase[count][1], range, FALSE);
				result2 = numFriendlyWeapObjInRange(me, curBase[count][0], curBase[count][1], range, FALSE);

				if(result > result2)
				{
					//if(enemy == none)	//don't suddenly switch the player, only if not already set	//allyInThreat
					//{
						dbg("ally " & count & " is in danger", me);
						//enemy = count;	//allyInThreat
						//exit;	//must exit here
						return(count);
					//}
				}
				//else if(result < 4)		//we have much more and they only < 4
				//{
				//	if(mapRevealedInRange(curBase[count][0],curBase[count][1],(5 * 128),me))	//can judge if safe only if can see the base
				//	{
				//		if(allyInThreat == count)	//same we were helping
				//		{
				//			dbg(" " & me & ")  HELP ALLY: this player seems to be safe now");
				//			allyInThreat = none;	//can stop helping now
				//			exit;	//must exit here
				//		}
				//	}
				//}
			}
		}

		count = count + 1;
	}

	return(none);	//nothing found
}

function void startDefending(int _counterEnemy)
{
	if((state != stNone) and (state != stDefending))	//units busy with something else
	{
		dbg("BASE: we need our units in the base now, cancel current state", me);
		cancelState();
	}

	requestHelpTime = 0;	//reset since started over

	setState(stDefending);
	phase = phMoveToBase;

	sendForceX = baseX;	//move to base
	sendForceY = baseY;

	enemy = me;
	counterEnemy = _counterEnemy;

	dbg("DEFENDING: defend mode on (enemy = " & counterEnemy & ")", me);
}

function void startHelpAlly(int _allyToHelp, int _helpx, int _helpy)
{
	enemy = _allyToHelp;		//store it in the enemy var, since he invoked this state

	/* Calculate some place on the base edge (my base -> help dest), so won't block the inner of the base */
	sendForceX = baseX;
	sendForceY = baseY;
	circlePerimPoint(_helpx, _helpy, ref sendForceX, ref sendForceY, sendHelpRange);

	//sendForceX = _helpx;	//curBase[enemy][0];	//allyInThreat
	//sendForceY = _helpy;	//curBase[enemy][1];	//allyInThreat

	if((sendForceX <= 0) or (sendForceY <= 0))
	{
		MsgBox("startHelpAlly() - sendForceX <= 0");
		exit;
	}

	setState(stHelpingAlly);
	phase = phMoveToBase;

	helpTime = maxHelpTime;		//limited time we can help this ally or can stuck forever

	dbg("helping " & getPlayerName(enemy) & " !!!!!!!!!!!!!!!!!!!!!!!!", me);	//allyInThreat

	/* Add required number of units from defendGr to sendAttackGr */
	fillHelpers();

	//selectGroup(sendAttackGr, TRUE);


	//ToDo: <check if enough attackers and send to the ally player base>
	//ToDo: <send message to ally>

	//orderGroupLoc(sendAttackGr, DORDER_SCOUT, curBase[enemy][0], curBase[enemy][1]);	//allyInThreat
}

function void manageHelpAlly()
{
	local bool _bFoundTarget;

	ASSERT(enemy >= 0, "manageHelpAlly: wrong ally index (" & enemy & ")", me);

	dbg("manageHelpAlly", me);

	if(enemy == none)
	{
		stopAllyDefense();
		ASSERT(FALSE,"manageHelpAlly() - no player set", me);
		exit;
	}

	if((sendForceX <= 0) or (sendForceY <= 0))
	{
		msg("I can't see your base" , me, enemy);	//allyInThreat
		//msg("give vision" , me, enemy);	//allyInThreat
		ASSERT(FALSE, "manageHelpAlly - (sendForceX <= 0) or (sendForceY <= 0)", me);

		stopAllyDefense();

		//MsgBox("manageHelpAlly() - sendForceX not initialized");
		exit;
	}

	if(not knowBase[enemy])		//no visible structures left for this ally
	{
		msg("I don't see your base" , me, enemy);	//allyInThreat
		dbg("manageHelpAlly - not haveBase", me);

		stopAllyDefense();
		exit;
	}

	//--------------------------------------
	//Manage Attack
	//--------------------------------------
	if(phase == phAttackingBase)
	{
/*
		_bFoundTarget = FALSE;

		initIterateGroup(attackGr);
		droid = iterateGroup(attackGr);
		while(droid != NULLOBJECT)
		{
			//Check if idle
			if((droid.order == DORDER_NONE) or ((droid.action != DACTION_MOVETOATTACK) and
			(droid.action != DACTION_ROTATETOATTACK) and (droid.action != DACTION_ATTACK)))
			{
				//find a target to attack
				retObj = NULLOBJECT;

				//find a good target for BBs
				if(droid.weapon == weaponBB)
				{
					findBBAttackBaseTarget(droid);
				}
				else	//get trucks
				{
					findAttackBaseTarget(droid, -1, -1, -1);
				}

				//Find any target if nothing found yet
				if(retObj == NULLOBJECT)
				{
					retObj = getClosestEnemy(sendForceX, sendForceY, 50 * 128, FALSE, FALSE, me);		//max 50 tiles
				}

				//attack found enemy target
				if(retObj != NULLOBJECT)
				{
					dbg("attacking ally's enemy unit", me);
					_bFoundTarget = TRUE;
					orderDroidObj(droid, DORDER_ATTACK, retObj);
				}

				//too far from attack location?
				if(retObj == NULLOBJECT)	//didn't send to attack
				{
					if(distBetweenTwoPoints(droid.x, droid.y, sendForceX, sendForceY) > sendHelpRange)
					{
						//make sure it's not far away because going around a big ramp: check destination
						if(distBetweenTwoPoints(droid.orderx, droid.ordery, sendForceX, sendForceY) > sendHelpRange)	//not heading to the right location
						{
							dbg("ALLY DEFEND: too far from defend loc, send back", me);
							orderDroidLoc(droid, DORDER_MOVE, sendForceX, sendForceY);
						}
					}
				}
			}

			droid = iterateGroup(attackGr);
		}
*/
		/* Attack any ally's base intruders */
		defendArea(attackGr, sendHelpRange, sendForceX, sendForceY, defendCorridor, 1);
	}
}

//--------------------------------------------------------
//Add required number of units from defendGr to attackGr
//--------------------------------------------------------
function void fillAttackers(bool _highPriorityTask)
{
	local	int _numDefenders;
	//_highPriorityTask - if task is a high priority, then use more units

	//don't leave BBs in defend group
	sortOutBBs();

	_numDefenders = defendGr.members - numDefenders;
	if(_highPriorityTask)
	{
		_numDefenders = defendGr.members - minDefenders;	//leave less units in the base
	}

	initIterateGroup(defendGr);
	tempDroid = iterateGroup(defendGr);
	while((tempDroid != NULLOBJECT) and (_numDefenders > 0))	//leave 'numDefenders' number of units in the defendGr
	{
		groupAddDroid(sendAttackGr, tempDroid);
		_numDefenders = _numDefenders - 1;
		tempDroid = iterateGroup(defendGr);
	}

	selectGroup(sendAttackGr, TRUE);
}

//--------------------------------------------------------
//Add required number of units from defendGr to attackGr
//--------------------------------------------------------
function void fillReinforcements(bool _bHelping)
{
	dbg("MANAGE UNITS: sending reinforcements", me);

	fillAttackers(_bHelping);	//reinforcements have high priority ONLY if defendig ally

	//Take care of statistic stuff
	if((state != stTakingOil) and (state != stHelpingAlly))
	{
		reinfCount[enemy] = reinfCount[enemy] + 1;
		tempReinfCount[enemy] = tempReinfCount[enemy] + 1;
	}

	if((state == stAttacking) or (state == stTakingOil))
	{
		reinfTime = maxReinfTime;	//restart "cancel attack" countdown
	}
}

function void fillHelpers()
{
	//don't leave BBs in defend group
	sortOutBBs();

	temp = defendGr.members - minDefenders;		//send more units if sent not enough

	if((temp + attackGr.members + sendAttackGr.members) > (numDefenders * 3))
	{
		temp = defendGr.members - numDefenders;
	}

	initIterateGroup(defendGr);
	tempDroid = iterateGroup(defendGr);
	while((tempDroid != NULLOBJECT) and (temp > 0))	//leave 'numDefenders' number of units in the defendGr
	{
		groupAddDroid(sendAttackGr, tempDroid);
		temp = temp - 1;
		tempDroid = iterateGroup(defendGr);
	}

	selectGroup(sendAttackGr, TRUE);
}

//---------------------------------------------------------
//	For all trucks with build orders, if there's a
//	closer idle truck, use it instead
//---------------------------------------------------------
function void closerTruck()
{
	range = (25 * 128);

	initIterateGroupB(buildGr, 0);
	droid = iterateGroupB(buildGr, 0);
	while(droid != NULLOBJECT)
	{
		//if((droid.action == DACTION_MOVETOBUILD) and (droid.stat != NULLSTAT))		//has a build order
		if(droid.action == DACTION_MOVETOBUILD)
		{
			//pointless, if too close already
			result = distBetweenTwoPoints(droid.orderx, droid.ordery, droid.x, droid.y);
			if(result > range)		//will build soon
			{

				//now check if we have a droid closer to the build pos
				initIterateGroupB(buildGr, 1);
				droid2 = iterateGroupB(buildGr, 1);
				while(droid2 != NULLOBJECT)
				{
					if((droid2.order == DORDER_NONE) or (droid2.order == DORDER_RTB))
					{
						result2 = distBetweenTwoPoints(droid.orderx, droid.ordery, droid2.x, droid2.y);
						if((result - result2) > range)	//the second one is much closer
						{
							//build what first droid was going to build

							//dbg(" " & me & ")  found a much closer droid at " & (droid.x / 128) & ", " & (droid.y / 128));
							orderDroidStatsLoc(droid2, DORDER_BUILD, droid.stat, droid.orderx, droid.ordery);
							orderDroid(droid, DORDER_RTB);	//send back to base
						}
					}
					droid2 = iterateGroupB(buildGr, 1);
				}
			}
		}

		droid = iterateGroupB(buildGr, 0);
	}
}

function void closestDerrick(int _x, int _y)
{
	temp = 99999;

	retStruct = NULLOBJECT;

	initEnumStruct(FALSE,derrick,me,me);
	tempStruct = enumStruct();
	while(tempStruct != NULLOBJECT)
	{
		temp2 = distBetweenTwoPoints(tempStruct.x, tempStruct.y, _x, _y);
		if(temp2 < temp)	//already going to some derrick
		{
			retStruct = tempStruct;
			temp = temp2;
		}

		tempStruct = enumStruct();
	}

}

function int findBestDefense()
{
	//return	- defense index
	/* find best defense */
	_temp2 = none;
	_temp = 0;
	while(_temp < numDef)
	{
		if(isStructureAvailable(def[_temp],me))
		{
			_temp2 = _temp;		//Best defense
		}
		_temp = _temp + 1;
	}

	return(_temp2);
}

//---------------------------------------------------------
//	Build oil defenses
//---------------------------------------------------------
event buildNormalOilDefenses(inactive)
{
	if(state == stDefending){exit;}

	if(idleGroup(buildGr) == 0){exit;}

	/* find best defense */
	best = findBestDefense();

	if(best == none){exit;}

	/* make sure not too many trucks are busy with defenses */
	result = numBuildingNoBaseDefenses();

	if(result >= maxDefenseTrucks)
	{
		exit;
	}

	range = defensesRange;	//defenses range

	/* set number of defenses allowed */
	count = minOilDef;
	if(playerPower(me) >= highPower)
	{
		count = maxOilDef;
	}


	/* find undefended derrick */
	initEnumStruct(FALSE,derrick,me,me);
	structure = enumStruct();
	while(structure != NULLOBJECT)
	{
		/* check if this derrick has a defense location stored */
		result = getOilDefendLocIndex(me, structure.x, structure.y);

		if((result < 0) or (not bLearn))		//no defense loc stored for this derrick
		{
			/* check if too many defenses around already */
			result = numFriendlyWeapStructsInRange(me, structure.x, structure.y, defensesRange);
			if(result < count)
			{
				/* make sure derrick is not in the base */
				//result = isInMyBase(structure.x, structure.y);

				if(not isInMyBase(structure.x, structure.y))
				{
					/* is anyone already on the way to build something nearby? */
					//result =buildingSiteBlocked(NULLOBJECT, range, structure.x, structure.y);

					if(not buildingSiteBlocked(NULLOBJECT, range, structure.x, structure.y))	//no
					{
						/* build the normal way */
						dbg("building oil defense the normal way at " & (structure.x / 128) & " - " & (structure.y / 128), me);

						buildOnMap(def[best], structure.x, structure.y);
					}
				}
			}
		}

		structure = enumStruct();
	}
}

event defendOil(inactive)
{
	if(not bLearn){exit;}

	if(state == stDefending){exit;}

	if(idleGroup(buildGr) == 0){exit;}	//no trucks

	/* make sure not too many trucks are busy with defenses */
	result = numBuildingNoBaseDefenses();

	if(result >= maxDefenseTrucks)
	{
		exit;
	}

	result = 0;
	count = 0;
	best = none;
	while(count < numDef)
	{
		result2 = numStatBusy(def[count]);	//How many trucks are busy with defenses
		result = result + result2;

		count = count + 1;
	}

	/* find best defense */
	best = findBestDefense();

	if(best == none){exit;}		//no defenses available

	if(result >= 5){exit;}		//too many busy

	range = defensesRange;		//Defenses range
	result = 99999;

	//Go through remembered oil defense locations
	//------------------------------------------------
	count2 = getOilDefendLocCount();

	count = 0;
	count4 = 0;
	while((count < count2) and (count4 < 3))	//pick max 3 locs
	{
		if(recallOilDefendLoc(me, count, ref x, ref y, ref result))		//if this one stored
		{
			if(result >= minOilRecallPrior)	//at least priority of 3
			{
				//find oil derrick which is supposed to be defended (closest one)
				//---------------------------------------------------------------
				closestDerrick(x, y);

				if(retStruct != NULLOBJECT)	//found anything?
				{
					buildX = retStruct.x;
					buildY = retStruct.y;

					//make sure derrick is not in the base
					//result = isInMyBase(buildX, buildY);

					if(not isInMyBase(buildX, buildY))	//not in base
					{
						//move coords closer to derrick perimeter
						circlePerimPoint(retStruct.x, retStruct.y, ref x, ref y, (2 * 128));	//move locations to the derrick perimeter

						//count if not too many built on this site already (using corrected coords!)
						if(numStructsByTypeInRange(me, me, REF_DEFENSE, buildX, buildY, range) < numOilDef)	//max
						{
							buildX = x;	//remember coords before using pickStructLocation() to check if corrected coords too far away
							buildY = y;

							//MsgBox("11");
							if(pickStructLocation(def[best], ref buildX, ref buildY, me))
							{
								//Make sure not too many building already
								//--------------------------------------------
								retInt = numTrucksOrderInRange(buildX, buildY, (4 * 128), DORDER_BUILD);

								if(retInt == 0)	//max 1
								{
									//don't allow to build outside of the range
									if(distBetweenTwoPoints(buildX, buildY, x, y) < range)		//coords corrected with pickStructLocation() not too far away from orig
									{
										//MsgBox("22");
										intOK[count4] = count;
										//MsgBox("33");
										count4 = count4 + 1;		//picked another one
									}
								}
							}
						}
					}
				}
			}
		}
		count = count + 1;
	}

	//MsgBox("2");

	if(count4 == 0){exit;}		//couldn't find anything

	//Now choose a random location from the picked ones
	//-------------------------------------------------
	result = intOK[random(count4 - 1)];

	//dbg(" " & me & ")  defendOil() - building defense at location #" & result & " !!!!!!!!!!!!");

	recallOilDefendLoc(me, result, ref x, ref y, ref result);

	//find oil derrick which is supposed to be defended (closest one)
	//---------------------------------------------------------------
	closestDerrick(x, y);

	if(retStruct != NULLOBJECT)	//found anything?
	{
		buildX = retStruct.x;
		buildY = retStruct.y;
	}
	else
	{
		dbg("defendOil() - couldn't find closest derrick !!!!!!!!!!!!!!!!", me);
		exit;
	}

	//MsgBox("3");

	//move locations to the base perimeter
	circlePerimPoint(retStruct.x, retStruct.y, ref x, ref y, oilExperRange);

	buildX = x;
	buildY = y;


	//if(structure2 == NULLOBJECT){exit;}	//no derrick found

	//Now find the closest truck
	//---------------------------------------------
	result = 99999;
	bResult = FALSE;	//found any?

	droid2 = NULLOBJECT;
	droid3 = NULLOBJECT;

	//MsgBox("4");

	initIterateGroup(buildGr);
	droid = iterateGroup(buildGr);
	while(droid != NULLOBJECT)
	{
		result2 = distBetweenTwoPoints(droid.x, droid.y, x, y);

		if(result2 < result)	//closer
		{
			if(droid.order == DORDER_NONE)
			{
				droid2 = droid;		//totally idle
				result = result2;
				bResult = TRUE;
			}
			//if busy, check if it's worth to make this droid build an oil defense instead
			else if((droid.order == DORDER_BUILD) and (droid.action == DACTION_MOVETOBUILD))
			{
				bResult2 = TRUE;		//can take this truck
				if(droid.stat == derrick)
				{
					bResult2 = FALSE;		//don't touch him, probably going far
				}
				else
				{
					initEnumStruct(FALSE,derrick,me,me);
					structure = enumStruct();
					while((structure != NULLOBJECT) and (bResult2))
					{
						//skip derricks in the base
						//result3 = isInMyBase(structure.x, structure.y);
						if(not isInMyBase(structure.x, structure.y))		//not in base
						{
							if(distBetweenTwoPoints(droid.orderx, droid.ordery, structure.x, structure.y) < range)	//already going to some derrick
							{
								bResult2 = FALSE;	//don't touch this truck, going far already
							}
						}

						structure = enumStruct();
					}
				}

				if(bResult2)	//safe to 'kidnap' this busy truck
				{
					droid3 = droid;		//remember this one too
					result = result2;
					bResult = TRUE;
				}
			}
		}
		droid = iterateGroup(buildGr);
	}

	//MsgBox("5");


	if(not bResult){dbg("defendOil() - no idle trucks (MUST BE SOME!)", me);exit;}		//no trucks

	//decide which droid to take
	//-----------------------------------------
	droid = droid2;		//default
	if((droid2 != NULLOBJECT) and (droid3 != NULLOBJECT))		//which of 2?
	{
		//only if busy one is much closer, otherwise let him do his job since he's busy
		result = distBetweenTwoPoints(droid2.x, droid2.y, x, y);
		result2 = distBetweenTwoPoints(droid3.x, droid3.y, x, y);

		if((result - result2) > (12 * 128))		//busy one is much closer
		{
			droid = droid3;
		}
	}
	else if(droid3 != NULLOBJECT)
	{
		droid = droid3;
	}

	buildOnMap(def[best], x, y);
}


//take over enemy derricks
function STRUCTURE findEnemyDerrick(int _targetPlayer)
{
	local int _numAttackers,_numEnemies;

	tempStruct = NULLOBJECT;

	tempStruct = findBestEnemyDerrick(_targetPlayer, numAvailableAttackers());		//find enemy derrick

	if(tempStruct == NULLOBJECT){return tempStruct;}	//none found

	//tempStruct = retStruct;

	dbg("findEnemyDerrick() - found derrick", me);

	//see if we can deal with this many defenses
	_numAttackers = numAvailableAttackers();
	_numEnemies = numEnemyWeapObjInRange(me, tempStruct.x, tempStruct.y, (8 * 128), FALSE);

	if(_numAttackers < (_numEnemies + 1))
	{
		tempStruct = NULLOBJECT;		//clear
		dbg("TAKE OIL: not enough attackers for this oil", me);
		return tempStruct;		//too many enemies around
	}

	dbg("findEnemyDerrick()- safe", me);

	//enemy = tempStruct.player;

	//sendForceX = tempStruct.x;
	//sendForceY = tempStruct.y;

	return tempStruct;
}

//find closest enemy derrick with litte defense
function STRUCTURE findBestEnemyDerrick(int _targetPlayer, int _numAttackers)
{
	local int _numEnemies,_enemy,_x,_y,_dist,_dist2,_dist3;
	retStruct = NULLOBJECT;

	tempResult2 = 99999;	//best weight

	_enemy = 0;
	while(_enemy < multiPlayerMaxPlayers)
	{
		if( ((_targetPlayer == none) and (_enemy != me) and (not allianceExistsBetween(_enemy, me)))  	//target player not set
		or ((_targetPlayer != none) and (_enemy == _targetPlayer)))						//target player set
		{
			initEnumStruct(FALSE,derrick,_enemy,me);
			tempStruct = enumStruct();
			while(tempStruct != NULLOBJECT)
			{
				_x = tempStruct.x;
				_y = tempStruct.y;

				//don't choose if near an enemy base, since might have units nearby, which we don't see
				//temp4 = isNearEnemyBase(x, y);

				if(not isNearEnemyBase(_x, _y))
				{
					//make sure not too well defended
					_numEnemies = numEnemyWeapObjInRange(me, _x, _y, (8 * 128), TRUE);	//check VTOLs too
					if(_numEnemies < _numAttackers)	//this one has less defenses than the amount of units we will use for attack
					{
						_dist = distBetweenTwoPoints(_x, _y, baseX, baseY) / 128;	// my base-derrick distance

						//enemy-derrick distance
						_dist2 = (_dist / 2) / 128;	//if don't know enemy base location
						if(knowBase[_enemy])
						{
							_dist2 = distBetweenTwoPoints(_x, _y, curBase[_enemy][0], curBase[_enemy][1]) / 128;
						}

						_dist3 = distBetweenTwoPoints(baseX, baseY, curBase[_enemy][0], curBase[_enemy][1]) / 128;	//my base-enemy base

						//calculate
						//criticalAngle = 45 / dist3 / baseRange;
						//temp4 = degree(baseX, baseY, x, y, curBase[temp][0], curBase[temp][1]);		//base-derrick-enemyBase angle, the bigger the safer
						//if(temp4 > 180){temp4 = 360 - temp4;}

						//if(not((temp4 < criticalAngle) and ((dist - baseRange) > dist3)))	//make sure not behind the enemy base
						//{
							//tempResult = (temp2 * defWeight) + dist - dist2 - temp4;	//calculate weight of the derrick

							//calculate weight for this derrick (threat)
							tempResult = oilWeight(_enemy, _x, _y);

							if(tempResult < tempResult2)
							{
								tempResult2 = tempResult;
								retStruct = tempStruct;
							}
						//}
					}

				}

				tempStruct = enumStruct();
			}
		}
		_enemy = _enemy + 1;
	}

	return retStruct;
}

function int oilWeight(int _owner, int _x, int _y)
{
	local int _range;

	_range = 12 * 128;	//must be same as in posWeight()

	retInt = posWeight(_owner, _x, _y, _range);

	retInt = retInt - numFeatByTypeInRange(me, 4, _x, _y, _range);	//4 = FEAT_OIL_RESOURCE

	return(retInt);
}


//calc threat
function int posWeight(int _owner, int _x, int _y, int _range)
{
	_result = 0;	//threat
	_temp2 = 100;	//more integer precision

	//base - pos
	_dist = distBetweenTwoPoints(baseX, baseY, _x, _y) / 128;

	if(_dist == 0)
		_dist = 1;

	_temp3 = numStructsByTypeInRange(me, me, REF_RESOURCE_EXTRACTOR, _x, _y, (_range * 128));	//derricks

	if(_temp3 == 0)
		_temp3 = 1;

	_dist = (-1) * (weightDistFactor * _temp2) / (_dist / _temp3);	//my weight //*_temp2 for precision

	_temp3 = (_dist / _temp2);
	//dbg("my weight = " & _temp3, me);

	//enemy - pos
	_dist2 = 0;	//if dead, no threat

	//check object enemy
	if(_owner != none)		//not always need one
	{
		if((not dead[_owner]) and (not killedBase[_owner]))
		{
			_dist2 = _dist;	//neutralize if enemy base loc unknown
			if(knowBase[_owner])
			{
				_dist2 = distBetweenTwoPoints(curBase[_owner][0], curBase[_owner][1], _x, _y) / 128;
				//dbg("_dist2 = " & _dist2, me);
				_dist2 = (weightDistFactor * _temp2) / _dist2;
			}
		}
	}

	_temp3 = (_dist2 / _temp2);
	//dbg("his weight = " & _temp3, me);

	//calc weight
	_result = (_dist2 + _dist);

	_temp3 = (_result / _temp2);
	//dbg("_result = " & _temp3, me);

	//check allies and all enemies
	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if((_temp != me) and (_temp != _owner))
		{
			/* Ally/Enemy */
			_temp3 = (-1);
			if(not allianceExistsBetween(_temp ,me))
			{
				_temp3 = 1;
			}

			if(knowBase[_temp] and seeBase[_temp])	//seeBase[] - otherwise this player might have been destroyed already or not loaded at all
			{
				_dist2 = distBetweenTwoPoints(curBase[_temp][0], curBase[_temp][1], _x, _y) / 128;
				if(_dist2 == 0){_dist2 = 1;}

				_result = _result + (_temp3 * (weightDistFactor / 5 * _temp2)) / _dist2;	//weightDistFactor / 2 => allies and other enemies have less weight	//was /4
			}
		}
		_temp = _temp + 1;
	}

	_result = _result / _temp2;

	//dbg("ally _result = " & _result, me);

	//also check enemy defenses nearby
	_temp3 = numEnemyWeapObjInRange(me, _x, _y, ((_range + 2) * 128), TRUE);	//also check VTOLs

	//dbg("num defenses = " & _temp3, me);

	_result = _result + _temp3;

	//also take into account possible ally and my objects nearby
	_temp3 = numFriendlyWeapObjInRange(me, _x, _y, ((_range + 2) * 128), TRUE);	//also check VTOLs
	_result = _result - _temp3;

	return(_result);
}

function int numAvailableAttackers()
{
	retInt = max(attackGr.members + sendAttackGr.members + defendGr.members - numDefenders, 0);

	return(retInt);
}

/* Total units that can attack, including defenders */
function int numAttackUnits()
{
	local	int		_totalAttackUnits;

	_totalAttackUnits = attackGr.members + sendAttackGr.members + defendGr.members;

	return _totalAttackUnits;
}

//---------------------------------------------------------
//	Check if point is in base
//---------------------------------------------------------
function bool isInMyBase(int _checkX, int _checkY)
{
	if(distBetweenTwoPoints(_checkX, _checkY, baseX, baseY) > (baseRange + defendCorridor))	//not in the base
	{
		return(FALSE);
	}

	return(TRUE);
}

//---------------------------------------------------------
//	Check if point is near anyone's base
//---------------------------------------------------------
function bool isNearAnyBase(int _x, int _y)
{
	_range = (25 * 128);

	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(knowBase[_temp] and seeBase[_temp])	//seeBase[] - otherwise this player might have been destroyed already or not loaded at all
		{
			if(distBetweenTwoPoints(curBase[_temp][0], curBase[_temp][1], _x, _y) < _range)
			{
				return(TRUE);
			}
		}
		_temp = _temp + 1;
	}

	return(FALSE);
}

function bool isNearEnemyBase(int _x, int _y)
{
	_range = (25 * 128);

	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(not allianceExistsBetween(_temp ,me))
		{
			if(knowBase[_temp] and seeBase[_temp])	//seeBase[] - otherwise this player might have been destroyed already or not loaded at all
			{
				if(distBetweenTwoPoints(curBase[_temp][0], curBase[_temp][1], _x, _y) < _range)
				{
					return(TRUE);
				}
			}
		}
		_temp = _temp + 1;
	}

	return(FALSE);
}

//---------------------------------------------------------
//	Returns TRUE if a base structures (not defense etc)
//---------------------------------------------------------
function bool isBaseStruct(STRUCTURE _checkStruct)
{
	if(_checkStruct == NULLOBJECT)
	{
		MsgBox("isBaseSTruct - _checkStruct is NULLOBJECT");
		return(FALSE);
	}

	temp = 0;
	while(temp < numBaseStructs)
	{
		if(_checkStruct.stat == baseStructs[temp])
		{
			return(TRUE);
		}
		temp = temp + 1;
	}

	return(FALSE);
}

//---------------------------------------------------------
//	Build derricks
//---------------------------------------------------------
function void checkOil(bool _bInBaseOnly)
{
	//dbg(" " & me & ")  Executing checkOil()");

	//How many trucks already working on derricks
	result = numStatBusy(derrick);	//How many trucks are busy with derricks

	//dbg(" " & me & ")  right now building " & result & " oil resoirces");

	if(result < maxBuildOilTrucks)	//Not too many
	{
		if(_bInBaseOnly)
		{
			findClosestOilToBuildOn(baseX, baseY, baseRange);	//Look near the base
		}
		else
		{
			findClosestOilToBuildOn(baseX, baseY, -1);			//Normal way
		}

		if(retFeature != NULLOBJECT)
		{
			//dbg(" " & me & ")  found unoccupied oil resource");

			bDummy = buildUsingClosestTruck(derrick, retFeature.x, retFeature.y);	//Can skip "buildOnMap" for oil
		}
	}

	//dbg(" " & me & ")  End checkOil()");
}

//-----------------------------------------------------
//Build ArgStrStat0 (passes STRUCTURESTAT) somewhere
//-----------------------------------------------------
function void buildOnMap(STRUCTURESTAT _statToBuild, int _buildX, int _buildY)
{
	bTempResult = pickStructLocation(_statToBuild, ref _buildX, ref _buildY, me);
	if(bTempResult)
	{
		bDummy = buildUsingClosestTruck(_statToBuild, _buildX, _buildY);		//can re-use all arguments
	}
}

function void findClosestOilToBuildOn(int _lookx, int _looky, int _maxRange)
{
	//dbg(" " & me & ")  Executing findClosestOilToBuildOn()");

	temp3 = _lookx;	//will be re-assigned
	temp4 = _looky;

	retFeature = NULLOBJECT;	//Not found right now
	temp = 99999;

	initGetFeature(oilRes,me,me);
	tempFeature = getFeature(me);
	while(tempFeature != NULLOBJECT)
	{
		//temp2 = distBetweenTwoPoints(temp3, temp4, tempFeature.x, tempFeature.y);
		//if(temp2 < temp)
		//{
			//make sure not dangerous
			if(not threatInRange(me, tempFeature.x, tempFeature.y, threatRange,FALSE))
			{
				//Any trucks already were sent to build there?
				//temp5 = buildingSiteBlocked(NULLOBJECT, (5 * 128), tempFeature.x, tempFeature.y);	//anyone going there already?

				if(not buildingSiteBlocked(NULLOBJECT, (5 * 128), tempFeature.x, tempFeature.y))		//No one going there
				{

					if(not ((_maxRange > 0) and distBetweenTwoPoints(baseX, baseY, tempFeature.x, tempFeature.y) < baseRange))		//make sure close enough to base
					{
						temp2 = oilWeight(none, tempFeature.x, tempFeature.y);

						if(temp2 < temp)
						{
							temp = temp2;
							retFeature = tempFeature;	//Remember and return it
						}
					}
				}
			}
		//}
		tempFeature = getFeature(me);
	}

	//dbg(" " & me & ")  End findClosestOilToBuildOn()");
}

function bool needTrucks()
{
	if(idleGroup(buildGr) >= 2)
		return FALSE;

	return TRUE;
}

function void buildTrucks()
{
	local	int _numBuilding,_haveTrucks;

	_haveTrucks = buildGr.members;

	_numBuilding = numTemplatesInProduction(truck,me);	//How many trucks are being built at the moment

	if((_haveTrucks + _numBuilding) >= maxTrucks)
		exit;

	initEnumStruct(FALSE,fac,me,me);
	structure = enumStruct();

	while((structure != NULLOBJECT) and ((((_haveTrucks + _numBuilding) < maxTrucks) and (_numBuilding == 0)) //Not too many already and max 1 at a time, if have more than minTrucks, use only 1 fac for trucks
	or ( ((_haveTrucks + _numBuilding) < minTrucks) and (_numBuilding <= 1) )) )		//But keep building until we have min number (max 2 at a time)
	{
		if(structureComplete(structure))
		{
			if(structureIdle(structure))
			{
				//count = count + 1;
				_numBuilding = _numBuilding + 1;
				buildDroid(truck, structure, me, 1);
			}
		}
		structure = enumStruct();
	}
}

function void checkPowerGen()
{
	//dbg(" " & me & ")  Executing checkPowerGen()");

	if(not structureLimitReached(powGen, me))
	{
		result = getNumStructures(derrick, me);
		result = result + numStatBusy(derrick);	//"Think ahead"

		result2 = getNumStructures(powGen,me);

		if((result2 * 4) < result)	//not enough pow gens
		{
			result3 = numStatMoveBusy(powGen);	//How many builds trucks are on the way to build

			count = (((result+3)/4) - result2) - result3;	//How many power gens are *really* missing (missing - pending)

			//dbg(" " & me & ")  num gens to build: " & count);

			while(count > 0)
			{
				buildInBase(powGen);	//Build power gen in the base  (can re-use argument ArgStrStat0)
				count = count - 1;
			}
		}
	}

	//dbg(" " & me & ")  End checkPowerGen()");
}

function void upgradeFacPow()
{
	if(idleGroup(buildGr) == 0){exit;}

	//powergen
	initEnumStruct(FALSE,powGen,me,me);
	structure = enumStruct();
	while(structure != NULLOBJECT)
	{
		if(isStructureAvailable(powMod,me) and (not testStructureModule(me, structure, 0)))
		{
			//result = buildingSiteBlocked(NULLOBJECT, 128, structure.x, structure.y);

			if(not buildingSiteBlocked(NULLOBJECT, 128, structure.x, structure.y))	//No one upgrading
			{
				buildOnMap(powMod, structure.x, structure.y);
			}
		}
		structure = enumStruct();
	}

	//factory
	initEnumStruct(FALSE,fac,me,me);
	structure = enumStruct();
	while(structure != NULLOBJECT)
	{
		if(isStructureAvailable(facMod,me) and (skGetFactoryCapacity(structure) < 2 ))
		{
			//result = buildingSiteBlocked(NULLOBJECT, 128, structure.x, structure.y);

			if(not buildingSiteBlocked(NULLOBJECT, 128, structure.x, structure.y))
			{
				result = numStatBusy(facMod);	//How many trucks are busy with facMod

				if(result <= 1)		//Max 2 at a time
				{
					buildOnMap(facMod, structure.x, structure.y);
				}
			}
		}
		structure = enumStruct();
	}
}

function void upgradeVtolFac()
{
	if(idleGroup(buildGr) == 0){exit;}

	//vtol Factory
	initEnumStruct(FALSE,vtolfac,me,me);
	structure = enumStruct();
	while(structure != NULLOBJECT)
	{
		if(isStructureAvailable(facMod,me) and (skGetFactoryCapacity(structure) < 2))
		{
			//result = buildingSiteBlocked(NULLOBJECT, 128, structure.x, structure.y);

			if(not buildingSiteBlocked(NULLOBJECT, 128, structure.x, structure.y))
			{
				result = numStatBusy(facMod);	//How many trucks are busy with resMod

				if(result <= 1)		//Max 2 at a time
				{
					buildOnMap(facMod, structure.x, structure.y);
				}
			}
		}
		structure = enumStruct();
	}
}

function void upgradeResFac()
{
	//dbg(" " & me & ")  Executing doUpgrades()");

	if(idleGroup(buildGr) == 0){exit;}

	//research
	initEnumStruct(FALSE,resFac,me,me);
	structure = enumStruct();
	while(structure != NULLOBJECT)
	{
		if(isStructureAvailable(resMod,me) and (not testStructureModule(me, structure, 0)))
		{
			//result = buildingSiteBlocked(NULLOBJECT, 128, structure.x, structure.y);

			if(not buildingSiteBlocked(NULLOBJECT, 128, structure.x, structure.y))
			{
				result = numStatBusy(resMod);	//How many trucks are busy with resMod

				if(result <= 1)		//Max 2 at a time
				{
					buildOnMap(resMod, structure.x, structure.y);
				}
			}
		}
		structure = enumStruct();
	}

	//dbg(" " & me & ")  End doUpgrades()");
}

function void deselectAllDroids()
{
	//Iterate through all player droids
	InitEnumDroids(me,me);
	tempDroid = EnumDroid();
	while(tempDroid != NULLOBJECT)
	{
		selectDroid(tempDroid, FALSE);
		tempDroid = EnumDroid();
	}
}

event doResearch(inactive)
{
	local int _tech,_numResearching,_needRes,_needResInPower;
	local int _topicCost,_tankCost,_missingDefendersCost,
			_availableAttackersCost,_minAttackersCost,
			_stateCost,_tStateUrgencyTimeout,_floatToIntCompensate,_researchActivityCost;
	local float	_fNeedRes;

	/* find out how many research facilities are busy */
	_numResearching = numBusyByType(resFac);

	if(_numResearching > 0)
		tLastResearch = 0;	//reset, since we are not idle

	/* decide how many research facilities we want to use */
	_needRes = maxResearch;


	/* NOTE: toPow(x / a, power) - means: parabola depends on x. Parabola's f(x) will have 1 at 'a',
		ie 'a' is like a threshold, which makes toPow() kick-in (output f(x) > 0) only after 'a', having no effect for x < a.
	*/
	_floatToIntCompensate = 10;		//more precise integer division

	_topicCost = 400;			//Approximate cost of a single research topic
	_tankCost = _topicCost;
	_missingDefendersCost = max(minDefenders - defendGr.members, 0) * _tankCost;	//can't be negative, don't care if have more than needed
	_availableAttackersCost = numAvailableAttackers() * _tankCost;
	_minAttackersCost = minAttackers * _tankCost;

	//_researchActivityCost = toPow(min(curResUrgency, 800) / (maxResHold / _floatToIntCompensate) , 5) / toPow(_floatToIntCompensate, 5) * _topicCost;	//+1 res at maxResHold
	_researchActivityCost = (int)toPow((float)(min(curResUrgency, 7000) / maxResHold), 3.0)
	* _topicCost;	//+1 res at maxResHold

	_stateCost = 0;
	_tStateUrgencyTimeout = 10 * 60;	/* 10mins - when to add at least 1 res, in secs, can't put research on hold forever while defending or helping ally
											shouldn't lose urgency way too fast, should still put enough power into what we are doing now - flat function*/
	if((state == stDefending) or (state == stHelpingAlly)) {
		//ASSERT(tState != 0, "doResearch: tState == 0", me);
		_stateCost = max((_tStateUrgencyTimeout / max(tState, 1) - 1), 0);		//f(x) is +inf at the beginnign of the state, 0 at _tStateUrgencyTimeout, '-' after _tStateUrgencyTimeout
	}

	/* Temporary calculations in power currency */
	/* numRes = (minResearch * _topicCost) 							//Try to keep minimum number of res facs working
			+ playerPower(me)  							//use each 400 power for 1 additional research topic
			- _missingDefendersCost		//Save some power if we don't have enough defenders
			+ toPow(_availableAttackersCost / _minAttackersCost, 2)		//Research more if we have alot of attackers already, +1 res at _minAttackersCost
			+ _researchActivityCost			//Take into account how actively we have been researching in the last tResUrgencyTrackInterval seconds
			- _stateCost
			- enemyAttackers; */				//Do less research if enemy is about to invade with a huge force

	_needResInPower = (minResearch * _topicCost) + playerPower(me) - _missingDefendersCost + (int)toPow((float)_availableAttackersCost / (float)max(_minAttackersCost, 1), 2.0) + _researchActivityCost - _stateCost;	// - enemyAttackers;

	/* Convert from power currency into number of research facilities needed to put to work */
	_fNeedRes = (float)_needResInPower / (float)_topicCost;
	_needRes = (int)_fNeedRes;

	/* Update debug menu */
	setDebugMenuEntry("research: " & _fNeedRes & " (" & _needResInPower & ")", 0);
	setDebugMenuEntry("resUrgency : " & curResUrgency & " (" & _researchActivityCost & ")" , 1);
	setDebugMenuEntry("-defenders: " & _missingDefendersCost, 2);
	setDebugMenuEntry("attackers: " & _availableAttackersCost & " (" & toPow((float)_availableAttackersCost / (float)max(_minAttackersCost,1), 2.0) & ")", 3);


/* 	numRes = minResearch 							//Try to keep minimum number of res facs working
			+ (power / _topicCost) 			//use each 400 power for 1 additional research topic
			- ( _numMissingDefenders / (_topicCost / _tankCost) )		//Save some power if we don't have enough defenders
			+ toPow(numAvailableAttackers / minAttackers, 2)		//Research more if we have alot of attackers already, +1 res at minAttackers
			+ toPow(curResUrgency / maxResHold, 5);					//+1 res at maxResHold	 */

	/* see if we already have enough research facilities busy */
	if(_numResearching >= _needRes)
		exit;

	result2 = (-1);		//research index

	/* current tech tree */
	_tech = 0;	//default tank tech
	if(tech != none)
		_tech = tech;	//use whatever we selected as our new preference

	/* Put research facilities to work */
	initEnumStruct(FALSE,resFac,me,me);
	structure = enumStruct();
	while((structure != NULLOBJECT) and (_numResearching < _needRes))		//not too many working
	{
		if(structureIdle(structure))
		{
			if(structureComplete(structure))
			{
				bResult = FALSE;	//this res lab idle for now

				/* check if need unit transporter ASAP */
/*
				if((state == stDrop) and (not researchFinished(resUnitTransporter, me)))
				{
					bResult = pursueResearch(structure,me,resUnitTransporter);

					if(bResult)
					{
						dbg("getting transporter tech", me);
					}
				}
*/

				/* do normal research */
				while(not bResult)
				{
					result2 = findResearch(result2 + 1, _tech);

					if(result2 > none)	//found research
					{
						bResult = pursueResearch(structure,me,research[_tech][result2]);

						if(bResult)
						{
							//dbg(" " & me & ")  Started research " & result2);
							_numResearching = _numResearching + 1;	//one more working
							tLastResearch = 0;	//reset, since we are not idle now
						}
						//else	//probably someone is working on the only available pre-req., so try next res topic in the meanwhile
						//{
						//	dbg(" " & me & ")  Couldn't start research " & result2);
						//}
					}
					else
					{
						bResult = TRUE;	//make loop end, no research found
					}
				}

			}
		}
		structure = enumStruct();
	}
}

function int findResearch(int _searchStart, int _techTree)
{
	ASSERT(_searchStart >= 0, "findResearch: _searchStart < 0", me);
	ASSERT(_techTree >= 0, "findResearch: _techTree < 0", me);

	retInt = _searchStart;
	while(retInt < numRes[_techTree])
	{
		if((not researchFinished(research[_techTree][retInt], me)) and (not researchStarted(research[_techTree][retInt], me)))
		{
			return(retInt);		//found research
		}
		retInt = retInt + 1;
	}

	retInt = none;		//not found
	return(retInt);
}

//--------------------------------------------------------
//Number of busy structures by type
//--------------------------------------------------------
function int numBusyByType(STRUCTURESTAT _busyStructType)
{
	local	int _result;

	initEnumStruct(FALSE,_busyStructType,me,me);
	structure = enumStruct();
	_result = 0;
	while(structure != NULLOBJECT)
	{
		if(not structureIdle(structure))
		{
			_result = _result + 1;
		}
		structure = enumStruct();
	}

	return(_result);
}

//--------------------------------------------------------
//For how many structures of given type there's a pending
//build (truck is on the way to build or already building)
//--------------------------------------------------------
function int numStatBusy(STRUCTURESTAT _structureToCheck)
{
	_temp = 0;
	initIterateGroup(buildGr);
	tempDroid = iterateGroup(buildGr);
	while(tempDroid != NULLOBJECT)
	{
		if(tempDroid.order == DORDER_BUILD)
		{
			if(tempDroid.stat == _structureToCheck)	//going to build it
			{
				_temp = _temp + 1;
			}
		}
		tempDroid = iterateGroup(buildGr);
	}

	return(_temp);
}

//--------------------------------------------------------
//Total number of trucks are have started building
//something (not just going to the building site)
//--------------------------------------------------------
function int numTrucksBuilding()
{
	retInt = 0;
	initIterateGroup(buildGr);
	tempDroid = iterateGroup(buildGr);
	while(tempDroid != NULLOBJECT)
	{
		if((tempDroid.order == DORDER_BUILD) and (tempDroid.action != DACTION_MOVETOBUILD))	//Started building
		{
			retInt = retInt + 1;
		}
		tempDroid = iterateGroup(buildGr);
	}

	return(retInt);
}

//---------------------------------------------------------
//Returns number of trucks that are on the way to
//build a certain structure type (not building yet)
//---------------------------------------------------------
function int numStatMoveBusy(STRUCTURESTAT _structStatToCheck)
{
	_temp = 0;
	initIterateGroup(buildGr);
	tempDroid = iterateGroup(buildGr);
	while(tempDroid != NULLOBJECT)
	{
		if((tempDroid.order == DORDER_BUILD) and (tempDroid.action == DACTION_MOVETOBUILD)) //Not reached the building site yet
		{
			if(tempDroid.stat == _structStatToCheck)	//going to build it
			{
				_temp = _temp + 1;
			}
		}
		tempDroid = iterateGroup(buildGr);
	}

	return(_temp);
}

//-----------------------------------------------------
function void buildInBase(STRUCTURESTAT _statToBuild)
{
	//dbg(" " & me & ")  Executing buildInBase()");

	temp = 6 * 128;
	temp2 = baseX + (random(temp) - (temp/2));	//Randomize a bit
	temp3 = baseY + (random(temp) - (temp/2));

	bTempResult = pickStructLocation(_statToBuild, ref temp2, ref temp3, me);
	if(bTempResult)
	{
		bDummy = buildUsingClosestTruck(_statToBuild, temp2, temp3);		//can re-use ArgStrStat0
	}

	//dbg(" " & me & ")  End buildInBase()");
}

//-----------------------------------------------------
//Build a structure with the closest truck
//-----------------------------------------------------
function bool buildUsingClosestTruck(STRUCTURESTAT _statToBuild, int _buildX, int _buildY)		//Building coords and STRUCTURESTAT are passed
{
	//dbg(" " & me & ")  Executing buildUsingClosestTruck()");

	tempDroid = closestIdleTruck(_buildX, _buildY);

	if(tempDroid != NULLOBJECT)
	{
		orderDroidStatsLoc(tempDroid, DORDER_BUILD, _statToBuild, _buildX, _buildY);
		//dbg(" " & me & ")  End buildUsingClosestTruck()");
		return(TRUE);
	}

	//dbg(" " & me & ")  End buildUsingClosestTruck()");

	return(FALSE);
}

//-----------------------------------------------------
//Build factories and research facilities dynamically
//-----------------------------------------------------
function void buildBaseStructs()
{
	local	int _maxResFac,_numResFac,_maxFacs,_numFacs,_buildX,_buildY,_range;
	local	bool _bStartedBuild,_bNeedResFac;

	if(idleGroup(buildGr) == 0)
		exit;

	_range = 6 * 128;

	_buildX = baseX + random(_range) - (_range / 2);
	_buildY = baseY + random(_range) - (_range / 2);

	_maxFacs = getStructureLimit(fac, me);
	_maxResFac = getStructureLimit(resFac, me);

	_numFacs = getNumStructures(fac,me);
	_numResFac = getNumStructures(resFac,me);

	/* limit num of facs when critical power or low on defenders */
	if(alert)
	{
		_maxFacs = min(minFacs, _maxFacs);		//limit facs
		_maxResFac = min(2, _maxResFac);		//limit res fac
	}

	/*check if limit reached */
	bResult = ((not structureLimitReached(fac, me)) and (_numFacs < _maxFacs));	//bool = available 	//limit not reahced and not more than allowed at the moment
	_bNeedResFac = ((not structureLimitReached(resFac, me)) and (_numResFac < _maxResFac));

	_bStartedBuild = FALSE;

	/* Build HQ */
	if(getStructure(HQ, me) == NULLOBJECT)	//not built and no one's on the way to build
	{
		//Check if someone's already on the way to build HQ
		result3 = numStatBusy(HQ);

		if(result3 == 0)		//no one's on the way to build
		{
			buildInBase(HQ);
		}
	}

	/* see if we need VTOL factories */
	if((state == stDrop) or (playerPower(me) > highPower) and (defendGr.members >= numDefenders))		//don't waste time, since transporter tech becomes available only after vtolfac is built
	{
		if((_numFacs > 0) and (_numResFac > 0) and isStructureAvailable(vtolfac, me))
		{
			//if(numResearchLeft(me, resUnitTransporter) <= 6)	//don't bother if still to far away from being able to build transporter
			//{
				if(getNumStructures(vtolfac, me) < min(1, getStructureLimit(vtolfac, me)))	//don't try to build more than allowed
				{
					//Check if someone's already on the way to build VTOL fac
					result3 = numStatBusy(vtolfac);

					if(result3 == 0)		//no one's on the way to build
					{
						buildInBase(vtolfac);
						exit;
					}
				}
			//}
		}
	}

	//if((not bResult) and (not _bNeedResFac)){exit;}

	/* build factories and research facilities */
	if(bResult and ((not _bNeedResFac)  or (_numFacs <= _numResFac) or (_numResFac >= 3) or ((_numFacs < minFacs) and (_numResFac >= 1))   ) ) //The only avail left or not enough or (less than min and have at least 1 res)
	{
		//How many trucks are on the way to build factories
		result3 = numStatMoveBusy(fac);	//How many builds are in pending (not in progress already!)

		//dbg(" " & me & ")  buildBaseStructs() - factory - have: " & _numFacs & " pending: " & result3);

		if((_numFacs + result3) < _maxFacs)	//Will not max out
		{
			bResult = pickStructLocation(fac, ref _buildX, ref _buildY, me);
			if(bResult == TRUE)
			{
				//Anyone already wants to build something else on this spot?
				//result3 = buildingSiteBlocked(NULLOBJECT, 128, _buildX, _buildY);

				if(not buildingSiteBlocked(NULLOBJECT, 128, _buildX, _buildY))
				{
					bResult = buildUsingClosestTruck(fac, _buildX, _buildY);		//Building coords and STRUCTURESTAT are passed

					if(bResult)
					{
						_bStartedBuild = TRUE;	//Build successfull
					}
				}
				else
				{
					dbg("buildBaseStructs() - factory someone's building (!!!!!!!!!!)", me);
				}
			}
		}
	}

	if(alert)
		exit;

	/* build res fac */
	if((not _bStartedBuild) and _bNeedResFac)	//Factory unavailable (didn't start build it) and Rec fac available
	{
		//dbg(" " & me & ")  buildBaseStructs() - must build res fac (*)");

		//How many trucks are on the way to build res fac
		result3 = numStatMoveBusy(resFac);	//How many builds are in progress or pending

		if((result3 + _numResFac) < min(_maxResFac, maxResearch))	//Will not max out, or don't build more than required (maxResearch)
		{
			dbg("Building res fac", me);

			bResult = pickStructLocation(resFac, ref _buildX, ref _buildY, me);
			if(bResult == TRUE)
			{
				//Anyone already wants to build something else on this spot?
				//result3 = buildingSiteBlocked(NULLOBJECT, 128, _buildX, _buildY);

				if(not buildingSiteBlocked(NULLOBJECT, 128, _buildX, _buildY))
				{
					bDummy = buildUsingClosestTruck(resFac, _buildX, _buildY);		//Building coords and STRUCTURESTAT are passed
				}
			}
		}
	}

	/* build uplink center */
	if(getNumStructures(uplink,me) >= 1){exit;}
	if(not isStructureAvailable(uplink, me)){exit;}

	if((_numFacs < 1) or (_numResFac < 1)){exit;}	//no facs, no research

	//How many trucks are on the way to build uplink
	result3 = numStatMoveBusy(uplink);	//How many builds are in progress or pending

	if(result3 > 0){exit;}

	_buildX = baseX + random(_range) - (_range / 2);
	_buildY = baseY + random(_range) - (_range / 2);

	bResult = pickStructLocation(uplink, ref _buildX, ref _buildY, me);
	if(bResult == TRUE)
	{
		//Anyone already wants to build something else on this spot?
		//result3 = buildingSiteBlocked(NULLOBJECT, 128, _buildX, _buildY);

		if(not buildingSiteBlocked(NULLOBJECT, 128, _buildX, _buildY))
		{
			bDummy = buildUsingClosestTruck(uplink, _buildX, _buildY);		//Building coords and STRUCTURESTAT are passed
		}
	}


	//dbg(" " & me & ")  End buildBaseStructs()");
}

//---------------------------------------------------------
//	Find droids without a group
//---------------------------------------------------------
function void unassignedDroids(GROUP defendersGr, GROUP buildersGr)
{
	_temp = 0;

	//Iterate through all player droids
	InitEnumDroids(me,me);
	tempDroid = EnumDroid();
	while(tempDroid != NULLOBJECT)
	{
		if(not hasGroup(tempDroid))
		{
			if(tempDroid.droidType == DROID_CONSTRUCT)
			{
				groupAddDroid(buildersGr, tempDroid);
				_temp = _temp + 1;
			}
			else
			{
				if((tempDroid.droidType != DROID_TRANSPORTER) and
				(tempDroid.droidType != DROID_COMMAND))
				{
					groupAddDroid(defendersGr, tempDroid);
					_temp = _temp + 1;
				}
			}
		}
		tempDroid = EnumDroid();
	}

	dbg("found " & _temp & " unassigned droids", me);
}

//---------------------------------------------------------------
//Returns how many droids are already on the way to build the
//same structure on the same spot (like helpbuild)
//---------------------------------------------------------------
function int numBuildSameBuilding(STRUCTURESTAT _checkStat, int _x, int _y)
{
	retInt = 0;

	initIterateGroup(buildGr);
	tempDroid = iterateGroup(buildGr);
	while(tempDroid != NULLOBJECT)
	{
		if(tempDroid.order == DORDER_BUILD)
		{
			if(tempDroid.stat == _checkStat)	//Same struct type
			{
				//Within some range
				if(distBetweenTwoPoints(_x, _y, tempDroid.orderx , tempDroid.ordery) <= 128)
				{
					retInt = retInt + 1;
				}
			}
		}
		tempDroid = iterateGroup(buildGr);
	}

	return(retInt);
}

function int numTrucksSameOrder(int _orderIndex)
{
	retInt = 0;

	initIterateGroup(buildGr);
	tempDroid = iterateGroup(buildGr);
	while(tempDroid != NULLOBJECT)
	{
		if(tempDroid.order == _orderIndex)	//right order type
		{
			retInt = retInt + 1;
		}
		tempDroid = iterateGroup(buildGr);
	}

	return(retInt);
}


//---------------------------------------------------------------
//Returns how many trucks have order in a range
//---------------------------------------------------------------
function int numTrucksOrderInRange(int _rangex, int _rangey, int _range, int _order)
{
	retInt = 0;

	initIterateGroup(buildGr);
	tempDroid = iterateGroup(buildGr);
	while(tempDroid != NULLOBJECT)
	{
		if((_order < 0) or (tempDroid.order == _order))	//Any order or right order type
		{
			//Within some range
			if(distBetweenTwoPoints(_rangex, _rangey, tempDroid.orderx , tempDroid.ordery) <= _range)
			{
				retInt = retInt + 1;
			}
		}
		tempDroid = iterateGroup(buildGr);
	}

	return(retInt);
}

//---------------------------------------------------------------
//Returns how many trucks have the same order location
//---------------------------------------------------------------
function int numTrucksSameOrderLoc(int _x, int _y, int _orderIndex)
{
	retInt = 0;

	initIterateGroup(buildGr);
	tempDroid = iterateGroup(buildGr);
	while(tempDroid != NULLOBJECT)
	{
		if((_orderIndex < 0) or (tempDroid.order == _orderIndex))	//Any order or right order type
		{
			//Within some range
			if(distBetweenTwoPoints(_x, _y, tempDroid.orderx , tempDroid.ordery) <= 64)
			{
				retInt = retInt + 1;
			}
		}
		tempDroid = iterateGroup(buildGr);
	}

	return(retInt);
}

//---------------------------------------------------------------
//	Find out if a truck is already building on the spot where
//	another truck might try to build and will fail
//---------------------------------------------------------------
function bool buildingSiteBlocked(DROID _truck, int _radius, int _x, int _y)
{
	initIterateGroup(buildGr);
	tempDroid = iterateGroup(buildGr);
	while(tempDroid != NULLOBJECT)
	{
		if(tempDroid != _truck)		//Not himself (_truck allowed to be NULLOBJECT)
		{
			if((tempDroid.order == DORDER_BUILD) or (tempDroid.order == DORDER_LINEBUILD))
			{
				//Within some range
				if(distBetweenTwoPoints(_x, _y, tempDroid.orderx , tempDroid.ordery) <= _radius)
				{
					return(TRUE);		//Spot busy
				}
			}
		}
		tempDroid = iterateGroup(buildGr);
	}

	return(FALSE);
}

event structDestroyed(inactive)
{
	local	int i;
	if(structure == NULLOBJECT)
		exit;

	/* Update ghost data */
	if(structure.player == me)
	{
		if((structure.stat == wall) or (structure.stattype == REF_DEFENSE))
		{
			/* Find structure that was destroyed */
			i = 0;
			while(i < maxGhosts)
			{
				if((ghostx[i] == structure.x) and (ghosty[i] == structure.y) and (ghostStat[i] == structure.stat))
				{
					dbg("FOUND DESTROYED STRUCTURE!!!!!", me);
					ghostDead[i] = TRUE;
					i = maxGhosts;			//exit
				}
				i = i + 1;
			}
		}
	}

	/* remember we lost LasSat */
	if(structure.stat == lasSat)
	{
		lasSatState[me] = lsNone;
	}
}

event structBuilt(inactive)
{
	//dbg(" " & me & ")  CALLBACK - built (" & structure.x & "-" & structure.y & ")", me);

	if(structure == NULLOBJECT)
	{
		MsgBox("structBuilt - structure NULLOBJECT");
		exit;}

	if(droid == NULLOBJECT)
	{
		MsgBox("structBuilt - droid NULLOBJECT");
		exit;}

	/* remember we have LasSat */
	if(structure.stat == lasSat)
	{
		dbg("buildInitialDefenses() - lassat built", me);
		resetLasSat();
		lasSatState[me] = lsRecharging;
	}

	/* build next anti-rush defense if just finished one,
	don't let other building routines intercept this truck */
	if((droid == initialDefensesTruck) and (not initialDefensesFinished))
	{
		buildInitialDefenses(TRUE);
		exit;
	}

	/* give allies vision of the entire map */
	if(structure.stat == uplink)
	{
		refreshAllyRadar();
	}


	feature2 = NULLOBJECT;	//Not found right now
	result = 99999;

	range = (50 * 128);	//(15 * 128);	//max range to look for further oil
	bResult = FALSE;	//can we build using callback truck?

	/* check if it's the right structure type */
	if(structure.stattype == REF_DEFENSE)
	{
		/* find derrick we were building defense for */
		closestDerrick(structure.x, structure.y);

		if(retStruct == NULLOBJECT){exit;}

		/* exit if this defense was not built for a derrick */
		if(distBetweenTwoPoints(retStruct.x, retStruct.y, structure.x, structure.y) > defensesRange)	//closest derrick - built defense
		{
			exit;
		}

		structure = retStruct;		//remember derrick for defenses building
	}
	else if(structure.stat == derrick)
	{
		/* check if we can build another derrick near this one */
		if(not structureLimitReached(derrick, me))
		{
			initGetFeature(oilRes,me,me);
			feature = getFeature(me);
			while(feature != NULLOBJECT)
			{
				result2 = distBetweenTwoPoints(droid.x, droid.y, feature.x, feature.y);
				if(result2 < range)	//oil very near
				{
					if(result2 < result)	//closest one
					{
						//make sure not dangerous
						if(not threatInRange(me, feature.x, feature.y, threatRange, FALSE))
						{
							result = result2;
							feature2 = feature;	//Remember and return it
						}
						else
						{
							dbg("dangerous to build more oil", me);
						}
					}
				}
				feature = getFeature(me);
			}

			bResult = FALSE;	//can we build using callback truck?

			//now check if any other trucks were sent to build there already
			if(feature2 != NULLOBJECT)	//found oil
			{
				bResult = TRUE;

				initIterateGroup(buildGr);
				droid2 = iterateGroup(buildGr);
				while(droid2 != NULLOBJECT)
				{
					if((droid2.orderx == feature2.x) and (droid2.ordery == feature2.y))
					{
						bResult = FALSE;	//someone already going to build

						//check if it's closer than callback droid
						if(distBetweenTwoPoints(droid2.x, droid2.y, feature2.x, feature2.y) > result)
						{
							//dbg(" " & me & ")  CALLBACK truck - sending other droid back to base", me);
							orderDroid(droid2, DORDER_RTB);		//send back to base
							bResult = TRUE;	//(assuming AI only sends 1 truck at each oil !!!)
						}
					}
					droid2 = iterateGroup(buildGr);
				}
			}

			if(bResult)		//safe to build with callback droid
			{
				//dbg(" " & me & ")  CALLBACK truck - building derrick with CALLBACK truck (" & feature2.x & "-" & feature2.y & ")", me);
				orderDroidStatsLoc(droid, DORDER_BUILD, derrick, feature2.x, feature2.y);
				exit;	//exit here
			}
		}
		else
		{
			dbg("can't build more derricks", me);
		}
	}
	else
	{
		exit;
	}

	//if(bResult){exit;}		//already started building with this truck

	if(structure == NULLOBJECT){exit;}	//don't have a derrick to defend

	if(state == stDefending){exit;}

		//--------------------------------------------------------
		//Check if derrick has at least min num of defenses nearby
		//--------------------------------------------------------

		/* find best defense */
		best = findBestDefense();

		if(best == none){exit;}

		/* make sure derrick is not in the base */
		//result = isInMyBase(structure.x, structure.y);

		if(isInMyBase(structure.x, structure.y))	//in base, so exit
		{
			exit;
		}

		range = defensesRange;	//defenses range

		/* is anyone already on the way to build something nearby? */
		//result = buildingSiteBlocked(droid, range, structure.x, structure.y);

		if(buildingSiteBlocked(droid, range, structure.x, structure.y))	//yes
		{
			exit;	//someone will build something here (probably a defence, so exit)
		}


		/* check if too many defenses around already */
		result3 = numFriendlyWeapStructsInRange(me, structure.x, structure.y, defensesRange);

		/* make sure not too many trucks are busy with defenses */
		result = numBuildingNoBaseDefenses();

		//if((result >= maxDefenseTrucks) and (result3 >= 1))
		if(result3 >= numOilDef)
		{
			exit;		//has basic defense, so exit
		}

		/* check if this derrick has a defense location stored */
		result = getOilDefendLocIndex(me, structure.x, structure.y);
		if(bLearn)
		{
			if(result >= 0)		//we have a defense loc stored for this derrick
			{
				/* check if priority is high enough */
				if(recallOilDefendLoc(me, result, ref x, ref y, ref result2))	//get priority
				{
					if(result2 >= minOilRecallPrior)	//prior high enough
					{
						circlePerimPoint(structure.x, structure.y, ref x, ref y, oilExperRange);

						if(pickStructLocation(def[best], ref x, ref y, me))
						{
							orderDroidStatsLoc(droid, DORDER_BUILD, def[best], x, y);
							exit;
						}
					}
				}
			}
		}

		if(result3 >= minOilDef)	//use minOilDef for normal defenses
		{
			exit;	//already has a basic defence, so exit
		}

		/* this derrick doesn't have a defense loc, build the normal way */
		buildX = structure.x;
		buildY = structure.y;

		if(pickStructLocation(def[best], ref buildX, ref buildY, me))
		{
			orderDroidStatsLoc(droid, DORDER_BUILD, def[best], buildX, buildY);
		}
	//}
}

event droidTakeOverEv(inactive)
{
	if(droid != NULLOBJECT)
	{
		if(droid.player == me)
		{
			assignDroid(droid);
		}
	}
	else
	{
		MsgBox("droidTakeOverEv - NULLOBJECT passed");
	}
}

//deal with a droid being built
event droidBuilt(inactive)
{
	assignDroid(droid);
}

function void assignDroid(DROID _droid)
{
	if(isVtol(_droid))
	{
		groupAddDroid(vtolGr, _droid);
	}
	else
	{
		setDroidSecondary(_droid, DSO_ATTACK_RANGE, DSS_ARANGE_LONG);
		setDroidSecondary(_droid, DSO_HALTTYPE, DSS_HALT_GUARD);

		if(_droid.droidType == DROID_CONSTRUCT)				// if constructor _droid
		{
			groupAddDroid(buildGr, _droid);

			/* make it build anti-rush defenses if still not finished */
			if(not initialDefensesFinished)
			{
				if((buildGr.members >= 5) and (initialDefensesTruck == NULLOBJECT))
				{
					dbg("buildInitialDefenses() assigned truck", me);
					initialDefensesTruck = _droid;
					buildInitialDefenses(TRUE);
					dbg("buildInitialDefenses() assigned end", me);
					return;
				}
			}

		}
		else if(_droid.droidType == DROID_TRANSPORTER)
		{
			dbg("built transporter", me);

			temp = 0;
			bResult = TRUE;
			while((temp < 10) and bResult)
			{
				if(transporter[temp] == NULLOBJECT)
				{
					dbg("built transporter " & temp, me);
					transporter[temp] = _droid;
					orderDroidLoc(_droid, DORDER_MOVE, baseX, baseY);
					bResult = FALSE;
				}
				temp = temp + 1;
			}
		}
		else if(_droid.droidType == DROID_REPAIR)
		{
			groupAddDroid(defendRepairGr, _droid);
		}
		else if(_droid.weapon == weaponBB)
		{
			//prfunction void BBs from wasting ammo on units
			//setDroidSecondary(_droid, DSO_ATTACK_LEVEL, DSS_ALEV_ATTACKED);
			groupAddDroid(defendGr, _droid);
		}
		else
		{
			bResult = FALSE;

			//don't add to scouts if not early-game anymore and not enough defenders
			bResult2 = TRUE;
			if((defendGr.members < numDefenders) and (gameTime > 5000))
			{
				bResult2 = FALSE;
			}

			if((addScout == 0) and (not lowMilitary) and (bResult2))	//for scouts?
			{
				if(enemyScoutGr.members < numEnemyScouts)
				{
					groupAddDroid(enemyScoutGr, _droid);
					bResult = TRUE;
				}
				else if(scoutGr.members < numScouts)
				{
					groupAddDroid(scoutGr, _droid);
					bResult = TRUE;
				}
			}

			if((addScout != 0) or (not bResult))		//for attackers, or scouts were full
			{
				if((defendX != none) and (defendY != none))
				{
					result = numFriendlyWeapObjInRange(me, defendX, defendY, (10 * 128), FALSE);
					result2 = numEnemyWeapObjInRange(me, defendX, defendY, (10 * 128), FALSE);

					if((defendGr.members >= minDefenders) or (result >= result2))	//don't send one by one or if dangerous
					{
						orderDroidLoc(_droid, DORDER_SCOUT, defendX, defendY);
					}
				}

				groupAddDroid(defendGr, _droid);

				/* remember we'd finished building first-time defenders */
				if((defendGr.members >= minDefenders) or (gameTime > (8 * 600)))		//8 mins
					bFirstTimeDefenders = FALSE;
			}

			addScout = addScout + 1;
			if(addScout > addScoutInterval)
			{
				addScout = 0;		//add to scouts next one
			}

		}
	}
}


//==============================================================================================
//	>>>>>>>>>>>>>>>>>>>>>>>>	MILITARY STUFF		<<<<<<<<<<<<<<<<<<<<<<<<<
//==============================================================================================
event repairDefendDroids(inactive)
{
	if(defendRepairGr.members == 0){exit;}
	if(defendGr.members == 0){exit;}

	groupRepairGroup(defendGr, defendRepairGr);

	/* repair the repair droids if idle */
	if((defendRepairGr.members > 1) and (idleGroup(defendRepairGr) > 0))
	{
		groupRepairGroup(defendGr, defendRepairGr);
	}
}

function void groupRepairGroup(GROUP _damagedGr, GROUP _repairerGr)
{
	_temp = maxDamageLevels - 1;	//start with heavyDamage, don't reset before loop to save CPU time
	_temp2 = 0;

	initIterateGroup(_repairerGr);
	_droid = iterateGroup(_repairerGr);
	while(_droid != NULLOBJECT)
	{
		if(_droid.order != DORDER_DROIDREPAIR)	//not already busy
		{
			/* look for a damaged unit, starting search with heavily damaged units */
			_droid2 = NULLOBJECT;		//damaged droid
			while((_temp >= 0) and (_droid2 == NULLOBJECT))	//first look for heavilyDamaged units, going up to lightDamage
			{
				/* find damaged droid no one is repairing yet */
				_droid2 = closestDamagedGroupDroid(me, _damagedGr, damageLevel[_temp], _droid.x, _droid.y, 0);
				if(_droid2 == NULLOBJECT)
				{
					_temp = _temp - 1;	//go to lighter damage levels
				}
			}

			if((_droid2 != NULLOBJECT) and (_droid != _droid2))	//found someone and him going to repair himself
			{
				//dbg("FOUND DAMAGED UNIT!!!! (for unit " & _temp2 & ")", me);
				orderDroidObj(_droid, DORDER_DROIDREPAIR, _droid2);
			}
			else if((_droid.order == DORDER_NONE) or (_droid.target == _droid))	//if idle or auto-repairing
			{
				/* if idle, check it's not too far away from the base */
				//_range = baseRange + defendCorridor;	//allow to repair defenders in the corridor as well
				//if((_droid.order == DORDER_NONE) and (_droid.target == NULLOBJECT))	//if not repairing
				//{
				//	_range = baseRange;	//move closer to base
				//}

				_range = baseRange;

				if(distBetweenTwoPoints(_droid.x, _droid.y, baseX, baseY) > _range)
				{
					//dbg("ORDERING REPAIR UNIT BACK TO BASE", me);
					_x = _droid.x;
					_y = _droid.y;
					circlePerimPoint(baseX, baseY, ref _x, ref _y, baseRange);	//send back to base
					orderDroidLoc(_droid, DORDER_MOVE, _x, _y);
				}
			}

			//don't reset _temp and don't start over for every repair unit, since nothing changes
		}

		_temp2 = _temp2 + 1;
		_droid = iterateGroup(_repairerGr);
	}
}

/* Goes through trucks and compares target */
function DROID getTruckByTarget(BASEOBJ _target)
{
	local DROID _droid;

	initIterateGroup(buildGr);
	_droid = iterateGroup(buildGr);
	while(_droid != NULLOBJECT)
	{
		if(_droid.target == _target)
			return _droid;

		_droid = iterateGroup(buildGr);
	}

	return NULLOBJECT;
}

function void buildTanks()
{
	//dbg(" " & me & ")  Executing buildTanks()");

	if(getDroidCount(me) >= unitLimit)
		exit;

	count = 0;

	/* decide if want to use heavy templates */
	count3 = 0;
	if((playerPower(me) > muchoPower) and (state != stDefending))
	{
		count3 = 1;
	}

	initEnumStruct(FALSE,fac,me,me);
	structure = enumStruct();
	while(structure != NULLOBJECT)
	{
		if(structureComplete(structure))
		{
			count = count + 1;		//'id' of fac

			if(structureIdle(structure))
			{
				//Build BBs
				//------------------
				bResult = FALSE;
				if(haveBB and (defendGr.members >= numDefenders))		//BB researched and not low on tanks
				{
					if((not lowMilitary) and (not alert))
					{
						result = numTemplatesInProduction(tmplBB,me);	//how many already building
						if(result < 1)		//not too many already
						{
							result = result + numDroidsByComponent(weaponBB, me, me);	//num BBs

							//result = result + bbGr.members;		//num BBs
							if(result < numBB)	//not too many
							{
								if(skCanBuildTemplate(me, structure, tmplBB))
								{
									bResult = TRUE;
									buildDroid(tmplBB, structure, me, 1);
								}
							}
						}
					}
				}

				//Build repair units
				//------------------
				if(not bResult)		//didn't start building BB
				{
					result = defendGr.members / 4;		//1 rep for 4 units

					if((defendRepairGr.members < result) and (defendRepairGr.members < maxDefendRepairers))	//still not enough
					{
						//result = maxDefendRepairers - result;	//how many left to build

						result2 = numRepairersInProduction();
						result = result - (result2 + defendRepairGr.members);	//how many really left
						if((result2 == 0) and (result > 0))		//not too many at a time and not too many built already
						{
							result = numRepairTmpl - 1;
							while((result >= 0) and (not bResult))
							{
								if(skCanBuildTemplate(me, structure, tmplRep[result]))
								{
									bResult = TRUE;
									buildDroid(tmplRep[result], structure, me, 1);
								}
								result = result - 1;
							}
						}
					}
				}


				//Build attack units
				//-------------------
				if(not bResult)		//didn't start building BB or repair unit
				{
					//Find best available templates
					result = numTemplates;
					result2 = 0;
					while((result > 0) and (result2 < 3))
					{
						result = result - 1;
						if(skCanBuildTemplate(me,structure, tmpl[count3][result]))
						{
							tmplOK[result2] = tmpl[count3][result];
							result2 = result2 + 1;
						}
					}

					if(result2 > 0)		//found a template to build
					{
						buildDroid(tmplOK[random(result2)], structure, me, 1);

						//if((alert) and (not lowMilitary))
						//{
						//	if(
						//	numTemplatesInProduction(truck,me);
						//}
					}
				}
			}

			/* build tanks only in first 3 factories (-trucks) if alert of non-military type */
			count2 = count - numTemplatesInProduction(truck,me);
			if((count2 >= 3) and (alert and (not lowMilitary)))
			{
				exit;
			}
		}
		structure = enumStruct();
	}

	//dbg(" " & me & ")  End buildTanks()");
}

function void buildVTOLs()
{
	if(getDroidCount(me) >= unitLimit)
	{
		exit;}

	count = 0;

	/* decide if want to use heavy templates */
	count3 = 0;
	//if((playerPower(me) > muchoPower) and (state != stDefending))
	//{
	//	count3 = 1;
	//}

	initEnumStruct(FALSE,vtolfac,me,me);
	structure = enumStruct();
	while(structure != NULLOBJECT)
	{
		if(structureComplete(structure))
		{
			count = count + 1;		//'id' of fac

			if(structureIdle(structure))
			{

				//Build attack units
				//-------------------
				//if(not bResult)		//didn't start building BB or repair unit
				//{
					//Find best available templates
					result = numVtolTemplates;
					result2 = 0;
					while((result > 0) and (result2 < 2))	//2 best tmplates
					{
						result = result - 1;
						if(skCanBuildTemplate(me,structure, vtoltmpl[count3][result]))
						{
							tmplOK[result2] = vtoltmpl[count3][result];
							result2 = result2 + 1;
						}
					}

					if(result2 > 0)		//found a template to build
					{
						buildDroid(tmplOK[random(result2)], structure, me, 1);
					}
				//}
			}

			/* build vtols only in first 3 factories, if alert of non-military type */
			if((count >= 3) and (alert and (not lowMilitary)))
			{
				exit;
			}
		}
		structure = enumStruct();
	}
}


//
//
//

function int numRepairersInProduction()
{
	_temp2 = 0;
	_temp = 0;
	while(_temp < numRepairTmpl)
	{
		_temp2 = _temp2 + numTemplatesInProduction(tmplRep[_temp],me);
		_temp = _temp + 1;
	}

	return(_temp2);
}

//how many trucks are building defenses
function int numBuildingDefenses()
{
	//return	- number of busy trucks

	temp2 = 0;		//How many are ordered to build a defense
	temp = 0;
	while(temp < numDef)
	{
		if(isStructureAvailable(def[temp],me))
		{
			temp3 = numStatBusy(def[temp]);	//How many going to build it
			temp2 = temp2 + temp3;
		}

		temp = temp + 1;
	}

	return(temp2);
}

function int numBuildingBaseDefenses()
{
	//return	- number of busy trucks

	temp2 = 0;		//How many are ordered to build a defense
	temp = 0;
	while(temp < numDef)
	{
		if(isStructureAvailable(def[temp],me))
		{
			temp3 = 0;
			initIterateGroup(buildGr);
			tempDroid = iterateGroup(buildGr);
			while(tempDroid != NULLOBJECT)
			{
				if(tempDroid.order == DORDER_BUILD)
				{
					if(tempDroid.stat == def[temp])	//going to build it
					{
						if(distBetweenTwoPoints(tempDroid.orderx, tempDroid.ordery, baseX, baseY) <= (baseRange + defendCorridor))	//within base
						{
							temp3 = temp3 + 1;
						}
					}
				}
				tempDroid = iterateGroup(buildGr);
			}


			temp2 = temp2 + temp3;
		}

		temp = temp + 1;
	}

	return(temp2);
}

function int numBuildingNoBaseDefenses()
{
	//return	- number of busy trucks

	temp2 = 0;		//How many are ordered to build a defense
	temp = 0;
	while(temp < numDef)
	{
		if(isStructureAvailable(def[temp],me))
		{
			temp3 = 0;
			initIterateGroup(buildGr);
			tempDroid = iterateGroup(buildGr);
			while(tempDroid != NULLOBJECT)
			{
				if(tempDroid.order == DORDER_BUILD)
				{
					if(tempDroid.stat == def[temp])	//going to build it
					{
						if(distBetweenTwoPoints(tempDroid.orderx, tempDroid.ordery, baseX, baseY) > (baseRange + defendCorridor))	//not within base
						{
							temp3 = temp3 + 1;
						}
					}
				}
				tempDroid = iterateGroup(buildGr);
			}


			temp2 = temp2 + temp3;
		}

		temp = temp + 1;
	}

	return(temp2);
}

function DROID closestIdleTruck(int _x, int _y)
{
	local DROID _closestTruck, _tempTruck;
	local int _closestDist, _tempDist;

	_closestTruck = NULLOBJECT;
	_closestDist = 99999;

	initIterateGroup(buildGr);
	_tempTruck = iterateGroup(buildGr);
	while(_tempTruck != NULLOBJECT)
	{
		if((_tempTruck.order == DORDER_NONE) or (_tempTruck.order == DORDER_RTB))
		{
			_tempDist = distBetweenTwoPoints(_x, _y, _tempTruck.x, _tempTruck.y);
			if(_tempDist < _closestDist)
			{
				_closestDist = _tempDist;
				_closestTruck = _tempTruck;
			}
		}
		_tempTruck = iterateGroup(buildGr);
	}

	return _closestTruck;
}

//------------------------------------------------
//Build some defenses on startup to prevent rushes
//------------------------------------------------
function void buildInitialDefenses(bool _bForceBuild)	//returns TRUE if finished
{
	//_bForceBuild - if returned from callback, truck order is not reste to DORDER_NONE yet, but it's idle

	if(not bLearn){return;}		//only uses learn data so far
	if(state == stDefending){return;}		//don't waste power

	/* if no builder, find one */
	if(initialDefensesTruck == NULLOBJECT)
	{
		if(buildGr.members >= 5)	//don't take away any trucks if low on them
		{
			initialDefensesTruck = closestIdleTruck(baseX, baseY);
		}
	}

	if(initialDefensesTruck == NULLOBJECT)
	{
		//dbg("buildInitialDefenses() - no truck", me);
		return;		//try again later
	}

	if((initialDefensesTruck.order != DORDER_NONE) and (not _bForceBuild))
	{
		//dbg("buildInitialDefenses() - truck busy", me);
		return;		//try again later
	}

	range = (7 * 128);		//"too-many-built-in-range" range
	best = none;		//Best defense

	/* find best defense */
	best = findBestDefense();
	if(best == none){return;}	//No defenses researched

	//Now iterate through the stored locations
	//----------------------------------------
	result2 = getBaseDefendLocCount();		//how many locations there are stored (max)

	while(curInitialBaseDef <= maxInitialBaseDef)
	{
		count = 0;	//start from the first stored location again

		while((count < result2) and (count < maxInitialDefSites))		//don't build at more than maxInitialDefSites in total
		{
			if(recallBaseDefendLoc(me, count, ref x, ref y, ref result3))	//TRUE if stored
			{
				if(result3 > 0)		//attacked atleast 1 time (highest priority is always at the top)
				{
					//move coords closer to base
					circlePerimPoint(baseX, baseY, ref  x, ref y, (baseRange + defendCorridor / 2));	//move locations to the base perimeter

					buildX = x;	//remember coords before using pickStructLocation() to check if corrected coords too far away
					buildY = y;

					//count if not too many built on this site already (using corrected coords!)
					if(numFriendlyWeapStructsInRange(me, buildX, buildY, range) < curInitialBaseDef)	//don't build too many
					{
						if(pickStructLocation(def[best], ref buildX, ref buildY, me))
						{
							//don't allow to build outside of the range
							if(distBetweenTwoPoints(buildX, buildY, x, y) < range)		//coords corrected with pickStructLocation() not too far away from orig
							{
								orderDroidStatsLoc(initialDefensesTruck, DORDER_BUILD, def[best], buildX, buildY);

								//dbg("buildInitialDefenses() - started", me);

								return;	/* this one successfull, try again next time */
							}
						}
					}
				}
			}
			count = count + 1;
		}
		curInitialBaseDef = curInitialBaseDef + 1;	/* finished this round, rise defenses number per site and start over again if not finished */
		dbg("buildInitialDefenses() - RAISED curInitialBaseDef", me);
	}


	stopInitialDefenses();
	return;
}

function void stopInitialDefenses()
{
	/* finished for real: no open sites with no defenses left, stop the whole process */
	initialDefensesFinished = TRUE;
	dbg("buildInitialDefenses() - FINISHED", me);

	/* add builder back to the buildGr if finished */
	if(initialDefensesTruck != NULLOBJECT)
	{
		dbg("buildInitialDefenses() - ADDED BACK THE TRUCK", me);
		groupAddDroid(buildGr, initialDefensesTruck);
	}
}

function void buildDefenses()
{
	local bool _buildStarted;

	//dbg(" " & me & ")  buildDefenses()");

	if(not bLearn){exit;}
	if(idleGroup(buildGr) == 0){exit;}

	//MsgBox("buildDefenses()");

	range = (7 * 128);		//"too-many-built-in-range" range
	best = none;		//Best defense

	//How many are ordered to build a defense?
	result = numBuildingBaseDefenses();
	if(result >= maxBaseDefenseTrucks){exit;}		//Not too many busy with defenses already

	/* find best defense */
	best = findBestDefense();
	if(best == none){exit;}	//No defenses researched

	bResult = FALSE;	//started to build anything?

	//Now iterate through the stored locations
	//---------------------------------------
	result2 = getBaseDefendLocCount();		//how many locations there are stored (max)
	count = 0;

	count4 = 0;
	while((count < result2) and (count4 < 2) and (count < maxBaseDefenseLoc))		//pick 2 best but don't build at more than maxBaseDefenseLoc in total
	{
		if(recallBaseDefendLoc(me, count, ref x, ref y, ref result3))	//TRUE if stored
		{
			if(result3 > 2)		//at least priority of 2
			{
				//move coords closer to base
				circlePerimPoint(baseX, baseY, ref  x, ref y, (baseRange + defendCorridor / 2));	//move locations to the base perimeter

				buildX = x;	//remember coords before using pickStructLocation() to check if corrected coords too far away
				buildY = y;

				//count if not too many built on this site already (using corrected coords!)
				//if(numStructsByTypeInRange(me, me, REF_DEFENSE, buildX, buildY, range) < numBaseDef)	//max
				if(numFriendlyWeapStructsInRange(me, buildX, buildY, range) < numBaseDef)
				{
					if(pickStructLocation(def[best], ref buildX, ref buildY, me))
					{
						//don't allow to build outside of the range
						if(distBetweenTwoPoints(buildX, buildY, x, y) < range)		//coords corrected with pickStructLocation() not too far away from orig
						{
							//Make sure not too many building already
							//--------------------------------------------
							retInt = numTrucksOrderInRange(buildX, buildY, (4 * 128), DORDER_BUILD);

							if(retInt == 0)	//max 1
							{
								intOK[count4] = count;
								count4 = count4 + 1;		//picked another one
							}
						}
					}
				}
			}
		}
		count = count + 1;
	}

	if(count4 == 0){exit;}		//couldn't recall any locations

	//Choose a random site
	//--------------------------------------------
	result = intOK[random(count4 - 1)];

	//dbg(" " & me & ")  defendDefenses() - building defense at location #" & result & " !!!!!!!!!!!!");

	recallBaseDefendLoc(me, result, ref x, ref y, ref temp2);

	//move coords closer to base
	circlePerimPoint(baseX, baseY, ref x, ref y, (baseRange + defendCorridor / 2));

	buildX = x;	//remember coords before using pickStructLocation() to check if corrected coords too far away
	buildY = y;

	if(pickStructLocation(def[best], ref buildX, ref buildY, me))
	{
		//don't allow to build outside of the range
		if(distBetweenTwoPoints(buildX, buildY, x, y) < range)		//coords corrected with pickStructLocation() not too far away from orig
		{
			_buildStarted = buildUsingClosestTruck(def[best], buildX, buildY);

			if(_buildStarted)
			{
				bResult = TRUE;	//Build successfull

				tLastBaseDefense = gameTime / 10;

				//dbg(" " & me & ")   building on base defense location # " & result & " !!!!!");
				//if((result + count3) >= 5){exit;}		//Not too many busy with defenses already
			}
		}
	}

	//dbg(" " & me & ")  * buildDefenses()");
}

function int numDefenses()
{
	retInt = 0;
	temp = 0;
	while(temp < numDef)
	{
		retInt = retInt + getNumStructures(def[temp],me);
		temp = temp + 1;
	}

	return(retInt);
}

function int numBaseDefenses()
{
	retInt = 0;
	temp = 0;
	while(temp < numDef)
	{
		initEnumStruct(FALSE,def[temp],me,me);
		tempStruct = enumStruct();
		while(tempStruct != NULLOBJECT)
		{
			if((tempStruct.x < maxx) and (tempStruct.x > minx))
			{
				if((tempStruct.y < maxy) and (tempStruct.y > miny))
				{
					retInt = retInt + 1;
				}
			}
			tempStruct = enumStruct();
		}
		temp = temp + 1;
	}

	return(retInt);
}



event objectAttacked(inactive)
{
	if(obj == NULLOBJECT){exit;}
	if(obj2 == NULLOBJECT){exit;}

	if(obj.player == obj2.player){exit;}

	attacked[obj2.player] = attacked[obj2.player] + 1;	//remember how many times attacked by him

	//check if attacked object is in the base
	//---------------------------------------

	if(distBetweenTwoPoints(baseX, baseY, obj.x, obj.y) < (baseRange + defendCorridor))	//baseRange + corridor where defenders can stay
	{
/*
		if(objectHasIndirectWeapon(obj2))
		{
			dbg("attacked by arty in the base", me);

			if(numEnemyWeapObjInRange(me, obj2.x, obj2.y, (5 * 128), FALSE) < defendGr.members)
			{
				dbg("attacking arty", me);
				orderGroupObj(defendGr, DORDER_ATTACK, obj2);
			}
		}
*/

		if(obj2.type == OBJ_DROID)				//attacker is a droid
		{
			if(not isVtol(objToDroid(obj2)))		//not vtol
			{
				if(bLearn)
				{
					storeBaseDefLocEv();
				}
			}
			else	/* check if we have to build some AAs asap */
			{
				if(knowBase[obj2.player])
				{
					exit;		//other routine does it in this case
				}

				x = obj.x;
				y = obj.y;
				range = (5 * 128);	//too many on spot range

				if(numAAinRange(me, me, x, y, range) >= 5)
				{
					exit;
				}

				best = findBestAA();
				if(best == none){exit;}

				buildX = x;	buildY = y;
				/* make sure we can build and won't be built too far away from orig loc */
				if(not pickStructLocation(AA[best], ref buildX, ref buildY, me))
				{
					exit;
				}

				if(distBetweenTwoPoints(buildX, buildY, x, y) > range)	//build loc moved too far away
				{
					exit;	//original site was probably blocked, don't build too far away from orig site
				}

				dbg("building AA defense, since don't see attacker's base", me);

				/* build AA */
				buildOnMap(AA[best], buildX, buildY);
			}
		}
	}
	else	//outside of the base
	{
		/* learn oil defense location */
		//result = isNearOil(obj.x, obj.y);

		if(isNearOil(obj.x, obj.y))
		{
			if(bLearn)
			{
				storeOilDefLocEv();
			}
		}
	}

	/* check if we can take them down easily, even outside of the base */
	if(obj2.type == OBJ_DROID)		//attacker is a droid
	{
		if(isVtol(objToDroid(obj2)))		//vtol
		{
			exit;
		}
	}

	range = baseRange * 3 / 2;	//1.5
	if(objectHasIndirectWeapon(obj2))
	{
		range = baseRange * 2;		//can be further away
	}

	if(distBetweenTwoPoints(baseX, baseY, obj2.x, obj2.y) < range)	//not too far
	{
		if(numEnemyWeapObjInRange(me, obj2.x, obj2.y, (6 * 128), FALSE) < (defendGr.members - 1))	//safe
		{
			//dbg("actively defending the base", me);

			baseDefendObj = obj2;

			/* attack with idle defenders */
			initIterateGroup(defendGr);
			droid = iterateGroup(defendGr);
			while(droid != NULLOBJECT)
			{
				if((droid.order != DORDER_ATTACK) and (droid.order != DORDER_EMBARK))
				{
					orderDroidObj(droid, DORDER_ATTACK, baseDefendObj);	//attack enemy
				}
				droid = iterateGroup(defendGr);
			}
		}
	}
}

event droidAttacked(inactive)
{
	if(droid.player != me)
		exit;

	/* Make defenders retreat if heavily damaged tosave units */
	if(groupMember(defendGr, droid))
	{
		if(droid.health < 45)
		{
			if(distBetweenTwoPoints(baseX, baseY, droid.x, droid.y) > baseRange)
			{
				if(defendGr.health > 50)		//wouldn't make sense if all half-dead
				{
					x = droid.x;
					y = droid.y;
					circlePerimPoint(baseX, baseY, ref x, ref y, baseRange - (2* 128));		//retreat behind defense lines
					orderDroidLoc(droid, DORDER_MOVE, x, y);
				}
			}
		}
	}
}

//-----------------------------------------------------------
//Structure attacked CALLBACK
//-----------------------------------------------------------
event structureAttacked(inactive)
{
	local int _maxRepairers;
	local DROID _truck;

	if(structure != NULLOBJECT)
	{
		/* recycle structure if will be dead with the next shot anyway */
		if(lowOnPower() and (structure.health <= structNoLiveHealth))		//Doesn't make sense if we've got alot of power though
		{
			/* See if any track is working on this structure */
			_truck = getTruckByTarget(structure);
			if(_truck != NULLOBJECT)
			{
				/* Order to recycle */
				dbg("demolishing structure", me);
				orderDroidObj(_truck, DORDER_DEMOLISH, structure);
			}
		}
		else
		{
			/* Repair damaged structure */
			_maxRepairers = 1;

			//close to base?
			if(distBetweenTwoPoints(baseX, baseY, structure.x, structure.y) < (baseRange + (8 * 128)))
			{
				bResult = TRUE;

				_maxRepairers = 2;	//use more trucks for base structures
			}

			if(not((not bResult) and (alert)))	//don't repair if low on power and not a base structure
			{
				retInt = repairStructure(structure, _maxRepairers);
			}
		}
	}
}

/* returns TRUE if we don't have much spare ower */
function bool lowOnPower()
{
	if(playerPower(me) < highPower)
		return TRUE;

	return FALSE;
}

//---------------------------------------------------------
//	Returns TRUE if a derrick defense or derrick
//	itself were attacked
//---------------------------------------------------------
function bool isNearOil(int _x, int _y)
{
	temp = (6 * 128);		//near oil range

	initEnumStruct(FALSE,derrick,me,me);
	tempStruct = enumStruct();
	while(tempStruct != NULLOBJECT)
	{
		if(distBetweenTwoPoints(_x, _y, tempStruct.x, tempStruct.y) < temp)		//close to a derrick
		{
			return(TRUE);
		}

		tempStruct = enumStruct();
	}

	return(FALSE);
}

//-----------------------------------------------------------
//Check all damaged structures and repair them
//-----------------------------------------------------------
function void repairStructures()
{
	if(idleGroup(buildGr) == 0)
		exit;

	//How many already repairing
	result = numTrucksSameOrder(DORDER_REPAIR);

	result3 = 5;		//max repairers

	if(result >= result3)
		exit;


	structure2 = NULLOBJECT;
	range = 90;			//repair if below

	//check base structures first
	//----------------------------
	count = 0;
	while(count < numBaseStructs)
	{
		initEnumStruct(FALSE,baseStructs[count],me,me);
		structure = enumStruct();
		while(structure != NULLOBJECT)
		{
			if(structure.health < range)
			{
				result2 = repairStructure(structure, 3);	//use 3 trucks max

				result = result + result2;		//one more busy?

				if(result >= result3){exit;}		//exit if too many busy
			}
			structure = enumStruct();
		}
		count = count + 1;
	}

	//now check all other structures
	//---------------------------------
	initEnumStruct(TRUE,fac,me,me);
	structure = enumStruct();
	while(structure != NULLOBJECT)
	{
		if(structure.health < range)
		{
			result2 = repairStructure(structure, 1);	//use 1 truck max

			result = result + result2;		//one more busy?

			if(result >= result3){exit;}		//exit if too many busy
		}
		structure = enumStruct();
	}
}

function int repairStructure(STRUCTURE _damagedStruct, int _maxRepairers)
{
	//Make sure not too many repairing already
	//----------------------------------------
	temp2 = numTrucksSameOrderLoc(_damagedStruct.x, _damagedStruct.y, DORDER_REPAIR);

	if(temp2 < _maxRepairers)	//not too many already
	{
		//Find closest idle truck
		//---------------------------------------
		tempDroid = closestIdleTruck(_damagedStruct.x, _damagedStruct.y);

		if(tempDroid != NULLOBJECT)
		{
			if(distBetweenTwoPoints(tempDroid.x, tempDroid.y, _damagedStruct.x, _damagedStruct.y) < (25 * 128))	//not too far
			{
				//check if in the base
				//temp2 = isInMyBase(_damagedStruct.x, _damagedStruct.y);

				//don't repair if outside of the base and dangerous
				if(not((not isInMyBase(_damagedStruct.x, _damagedStruct.y)) and (threatInRange(me, _damagedStruct.x, _damagedStruct.y, threatRange, FALSE)) ) )
				{
					orderDroidObj(tempDroid, DORDER_REPAIR, _damagedStruct);
					return(1);
				}
			}
		}
	}

	return(0);
}

//
//	Scout
//
event doScout(inactive)
{
	//dbg(" " & me & ")  doScout()");
	if(idleGroup(scoutGr) == 0){exit;}

	initIterateGroup(scoutGr);				// find all units in build group.
	droid = iterateGroup(scoutGr);
	while(droid != NULLOBJECT)
	{
		//dbg(" " & me & ")  doScout() - droid.orderx: " & droid.orderx & ", droid.ordery: " & droid.ordery);

		if((distBetweenTwoPoints(droid.x, droid.y, droid.orderx, droid.ordery) < 384) or (scoutX <= 0) or (droid.order == DORDER_NONE))	//Some of them reached destination or first time
		{
			//dbg(" " & me & ")  doScout() - setting new scouting destination (**********)");

			//find next closest unrevealed tile (into buildX and buildY)
			//bResult = fogTileInRange(ref buildX, ref buildY, droid.x, droid.y, baseX, baseY, scoutRange, me);
			bResult = fogTileInRange(ref buildX, ref buildY, droid.x, droid.y, baseX, baseY, -1, me, threatRange);

			//bResult = fogTileInRange(ref buildX, ref buildY, 33, 44, 55, 66, 77, 88);


			if(not bResult)
			{
				//dbg(" " & me & ")  doScout() - failed to find scout loc (**********)");

				//scoutRange = scoutRange + scoutStep;	//and try next time

				//see if whole map revealed
				//if( ((scoutRange / 128) > mapWidth) and ((scoutRange / 128) > mapHeight))
				//{
					dbg("doScout() - STOP SCOUTING, MAP REVEALED (!!!!!!!!!!!!!)", me);

					groupAddGroup(defendGr, scoutGr);
					setEventTrigger(doScout, inactive);	//stop scouting
				//}
			}
			else
			{
				//dbg(" " & me & ")  doScout() x: " & (droid.x/128) & ", y: " & (droid.x/128) & "newx: " & (buildX/128) & "newy :" & (buildY/128));

				scoutX = buildX;
				scoutY = buildY;

				orderDroidLoc(droid, DORDER_MOVE, scoutX, scoutY);
			}
		}

		droid = iterateGroup(scoutGr);
	}

	//dbg(" " & me & ")  * doScout()");
}

event scoutForEnemy(inactive)
{
	//dbg(" " & me & ")  scoutForEnemy()");

	bResult = FALSE;	//no idle
	initIterateGroup(enemyScoutGr);				// find all units in build group.
	droid = iterateGroup(enemyScoutGr);
	while(droid != NULLOBJECT)
	{
		//dbg(" " & me & ")  doScout() - droid.orderx: " & droid.orderx & ", droid.ordery: " & droid.ordery);

		if((distBetweenTwoPoints(droid.x, droid.y, droid.orderx, droid.ordery) < 384) or (droid.order == DORDER_NONE))	//Some of them reached destination
		{
			//dbg(" " & me & ")  scout reached");
			bResult = TRUE;
		}
		droid = iterateGroup(enemyScoutGr);
	}

	if(not bResult){exit;}


	if((enemyScoutX > 0) and (enemyScoutY > 0))
	{
		//find a valid spot we can send droid to
		//bResult = fogTileInRange(ref x, ref y, enemyScoutX, enemyScoutY, enemyScoutX, enemyScoutY, -1, me);
		bResult = chooseValidLoc(ref x, ref y, enemyScoutX, enemyScoutY, me, (11 * 128));

		if(not bResult)
		{
			dbg("couldn't send enemy scouts to " & enemyScoutX & ", " & enemyScoutY, me);
			minEnemyScouts = 0;
			maxEnemyScouts = 0;
			numEnemyScouts = 0;
			groupAddGroup(defendGr, enemyScoutGr);
			setEventTrigger(scoutForEnemy, inactive);	//deactivate
		}
		else
		{
			orderGroupLoc(enemyScoutGr, DORDER_MOVE, x, y);
			//dbg(" " & me & ")  sending enemy scout to: " & x & ", " & y);
		}

	}
	else
	{
		dbg("scoutForEnemy() - no valid coords", me);
		//exit;
	}

	//find coords for the next time
	//--------------------------------------
	count = 0;		//times tried

	if((enemyScoutX > 0) and (enemyScoutY > 0))
	{
		x = enemyScoutX; y = enemyScoutY;
	}
	else
	{
		x = baseX; y = baseY;
	}

	bResult = TRUE;		//revealed
	while(bResult and (count < 200))		//until finds a not revealed loc
	{
		getNextScoutCoord(x, y);	//Sets enemyScoutX and Y vars
		x = enemyScoutX; y = enemyScoutY;

		bResult = mapRevealedInRange(x, y, enemyScoutRange, me);	//check if has already visited this area

		count = count + 1;
	}

	if(bResult)		//no new coords found
	{
		dbg("couldn't find next spot after: " & enemyScoutX & ", " & enemyScoutY, me);
		minEnemyScouts = 0;
		maxEnemyScouts = 0;
		numEnemyScouts = 0;
		groupAddGroup(defendGr, enemyScoutGr);
		setEventTrigger(scoutForEnemy, inactive);		//deactivate
	}
	//else
	//{
	//	dbg(" " & me & ")  found new enemy scout coords");
	//}
}

function void getNextScoutCoord(int _lastX, int _lastY)
{
	temp = (9 * 128);		//border offset

	tempX = _lastX;
	tempY = _lastY;

	if(bEnemyScoutHor)		//horizontal - main direction
	{
		if(bEnemyScoutToRight)
		{
			tempX = tempX + enemyScoutStep;

			//check if unit too close to hor edge already
			if(tempX > ((mapWidth * 128) - temp))		//too close to edge
			{
				//dbg(" " & me & ")  ----reached right edge");

				tempX = ((mapWidth * 128) - temp);
				bEnemyScoutToRight = FALSE;

				//have to skip a vert line now

				if(not bEnemyScoutToBottom)	//going to top
				{
					tempY = tempY - enemyScoutStep;

					//check vertical edge now
					if(tempY < temp)	//reached top
					{
						//dbg(" " & me & ")  ----reached top edge");
						tempY = temp;
						bEnemyScoutToBottom = TRUE;
					}
				}
				else		//going to bottom
				{
					tempY = tempY + enemyScoutStep;
					//check vertical edge now
					if(tempY > ((mapHeight * 128) - temp))	//reached bottom
					{
						//dbg(" " & me & ")  ----reached bottom edge");
						tempY = ((mapHeight * 128) - temp);
						bEnemyScoutToBottom = FALSE;
					}
				}
			}


		}
		else		//to left
		{
			tempX = tempX - enemyScoutStep;

			//check if unit too close to hor edge already
			if(tempX < temp)		//too close to edge
			{
				//dbg(" " & me & ")  ----reached left edge");
				tempX = temp;
				bEnemyScoutToRight = TRUE;	//change dir next time

				//have to skip a vert line now

				if(not bEnemyScoutToBottom)	//going to top
				{
					tempY = tempY - enemyScoutStep;

					//check vertical edge now
					if(tempY < temp)	//reached top
					{
						//dbg(" " & me & ")  ----reached top edge");
						tempY = temp;
						bEnemyScoutToBottom = TRUE;
					}
				}
				else				//going to bottom
				{
					tempY = tempY + enemyScoutStep;
					//check vertical edge now
					if(tempY > ((mapHeight * 128) - temp))	//reached bottom
					{
						//dbg(" " & me & ")  ----reached bottom edge");
						tempY = (mapHeight * 128) - temp;
						bEnemyScoutToBottom = FALSE;
					}
				}
			}
		}
	}
	else	//main dir = vert
	{
		if(bEnemyScoutToBottom)
		{
			tempY = tempY + enemyScoutStep;

			//check if unit too close to ver edge already
			if(tempY > ((mapHeight * 128) - temp))		//too close to edge
			{
				//dbg(" " & me & ")  ----reached bottom edge");
				tempY = (mapHeight * 128) - temp;
				bEnemyScoutToBottom = FALSE;		//change dir

				//have to skip a hor line now

				if(not bEnemyScoutToRight)	//going left
				{
					tempX = tempX - enemyScoutStep;

					//check hor edge now
					if(tempX < temp)	//reached left
					{
						//dbg(" " & me & ")  ----reached left edge");
						tempX = temp;
						bEnemyScoutToRight = TRUE;
					}
				}
				else	//to right
				{
					tempX = tempX + enemyScoutStep;
					//check hor edge now
					if(tempX > ((mapWidth * 128) - temp))	//reached right
					{
						//dbg(" " & me & ")  ----reached right edge");
						tempX = (mapWidth * 128) - temp;
						bEnemyScoutToRight = FALSE;
					}
				}
			}


		}
		else		//to top
		{
			tempY = tempY - enemyScoutStep;

			//check if unit too close to ver edge already
			if(tempY < temp)		//too close to edge
			{
				tempY = temp;
				bEnemyScoutToBottom = TRUE;		//change dir

				//have to skip a hor line now

				if(not bEnemyScoutToRight)	//going left
				{
					tempX = tempX - enemyScoutStep;

					//check hor edge now
					if(tempX < temp)	//reached left
					{
						//dbg(" " & me & ")  ----reached left edge");
						tempX = temp;
						bEnemyScoutToRight = TRUE;
					}
				}
				else	//to right
				{
					tempX = tempX + enemyScoutStep;
					//check hor edge now
					if(tempX > ((mapWidth * 128) - temp))	//reached right
					{
						//dbg(" " & me & ")  ----reached right edge");
						tempX = (mapWidth * 128) - temp;
						bEnemyScoutToRight = FALSE;
					}
				}
			}
		}
	}

	enemyScoutX = tempX;
	enemyScoutY = tempY;
}

//---------------------------------------------------------------
//	Returns closest corner based on arguments
//---------------------------------------------------------------
function void getClosestCorner(int _x, int _y)
{
	temp = (12 * 128);	//border offset

	//horizontal
	retInt = temp;					//left
	if(_x > ((mapWidth * 128) / 2))
	{
		retInt = (mapWidth * 128) - temp;	//right
	}


	//vertical
	retInt2 = temp;					//top
	if(_y > ((mapHeight * 128) / 2))
	{
		retInt2 = (mapHeight * 128) - temp;	//bottom
	}
}

function void updateMilitaryStatus()
{
	noBaseTargets = TRUE;	//reset here, set by checkBase()

	count = 0;
	while(count < multiPlayerMaxPlayers)
	{
		if(count != me)
		{
			ally[count] = FALSE;

			if(allianceExistsBetween(count ,me) )
			{
				ally[count] = TRUE;
			}

			/* check if can see any enemy object */
			//only check if not dead already, OBJ_SEEN will make him alive if it sees anything
			if(not dead[count])
			{
				/* check if dead */
				//count2 = checkPlayerDead(count);
				if(checkPlayerDead(count))
				{
					dead[count] = TRUE;

					dbg(getPlayerName(count) & " IS DEAD !!!!!!!!!!!!!!!!++++", me);

					notifyPlayerDead(count);
				}
			}

			/* find base */
			if(not dead[count])
			{
				checkBase(count);
			}
		}
		count = count + 1;
	}
}

function void militarySelftest()
{
	if(researchFinished(resBB, me))	//BB
	{
		haveBB = TRUE;
	}
}

function void findAlternateTarget()
{
	//Only choose alternate target if already ready to attack, otherwise
	//if a real target will be found afterwards, it won't be assigned as main target
	//------------------------------------------------------------------------------

	//find any other structure left
	structure = getClosestEnemyStructByType(baseX, baseY, -1, REF_DEFENSE, me);
	if(structure == NULLOBJECT)
	{
		structure = getClosestEnemyStructByType(baseX, baseY, -1, REF_RESOURCE_EXTRACTOR, me);
	}

	//if found
	if(structure != NULLOBJECT)
	{
		//centreView(structure);

		result = structure.player;
		dbg("no valid base targets, found an alternative target for " & getPlayerName(result), me);

		seeBase[result] = TRUE;
		knowBase[result] = TRUE;

		//dead[result] = FALSE;
		//killedBase[result] = FALSE;

		curBase[result][0] = structure.x;
		curBase[result][1] = structure.y;

		if(curHelpX[result] <= 0)
		{
			curHelpX[result] = curBase[result][0];
			curHelpY[result] = curBase[result][1];
		}

		//if((base[result][0] <= 0) or (base[result][1] <= 0))
		//{
		//	base[result][0] = structure.x;
		//	base[result][1] = structure.y;
		//}

		noBaseTargets = FALSE;
	}
}

function bool canStartAttack()
{
	if((defendGr.members - numDefenders) < numAttackers)
	{
		return(FALSE);
	}

	return(TRUE);
}

//count current attackers as well
function bool canTheoreticallyStartAttack()
{
	if((attackGr.members + sendAttackGr.members + defendGr.members - numDefenders) >= numAttackers)
	{
		return(TRUE);
	}

	return(FALSE);
}

// have *any* attackers? (count current attackers as well)
function bool haveTheoretilcallyMinAttackers(bool _bSafeToSendLittleAttackers)
{
	if(_bSafeToSendLittleAttackers)		//it's ok to send little attackers, for example if joining forces with other players
	{
		if((attackGr.members + sendAttackGr.members + defendGr.members - minDefenders) >= minAttackers)
		{
			return TRUE;
		}
	}
	else	//too dangerous to send little attackers, wait until we get more units
	{
		if((attackGr.members + sendAttackGr.members + defendGr.members - numDefenders) >= minAttackers)
		{
			return TRUE;
		}
	}


	return FALSE;
}

function int totalDroids()
{
	local int _dummy;	//FIXME
	_dummy = 0;
	return attackGr.members + sendAttackGr.members + defendGr.members;
}

//---------------------------------------------------------------
//	Check base coords are valid for a certain player
//---------------------------------------------------------------
function void checkBase(int _player)
{
	ASSERT(_player >= 0, "checkBase - _player < 0", me);

	if(knowBase[_player])
	{
		if((curBase[_player][0] <= 0) or (curBase[_player][1] <= 0))
			MsgBox("checkBase() - curBase <= 0");

		if(mapRevealedInRange(curBase[_player][0],curBase[_player][1], (2 * 128), me))		//can tell if it's empty only if visited this place (in case recalled it from memory)
		{
			if(not structInRangeVis(me, _player, curBase[_player][0], curBase[_player][1], (2 * 128)) )
			{
				//if((curBase[_player][0] == base[_player][0]) and (curBase[_player][1] == base[_player][1]))
				//{
				//	dbg(" " & me & ")  recalled location is empty for " & _player & " !!!!!!!!!!!!!!!!!!!!!!!");
				//}

				//find new base
				//temp = findBase(_player);

				if(findBase(_player))	//found new location of the base for this player
				{
					dbg("Corrected base coords for player" & _player, me);

					curBase[_player][0] = retInt;
					curBase[_player][1] = retInt2;

					if(curHelpX[_player] <= 0)
					{
						curHelpX[_player] = curBase[_player][0];
						curHelpY[_player] = curBase[_player][1];
					}

					/* update destination coords if going to this player */
					if(enemy == _player)
					{
						dbg("Enemy cords updated", me);
						sendForceX = curBase[_player][0];
						sendForceY = curBase[_player][1];
					}

					seeBase[_player] = TRUE;	//found base

					if(not ally[_player])
						noBaseTargets = FALSE;

					dbg("found a different enemy base location for " & _player, me);

					//if no real base found yet, only an alternate loc, then remember real base now
					if((base[_player][0] <= 0) or (base[_player][1] <= 0))
					{
						base[_player][0] = retInt;
						base[_player][1] = retInt2;
					}

					//learn this location
					if(bLearn)
					{
						if(not canRememberPlayerBaseLoc(me, _player))		//not already in memory
						{
							learnPlayerBaseLoc(me, _player, retInt, retInt2);
						}
					}
				}
				else	//couldn't find anything
				{
					if(_player == enemy)	//attacking this one right now
					{
						if(seeBase[_player])		//warn only once, when just lost the base
						{
							dbg("lost current enemy " & getPlayerName(_player) & " !!!!!!!!!!!!!!!!!!!!!", me);
						}

					}
					else if(seeBase[_player])	//lost it now
					{
						dbg("lost base loc for enemy " & getPlayerName(_player), me);
					}

					seeBase[_player] = FALSE;	//lost
					//knowBase[_player] = FALSE;	//disabled 15.05.05 because of phSearchingForBase was skipped because of this
				}

			}
			else		//enemy base still there
			{
				if(not allianceExistsBetween(me , _player))	//this player is not our ally
					noBaseTargets = FALSE;

				/* make sure allies see newly found enemy base */
				if(not seeBase[_player])	//just found
					refreshAllyRadar();

				seeBase[_player] = TRUE;	//can see base
			}
		}
		else	//enemy base still there (probably recalled it)
		{
			if(not ally[_player])
				noBaseTargets = FALSE;
		}
	}
	else	//don't have enemy base loc
	{
		//find new base
		//temp = findBase(_player);

		if(findBase(_player))	//found new location of the base for this player
		{
			curBase[_player][0] = retInt;
			curBase[_player][1] = retInt2;

			if(curHelpX[_player] <=0)
			{
				curHelpX[_player] = curBase[_player][0];
				curHelpY[_player] = curBase[_player][1];
			}

			knowBase[_player] = TRUE;
			seeBase[_player] = TRUE;	//found base

			if(not ally[_player])
			{
				noBaseTargets = FALSE;
			}

			dbg("found new enemy base for " & getPlayerName(_player) & " at " & (curBase[_player][0] / 128) & " - " & (curBase[_player][1] / 128) & " !!!!!!!!!", me);

			//if no real base found yet, only an alternate loc, then remember real base now
			if((base[_player][0] <= 0) or (base[_player][1] <= 0))
			{
				base[_player][0] = retInt;
				base[_player][1] = retInt2;
			}

			//learn this location
			if(bLearn)
			{
				if(not canRememberPlayerBaseLoc(me, _player))		//not already in memory
				{
					learnPlayerBaseLoc(me, _player, retInt, retInt2);
				}
			}

			refreshAllyRadar();
		}
		//else
		//{
		//	dead[_player] = TRUE;
		//}
	}
}

function bool checkPlayerDead(int _player)
{
	if(knowBase[_player] and (not seeBase[_player]))		//know location, but don't see it
	{
		if(mapRevealedInRange(curBase[_player][0],curBase[_player][1], (2 * 128), me))	//make sure can see the location where the base should be
		{
			//_temp = canSeePlayer(_player);		//can see any other objects?

			if(not canSeePlayer(_player))
			{
				return(TRUE);		//dead
			}
		}
	}

	return(FALSE);
}

function bool canSeePlayer(int _player)
{
	_bResult = FALSE;	//not found

	initEnumStruct(TRUE,wall,_player,me);
	_structure = enumStruct();
	while((_structure != NULLOBJECT) and (not _bResult))
	{
		_temp = getStructureType(_structure);
		if((_temp != 7) and (_temp != 8) and (_temp != 6) and (_temp != 6))	//wall, cornerwall, defense, rearm
		{
			_bResult = TRUE;
		}
		_structure = enumStruct();
	}

	if(not _bResult)	//no structures
	{
		InitEnumDroids(_player,me);
		_droid = EnumDroid();
		if(_droid == NULLOBJECT)
		{
			return(FALSE);
		}
	}

	return(TRUE);
}

function bool findBase(int _targetPlayer)
{
	local int _structType;

	ASSERT(_targetPlayer >= 0, "findBase - _targetPlayer < 0", me);

	_structType = 0;
	while(_structType < numBaseStructs)
	{
		tempStruct = getStructureVis(baseStructs[_structType], _targetPlayer, me);
		if(tempStruct !=NULLOBJECT)
		{
			retInt = tempStruct.x;
			retInt2 = tempStruct.y;
			return(TRUE);
		}
		_structType = _structType + 1;
	}

	return(FALSE);
}

function int chooseEnemyToDrop()
{
	//choose the most annoying one

	temp5 = none;
	temp4 = (-1);	//num times attacked by an enemy

	temp = 0;
	while(temp < multiPlayerMaxPlayers)
	{
		if((not allianceExistsBetween(temp, me)) and (temp != me))
		{
			if((not dead[temp]) and knowBase[temp] and seeBase[temp])	//found player's base and know this player is active since can se him
			{
				temp2 = numAlliesDroppingPlayer(temp);

				temp3 = numActiveEnemyDrop(temp);

				if((temp3 == 0) and (temp2 < maxAllyDroppers))	//not too many and not already dropping
				{
					if(attacked[temp] > temp4)
					{
						temp4 = attacked[temp];
						temp5 = temp;
					}
				}
			}
		}
		temp = temp + 1;
	}

	return(temp5);
}

function int chooseEnemy()
{
	//return - suited enemy to attack

	result = 99999;
	result2 = none;

	if((offeredEnemy != none))		//anyone already attacking someone?
	{
		//if((not ally[offeredEnemy]) and (not dead[offeredEnemy]) and (knowBase[offeredEnemy]) and (offeredEnemy != me) and (not killedBase[offeredEnemy]))
		if((not ally[offeredEnemy]) and (not dead[offeredEnemy]) and (knowBase[offeredEnemy]) and (offeredEnemy != me))
		{
			dbg("choosing offered enemy", me);
			result2 = offeredEnemy;
			offeredEnemy = none;		//don't choose it again after destroying it
		}
	}

	if(result2 == none)		//didn't set offeredEnemy as the enemy
	{
		/* now look for bases that were not yet destroyed and which we can see */
		count = 0;
		while(count < multiPlayerMaxPlayers)
		{
			if((not ally[count]) and (count != me))
			{
				if(knowBase[count] and (not dead[count]) and (not killedBase[count]) and seeBase[count])	//found player's base
				{
					result3 = distBetweenTwoPoints(baseX, baseY, curBase[count][0], curBase[count][1]);
					if(result3 < result)
					{
						result = result3;
						result2 = count;	//enemy so far
					}
				}
			}
			count = count + 1;
		}

		/* now also include those bases we can't see */
		if(result2 == none)
		{
			count = 0;
			while(count < multiPlayerMaxPlayers)
			{
				if((not ally[count]) and (count != me))
				{
					if(knowBase[count] and (not dead[count]) and (not killedBase[count]))	//found player's base
					{
						result3 = distBetweenTwoPoints(baseX, baseY, curBase[count][0], curBase[count][1]);
						if(result3 < result)
						{
							result = result3;
							result2 = count;	//enemy so far
						}
					}
				}
				count = count + 1;
			}
		}

		/* now also include those bases that were already destroyed */
		if(result2 == none)
		{
			count = 0;
			while(count < multiPlayerMaxPlayers)
			{
				if((not ally[count]) and (count != me))
				{
					//if(knowBase[count] and (not dead[count]))	//found player's base
					if(knowBase[count])	//found player's base
					{
						result3 = distBetweenTwoPoints(baseX, baseY, curBase[count][0], curBase[count][1]);
						if(result3 < result)
						{
							result = result3;
							result2 = count;	//enemy so far
						}
					}
				}
				count = count + 1;
			}
		}
	}

	/* set enemy */
	//if(result2 != none)
	//{
	//	enemy = result2;
	//}

	return(result2);
}

function void checkBaseThreat()
{
	local 	int 	_attacker,_attackerUnitForce,_attackerStructureForce,_counterEnemy,_bestEnemyForce;
	local	int		_enemyUnits,_enemyStructures,_allyUnits,_allyStructures;
	local	int		_totalEnemies,_totalAllies,_range;
	local	int		_enemyX,_enemyY,_counterEnemyForce;

	_range = (35 * 128);

	//if(not bigMap)
	//	_range = (29 * 128);

	_range = max(_range, (baseRange + defendCorridor));	//just in case baseRange is bigger

	//showRangeAtPos(baseX, baseY, _range);

	/* Check if base is in danger */
	// _totalEnemies enemy units and structures
	_enemyUnits = 0;
	_enemyStructures = 0;

	// don't reset counterenemy if we are defending
	if(state != stDefending) {
		_counterEnemy = -1;
	}

	_bestEnemyForce = 0;
	_attacker = 0;
	while(_attacker < MAX_PLAYERS)
	{
		if((not allianceExistsBetween(_attacker, me)) and (_attacker != me))
		{
			_attackerUnitForce = numPlayerWeapDroidsInRange(_attacker, me, baseX, baseY, _range, FALSE);
			_enemyUnits = _enemyUnits + _attackerUnitForce;

			_attackerStructureForce = numPlayerWeapStructsInRange(_attacker, me, baseX, baseY, _range);
			_enemyStructures = _enemyStructures + _attackerStructureForce;


			//console(_attacker & " " & _attackerUnitForce & "/" & _attackerStructureForce);

			// see if this enemy dominates in the area
			if((_counterEnemy < 0) or ((_attackerUnitForce + _attackerStructureForce / 3) > _bestEnemyForce))
			{
				_bestEnemyForce = _attackerUnitForce + _attackerStructureForce / 3;

				// don't reset counterenemy if we are defending
				if(state != stDefending) {
					_counterEnemy = _attacker;
				}
			}
		}
		_attacker++;
	}
	_enemyStructures = _enemyStructures / 3;

	//_enemyUnits = numEnemyWeapDroidsInRange(me, baseX, baseY, _range, FALSE);
	//_enemyStructures = numEnemyWeapStructsInRange(me, baseX, baseY, _range) / 3;

	_allyUnits = numFriendlyWeapDroidsInRange(me, baseX, baseY, _range, FALSE);
	_allyStructures = numFriendlyWeapStructsInRange(me, baseX, baseY, _range) / 3;

	_totalEnemies = _enemyUnits + _enemyStructures;	//total enemies
	_totalAllies = _allyUnits + _allyStructures;	//total allies

	if(_enemyUnits > 0)
		dbg("Num enemies = " & _enemyUnits & "/" & _enemyStructures & " (" & _allyUnits & "/" & _allyStructures & ") - " & (_range / TILE), me);

	/* pre-warn allies (only units _totalEnemies) */
	if(_enemyUnits >= 7)
	{
		if(state != stDefending) 	//do only once/attack
		{
			if(timeNotifyEnemyInBase <= 0)
			{
				notifyEnemyAtBase();

				attackedCount = attackedCount + 1;	//remember how many times we were attacked
			}
		}
	}

	/* Check if base in danger */
	if((_enemyUnits > _totalAllies) or ((_enemyUnits >= maxBaseEnemies) and ((_totalEnemies - _totalAllies) < 4)) or (_totalEnemies > _totalAllies)		//they have more units than all our defenses
	 or ((_allyUnits < minDefenders) and alert and (_enemyUnits >= 2) and (_allyStructures < 20)) )		//if we are low on defenders and power next attack might wipe us out (dangerous especially on big maps)
	{
		if(gameTime > 2800)
		{
			dbg("BASE: too many enemies in the base             !!!!!!", me);

			if(state != stDefending)
			{
				if(state != stNone)
				{
					cancelState();
				}

				//TODO: with _attacker = playerDominanceInArea() find out if attacker's base is closer than our own base
				//and attack enemy base instead

				startDefending(_counterEnemy);
				requestHelp();
			}
		}

	}
	/* check if can stop defending */
	else if((state == stDefending) and (_enemyUnits == 0))		//all enemies are gone
	{
		if(defendGr.members >= minDefenders)		//make sure can defend on our own
		{
			dbg("base is safe again", me);

			_counterEnemy = counterEnemy;
			stopDefending();

			notifyAllies("i'm ok", FALSE);		//tell allies we are ok now

			/* See if we can counterattack */
			if((state == stNone) and (_counterEnemy != none))
			{
				if(not allianceExistsBetween(_counterEnemy, me))
				{
					if(numAttackUnits() >= MIN_COUNTERATTACKERS)
					{
						if(knowBase[_counterEnemy])
						{
							_enemyX = curBase[_counterEnemy][0];
							_enemyY = curBase[_counterEnemy][1];
							_range = (20 * TILE);

							// see if we have a chance to win

							_counterEnemyForce = numPlayerWeapDroidsInRange(_counterEnemy, me, _enemyX, _enemyY, -1, FALSE) +
										  numPlayerWeapStructsInRange(_counterEnemy, me, _enemyX, _enemyY, _range) / 3;

							if(numAttackUnits() > _counterEnemyForce)
							{
								dbg("counterattacking", me);
								startAttack(_counterEnemy, _enemyX, _enemyY);
								requestStartAttack(_counterEnemy, _enemyX, _enemyY);
							}
							else{
								dbg("counterattack: too dangerous: " & numAttackUnits() & "/" & _counterEnemyForce, me);
							}
						}
						else{
							dbg("counterattack: don't have base of " & _counterEnemy, me);
						}
					}
					else{
						dbg("counterattack: not enough attackers " & numAttackUnits(), me);
					}
				}
				else{
					dbg("counterattack: counterEnemy is ally: " & _counterEnemy, me);
				}
			}
			else{
				dbg("counterattack: busy: " & state & " : " & _counterEnemy, me);
			}

		}
	}
}

function void requestHelp()
{
	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(allianceExistsBetween(me , _temp))
		{
			giftRadar(me, _temp, FALSE);
			msg("help" ,me , _temp);
			dropBeacon("help", _temp, me, baseX, baseY, 0);
		}
		_temp = _temp + 1;
	}

	requestHelpTime = maxRequestHelpTime;
}

/* Request status from allies */
function void checkRequestStatus()
{
	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(allianceExistsBetween(me , _temp) and (tRequestStatus[_temp] <= 0))
		{
			requestStatus(_temp);
		}
		_temp = _temp + 1;
	}
}

function void requestStatus(int _player)
{
	msg("status?" ,me ,  _player);

	tRequestStatus[ _player] = tMaxRequestStatus + random(700);
}

function void requestEnemy(int _toAskPlayer)
{
	msg("who's your target?" ,me , _toAskPlayer);

	tWaitPlayerReply[_toAskPlayer] = tMaxWaitPlayerReply;	//start timer
}


function void notifyPlayerDead(int deadPlayer)
{
	exit;

	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(allianceExistsBetween(me , _temp))
		{
			if(deadPlayer == me)
			{
				msg("ok, i'm dead, cya" ,me , _temp);
			}
			else
			{
				msg(getPlayerName(deadPlayer) & " is dead" ,me , _temp);
			}
		}
		_temp = _temp + 1;
	}
}

function void notifyPlayerAlive(int _alivePlayer)
{
	exit;

	if(gameTime < 200)
		exit;	//engine bugs at startup

	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(allianceExistsBetween(me , _temp))
		{
			msg(getPlayerName(_alivePlayer) & " is alive" ,me , _temp);
		}
		_temp = _temp + 1;
	}
}

function void notifyPlayerBaseDestroyed(int _destroyedPlayer)
{
	notifyAllies("destroyed " & getPlayerName(_destroyedPlayer) & "'s base", FALSE);
}

function void notifyLost()
{
	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(allianceExistsBetween(me , _temp))
		{
			msg("cya" ,me , _temp);
		}
		_temp = _temp + 1;
	}
}

function void notifyReadyAttack()
{
	notifyAllies("go?", FALSE);

	notifyReadyAttackTime = maxNotifyReadyAttackTime;

	bNotifiedReadyAttack = FALSE;	//remember not notified yet

	dbg("ATTACK: allies notified", me);
}

function void notifyReadyToDrop()
{
	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(allianceExistsBetween(me , _temp))
		{
			//if(allyEnemy[_temp] == enemy)		//only if he's attacking the same enemy
			//{
				msg("ready to drop" ,me , _temp);
			//}
		}
		_temp = _temp + 1;
	}

	dbg("ATTACK: allies notified of drop", me);
}

function void refreshAllyRadar()
{
	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(allianceExistsBetween(me , _temp))
		{
			giftRadar(me, _temp, FALSE);
		}
		_temp = _temp + 1;
	}
}

// one function for all notifications
function void notifyAllies(STRING _cstr, bool _bUpdateRadar)
{
	local int i;

	i = 0;
	while(i < multiPlayerMaxPlayers)
	{
		if(allianceExistsBetween(me, i))
		{
			if(_bUpdateRadar)
			{
				giftRadar(me, i, FALSE);
			}
			msg(_cstr, me, i);
		}
		i = i + 1;
	}
}

function void notifyTakeOil(int _enemy, int _x, int _y)
{
	dropAllyBeacon("gonna get " & getPlayerName(_enemy) & "'s derrick", _x, _y);
	notifyAllies("gonna get " & getPlayerName(_enemy) & "'s derrick", TRUE);
}

function void dropAllyBeacon(STRING _cstr, int _x, int _y)
{
	local int i;

	dropBeacon(_cstr, me, me, _x, _y, 0);

	i = 0;
	while(i < multiPlayerMaxPlayers)
	{
		if((allianceExistsBetween(me, i)) and (i != me))
		{
			dropBeacon(_cstr, i, me, _x, _y, 0);
		}
		i = i + 1;
	}
}

function void requestPrepareDrop()
{
	if(enemy == none){MsgBox("requestPrepareDrop() - enemy == none"); exit;}

	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(allianceExistsBetween(me , _temp))
		{
			giftRadar(me, _temp, FALSE);
			msg("drop " & enemy, me , _temp);
		}
		_temp = _temp + 1;
	}
}

function void notifyPrepareDrop()
{
	if(enemy == none){MsgBox("notifyPrepareDrop() - enemy == none"); exit;}

	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(allianceExistsBetween(me , _temp))
		{
			giftRadar(me, _temp, FALSE);
			msg("dropping " & enemy, me , _temp);
			msg("preparing drop", me , _temp);
		}
		_temp = _temp + 1;
	}
}

function void notifyStartDrop()
{
	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(allianceExistsBetween(me , _temp))
		{
			msg("transporting units", me , _temp);
		}
		_temp = _temp + 1;
	}
}

function void notifyCantDrop()
{
	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(allianceExistsBetween(me , _temp))
		{
			if(allyEnemy[_temp] == enemy)
			{
				msg("can't drop", me , _temp);
			}
		}
		_temp = _temp + 1;
	}
}

function void notifyLoadedTransporters()
{
	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(allianceExistsBetween(me , _temp))
		{
			if(allyEnemy[_temp] == enemy)
			{
				msg("loaded transporters", me , _temp);
			}
		}
		_temp = _temp + 1;
	}
}

function void requestStartAttack(int _enemy, int _x, int _y)
{
	if(_enemy == none){MsgBox("requestStartAttack() - _enemy == none"); exit;}

	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(allianceExistsBetween(me , _temp))
		{
			giftRadar(me, _temp, FALSE);
			msg("go " & getPlayerName(_enemy), me , _temp);
			dropBeacon("go " & getPlayerName(_enemy), _temp, me, _x, _y, 0);
		}
		_temp = _temp + 1;
	}
}

function void notifyPlayerHasVTOLs(int _playerWithVTOLs)
{
	notifyAllies(_playerWithVTOLs & " got vtols", FALSE);
}

function void notifyStatusAll()
{
	local int i;

	i = 0;
	while(i < multiPlayerMaxPlayers)
	{
		if(allianceExistsBetween(me , i))
		{
			notifyStatus(i);
		}
		i = i + 1;
	}
}

function void notifyStatus(int _playerToNotify)
{
	if(state == stDefending)
	{
		msg("help" ,me , _playerToNotify);
	}
	else if(state == stAttacking)
	{
		msg("going " & enemy ,me , _playerToNotify);
	}
	else if(state == stHelpingAlly)
	{
		msg("helping " & enemy ,me , _playerToNotify);
	}
	else if(state == stTakingOil)
	{
		msg("hunting " & getPlayerName(enemy) & "'s oil" ,me , _playerToNotify);
	}
	else if(((state == stDrop) or (state == stTransporting)) and (enemy != none))
	{
		msg("dropping " & getPlayerName(enemy), me , _playerToNotify);

		if(phase <= phGettingUnits)
		{
			msg("preparing drop", me , _playerToNotify);
		}
		else if(phase == phWaitAllies)
		{
			msg("ready to drop", me , _playerToNotify);
		}
		else if(phase == phLoadingTransport)
		{
			msg("loading transport", me , _playerToNotify);
		}
		else if(phase == phSendDrop)
		{
			msg("transporting units", me , _playerToNotify);
		}
	}
}

function void notifyPower(int _targetPlayer)
{
	if(playerPower(me) <= noPower)
	{
		msg("nope", me , _targetPlayer);
	}
	else if(playerPower(me) <= lowPower)
	{
		msg("not much", me , _targetPlayer);
	}
	else	//high power
	{
		msg("yeah", me , _targetPlayer);
	}
}

function void notifyEnemyAtBase()
{
	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(ally[_temp])
		{
			if(attackedCount == 0)		//first time
			{
				_temp2 = random(3);	//100%
				if(_temp2 == 0)
				{
					msg("oh no, here we go..." ,me , _temp);
				}
				else if(_temp2 == 1)
				{
					msg("it started" ,me , _temp);
				}
				else if(_temp2 == 2)
				{
					msg("they are at my base" ,me , _temp);
				}
			}
			else if((attackedCount > 0) and (attackedCount < 4))
			{
				_temp2 = random(5);
				if(_temp2 == 0)
				{
					msg("not again..." ,me , _temp);
				}
				else if(_temp2 == 1)
				{
					msg("they're after my base" ,me , _temp);
				}
				else if(_temp2 == 2)
				{
					msg("incoming" ,me , _temp);
				}
			}
			else if((attackedCount >= 4) and (attackedCount < 10))
			{
				_temp2 = random(6);
				if(_temp2 == 0)
				{
					msg("this is getting annoying..." ,me , _temp);
				}
				else if(_temp2 == 1)
				{
					msg("this sucks!" ,me , _temp);
				}
				else if(_temp2 == 2)
				{
					msg("duh..." ,me , _temp);
				}
				else if(_temp2 == 3)
				{
					msg("thery're after my base again" ,me , _temp);
				}
			}
			else
			{
				_temp2 = random(8);
				if(_temp2 == 0)
				{
					msg("why is it always my base???" ,me , _temp);
				}
				else if(_temp2 == 1)
				{
					msg("this sucks..." ,me , _temp);
				}
				else if(_temp2 == 2)
				{
					msg("duh..." ,me , _temp);
				}
				else if(_temp2 == 3)
				{
					msg("sooner or later they're gonna get me" ,me , _temp);
				}
				else if(_temp2 == 4)
				{
					msg("today is not my day..." ,me , _temp);
				}
				else if((_temp2 == 5) or (_temp2 == 6))
				{
					msg("they already attacked me " & attackedCount & " times!!! ... yes, I count!" ,me , _temp);
				}

			}
		}
		_temp = _temp + 1;
	}

	timeNotifyEnemyInBase = maxTimeNotifyEnemyInBase;
}

event defendBase(inactive)
{
	/* if attacking en enemy, check if it's still safe to do so otherwise retreat */
	if(baseDefendObj != NULLOBJECT)
	{
		if(numEnemyWeapObjInRange(me, baseDefendObj.x, baseDefendObj.y, (6 * 128), FALSE) >= (defendGr.members - 1))
		{
			//dbg("NOT SAFE TO FOLLOW ATTACKER ANYMORE", me);

			//calc perim coords
			x = baseDefendObj.x;
			y = baseDefendObj.y;

			circlePerimPoint(baseX, baseY, ref x, ref y, (baseRange + defendCorridor / 2));	//move defense locations to the base perimeter

			/* return those who were attacking him back to the base */
			initIterateGroup(defendGr);
			droid = iterateGroup(defendGr);
			while(droid != NULLOBJECT)
			{
				if((droid.target != NULLOBJECT) and (droid.target == baseDefendObj))
				{
					//dbg("droid.target == baseDefendObj", me);

					//droid.target = NULLOBJECT;

					orderDroidLoc(droid, DORDER_MOVE, x, y);		//don't SCOUT
				}
				droid = iterateGroup(defendGr);
			}
		}
	}

	/* Attack any base intruders */
	defendArea(defendGr, baseRange, baseX, baseY, defendCorridor, minDefenders);
}

function void defendArea(GROUP	_defendGr, int _range, int _defendX, int _defendY, int _defendCorridor, int _minDefenders)
{
	local BASEOBJ _obj;
	local DROID	_droid;
	local bool	_bResult,_bResult2;
	local int	_x,_y,_result,_result2,_reactToEnemyCorridor, _dist,_order;
	local int	_moveCloserThreshold;

	if(_defendGr.members == 0)
		exit;

	_bResult = FALSE;
	_obj = NULLOBJECT;
	_reactToEnemyCorridor = 10 * 128;		//when enemy in this range, we move closer to the edge of the defence radius
	_order = DORDER_SCOUT;
	_moveCloserThreshold = 5 * 128;		//if new enemy is closer by this than the old one, then make sure we assign it as a new target

	/* Check if have to defend anything */

	//look at all visible objects close to base
	_obj = getClosestEnemy(_defendX, _defendY,  _range + _defendCorridor + _reactToEnemyCorridor, FALSE, FALSE, me);
	if(_obj != NULLOBJECT)
	{
		//result = isInMyBase(obj.x, obj.y);		//check in base

		//if(distBetweenTwoPoints(_obj.x, _obj.y, _defendX, _defendY) <= _range)		//within defend location
		//{
			_bResult = TRUE;
			_x = _obj.x;
			_y = _obj.y;
		//}
	}

/*
	if(not _bResult)		//no enemy found yet
	{
		_obj = getClosestEnemy(_defendX, _defendY, _range, FALSE, FALSE, me);

		if(_obj != NULLOBJECT)
		{
			//dbg(" " & me & ")  Enemy close to the base, attacking !!!");
			//orderGroupLoc(defendGr, DORDER_SCOUT, obj.x, obj.y);
			_bResult = TRUE;
			_x = _obj.x;
			_y = _obj.y;

			//baseThreatX = x;
			//baseThreatY = y;
		}
	}
*/

	//attack
	if(_bResult)	//found target
	{
		/* if outside of the base and too dangerous to attack directly, move to the perimeter */
		_bResult2 = FALSE;	//outside?
		if(distBetweenTwoPoints(_defendX, _defendY, _x, _y) > (_range + _defendCorridor))
		{
			_bResult2 = TRUE;

			//calc perim coords
			circlePerimPoint(_defendX, _defendY, ref _x, ref _y, (_range + _defendCorridor / 2));	//move defense locations to the base perimeter

			/* If for base defenders, then remember defend location for newly built units */
			if(_defendGr == defendGr)
			{
				defendX = _x;
				defendY = _y;
			}
		}

		_result = numFriendlyWeapObjInRange(me, _x, _y, (10 * 128), FALSE);
		_result2 = numEnemyWeapObjInRange(me, _x, _y, (10 * 128), FALSE);

		if((_defendGr.members >= _minDefenders) or (_result >= _result2))	//don't send one by one or if dangerous
		{
			initIterateGroup(_defendGr);
			_droid = iterateGroup(_defendGr);
			while(_droid != NULLOBJECT)
			{
				_order = DORDER_SCOUT;		//default defend order

				/* if unit already going to defend loc, check if there's actually an enemy left at that loc */
				_bResult = FALSE;
				if(_bResult2 and (_droid.orderx > 0) and (numEnemyWeapObjInRange(me, _droid.orderx, _droid.ordery, (7 * 128), FALSE) == 0)) 	//if we have an enemy inside, then cancel order to the perim
				{
					_bResult = TRUE;
				}

				/* Check if there's a new target which is closer to the base heart */
				if(not _bResult)		//won't move defender already anyway
				{
					if(_droid.orderx > 0)
					{
						_dist = distBetweenTwoPoints(_defendX, _defendY, _droid.orderx, _droid.ordery) - distBetweenTwoPoints(_defendX, _defendY, _x, _y);
						if(_dist > _moveCloserThreshold)		//if much closer
						{
							_bResult = TRUE;		//move back a bit
							_order = DORDER_MOVE;	//make sure will go directly to the closest enemy
							dbg("FOUND A CLOSER ENEMY!!!", me);
						}
					}
				}

				if((_droid.order == DORDER_NONE) or (_droid.order == DORDER_MOVE) or _bResult)	//nothing or returning too base
				{
					if((_droid.order != DORDER_ATTACK) and (distBetweenTwoPoints(_droid.x, _droid.y, _x, _y) > _moveCloserThreshold))		//don't touch if attacking arty and don't make it 'break-dance', if already there
					{
						orderDroidLoc(_droid, _order, _x, _y);
					}
				}
				_droid = iterateGroup(_defendGr);
			}
		}
	}

	/* check if defenders went too far from base */
	initIterateGroup(_defendGr);
	droid = iterateGroup(_defendGr);
	while(_droid != NULLOBJECT)
	{
		if(distBetweenTwoPoints(_droid.x, _droid.y, _defendX, _defendY) > (_range + _defendCorridor))	//too far from base
		{
			//if(not threatInRange(me, droid.x, droid.y, (8 * 128), FALSE))		//no targets
			//{
				if(_droid.order != DORDER_ATTACK)	//retreat even if busy but not directly attacking
				{
					if(not((_droid.order != DORDER_NONE) and (distBetweenTwoPoints(_droid.orderx, _droid.ordery, _defendX, _defendY) <= (_range + _defendCorridor / 2))))		//make sure not already returning
					{
						//find a closest point at a base perimeter to retreat to
						_x = _droid.x;
						_y = _droid.y;

						circlePerimPoint(_defendX, _defendY, ref _x, ref _y, (_range + _defendCorridor / 2 - 128));		//move just before base defenses

						orderDroidLoc(_droid, DORDER_MOVE, _x, _y);
					}
				}
			//}
		}
		_droid = iterateGroup(_defendGr);
	}

	//dbg(" " & me & ")  END defendBase");
}



function void findFreeSpot(int _x, int _y)
{
	retInt = _x;
	retInt2 = _y;

	_temp = _x;
	_temp2 = _y;
	if(pickStructLocation(fac, ref _temp, ref _temp2, me))
	{
		retInt = _temp; retInt2 = _temp2;
		return;
	}

	return;
}

function void findFreeSpotMedium(int _x, int _y)
{
	retInt = _x;
	retInt2 = _y;

	_temp = _x;
	_temp2 = _y;
	if(pickStructLocation(powGen, ref _temp, ref _temp2, me))
	{
		retInt = _temp; retInt2 = _temp2;
		return;
	}

	return;
}

function void findFreeSpotSmall(int _x, int _y)
{
	retInt = _x;
	retInt2 = _y;

	_temp = _x;
	_temp2 = _y;
	if(pickStructLocation(wall, ref _temp, ref _temp2, me))
	{
		retInt = _temp; retInt2 = _temp2;
	}
}

function void startCollecting()
{
	setState(stCollecting);

	dbg("COLLECT: started collecting state", me);

	setCollectingLoc();

	startCollectingPhase();

}

function void startCollectingPhase()
{
	phase = phCollecting;

	orderGroupLoc(sendAttackGr, DORDER_MOVE, collectX, collectY);	//use move, cause far away units may keep attacking forever

	collectTime = maxCollectTime;

	dbg("COLLECT: started collecting at " & collectX / 128 & " - " & collectY / 128, me);
}

function void setCollectingLoc()
{
	collectX = sendAttackGr.x; collectY = sendAttackGr.y;

	dbg("setCollectingLoc() - mostOfGroup(): " & collectX / 128 & " - " & collectY / 128, me);

	//result3 = findFreeSpot(collectX, collectY);			//a lot of free space
	//collectX = retInt;	collectY = retInt2;

	dbg("setCollectingLoc() - set collect at " & collectX / 128 & " - " & collectY / 128, me);
}

//gathered units or time is up
function bool canStopCollecting()
{
	//return - 0 or 1

	/* time up */
	if(collectTime <= 0)
	{
		return(TRUE);
	}

	//temp = finishedCollecting();

	return(finishedCollecting());
}

//gathered units
function bool finishedCollecting()
{
	//return - 0 or 1

	/* most of them collected */
	if(distBetweenTwoPoints(collectX, collectY, sendAttackGr.x, sendAttackGr.y) < (5 * 128))
	{
		return(TRUE);
	}

	return(FALSE);
}

function bool enoughDroppers()
{
	if((attackGr.members + sendAttackGr.members + defendGr.members - numDefenders) >= numDroppers)
	{
		return(TRUE);
	}

	return(FALSE);
}

function bool alliesReadyToDrop()
{
	_temp = 0;
	_temp2 = 0;

	while(_temp < multiPlayerMaxPlayers)
	{
		if(allianceExistsBetween(me , _temp))
		{
			if(allyState[_temp] == stDrop)		//gonna drop
			{
				if(allyEnemy[_temp] == enemy)	//dropping the same enemy as me
				{
					if(allyPhase[_temp] < phWaitAllies)
					{
						return(FALSE);		//not ready yet
					}
				}
			}
		}
		_temp = _temp + 1;
	}

	return(TRUE);		//all ok
}

function int getNumTransporters()
{
	_temp = 0;

	//Iterate through all player droids
	InitEnumDroids(me,me);
	_droid = EnumDroid();
	while(_droid != NULLOBJECT)
	{
		if(_droid.droidType == DROID_TRANSPORTER)
		{
			_temp = _temp + 1;
		}

		_droid = EnumDroid();
	}

	return(_temp);
}

function bool enoughTransporters()
{
	temp = numTransporters;

	temp2 = getNumTransporters();

	if(temp2 >= temp)
	{
		return(TRUE);
	}

	return(FALSE);
}

function void buildTransporters()
{
	temp = numTransporters;

	/* how many got already */
	temp2 = getNumTransporters();
	//temp2 = temp2 + numTemplatesInProduction(tmplUnitransporter,me);	//FIXME

	//if(temp2 >= temp){exit;}

	/* build transporters */
	initEnumStruct(FALSE,vtolfac,me,me);
	tempStruct = enumStruct();
	while((tempStruct != NULLOBJECT) and (temp2 < temp))
	{
		if(structureIdle(tempStruct))
		{
			//if(skCanBuildTemplate(me, tempStruct, tmplUnitransporter))
			if(skGetFactoryCapacity(tempStruct) >= 2)		//fully upgraded
			{
				dbg("started to build transporter", me);
				//buildDroid(tmplUnitransporter, tempStruct, me, 1);		//FIXME
				temp2 = temp2 + 1;
			}
		}

		tempStruct = enumStruct();
	}
}

function void fillDroppers()
{
	temp = defendGr.members - numDefenders;

	temp2 = 0;

	while((temp > 0) and (temp2 < numDroppers))	//leave 'numDefenders' number of units in the defendGr
	{
		temp4 = 99999;
		tempDroid2 = NULLOBJECT;

		/* get closest tank */
		initIterateGroup(defendGr);
		tempDroid = iterateGroup(defendGr);
		while(tempDroid != NULLOBJECT)
		{
			temp3 = distBetweenTwoPoints(baseX, baseY, tempDroid.x, tempDroid.y);
			if(temp3 < temp4)
			{
				temp4 = temp3;
				tempDroid2 = tempDroid;
			}
			tempDroid = iterateGroup(defendGr);
		}

		if(tempDroid2 != NULLOBJECT)	//got closest
		{
			groupAddDroid(sendAttackGr, tempDroid2);
		}
		else
		{
			temp2 = numDroppers;	//exit loop
		}

		temp = temp - 1;	//one less left in defendGr
		temp2 = temp2 + 1;	//one more loaded
	}

	selectGroup(sendAttackGr, TRUE);
}

function void dropLoadTransport()
{
	//transportGr

	dbg("loading total " & numTransporters & " transporters (" & transportGr.members & " units)",me);

	if(transportGr.members == 0){exit;}

	/* load transports */
	temp = 0;

	while(temp < maxTransporters)
	{
		if(transporter[temp] != NULLOBJECT)
		{
			temp5 = transporterCapacity(transporter[temp]);
			//dbg("transporterCapacity[" & temp & "] = " & temp5, me);

			while(temp5 > 0)
			{
				temp4 = 99999;
				tempDroid2 = NULLOBJECT;

				/* get closest tank */
				initIterateGroup(transportGr);
				tempDroid = iterateGroup(transportGr);
				while(tempDroid != NULLOBJECT)
				{
					if(tempDroid.order != DORDER_EMBARK)
					{
						//dbg("!= DORDER_EMBARK", me);

						temp3 = distBetweenTwoPoints(transporter[temp].x, transporter[temp].y, tempDroid.x, tempDroid.y);
						if(temp3 < temp4)
						{
							temp4 = temp3;
							tempDroid2 = tempDroid;
						}
					}
					tempDroid = iterateGroup(transportGr);
				}

				if(tempDroid2 != NULLOBJECT)	//got closest
				{
					//dbg("Unit embarking", me);
					orderDroidObj(tempDroid2, DORDER_EMBARK, transporter[temp]);
				}

				temp5 = temp5 - 1;
			}

		}
		temp = temp + 1;
	}
}

function bool transporterLoaded()
{
	/* check if anyone is still waiting to be loaded */
	if(transportGr.members <= numTransporters)	// > 90% loaded
	{
		dbg("transporter loaded!!!", me);
		return(TRUE);
	}

	/* check if loaded max number of droids (for example 20 for 2 transporters) */
	temp = numDroidsLoaded();
	temp2 = getNumTransporters();

	if(temp >= (temp2 * 10))
	{
		dbg("transporter loaded!!! 2", me);
		return(TRUE);
	}

	//dbg("transporter not loaded", me);
	return(FALSE);
}

//returns how many drois were loaded into transporters
function int numDroidsLoaded()
{
	/* load transports */
	_temp = 0;
	_temp2 = 0;		//how many loaded

	while(_temp < maxTransporters)
	{
		if(transporter[_temp] != NULLOBJECT)
		{
			_temp2 = (10 - transporterCapacity(transporter[_temp])) + _temp2;

		}
		_temp = _temp + 1;
	}

	return(_temp2);
}

function int numActiveEnemyDrop(int _enemyToCheck)
{
	if(_enemyToCheck < 0){return(maxAllyDroppers);}

	retInt = 0;
	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if((_temp != me) and (allianceExistsBetween(me , _temp)))
		{
			if((allyState[_temp] == stDrop) and (allyEnemy[_temp] == _enemyToCheck) and (allyPhase[_temp] >= phWaitAllies))	//will drop very soon
			{
				retInt = retInt + 1;
			}
		}
		_temp = _temp + 1;
	}

	return(retInt);
}

function int numAlliesDroppingPlayer(int _player)
{
	if(_player < 0){return(maxAllyDroppers);}

	retInt = 0;
	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if((_temp != me) and (allianceExistsBetween(me , _temp)))
		{
			if((allyState[_temp] == stDrop) and (allyEnemy[_temp] == _player))
			{
				retInt = retInt + 1;
			}
		}
		_temp = _temp + 1;
	}

	return(retInt);
}

function bool timeToDrop()
{
	//drop if we are further away from the enemy than all allies or if our turn has came

	if((curBase[enemy][0] <= 0) or (curBase[enemy][1] <= 0))
	{
		MsgBox("timeToDrop - curBase[enemy][x/y] <= 0 (" & me & ")");
		return FALSE;}

	if(enemy == none)
	{
		MsgBox("timeToDrop - no enemy set (" & me & ")");
		return FALSE;}

	_temp3 = me;
	_range = distBetweenTwoPoints(baseX, baseY, curBase[enemy][0], curBase[enemy][1]) + (3 * 128);	//+ (3 * 128) := reduce the cahnce that no one starts since all players store different ally coords

	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if((_temp != me) and (allianceExistsBetween(me , _temp)))
		{
			//if((allyState[_temp] == stDrop) and (allyEnemy[_temp] == enemy) and (allyPhase[_temp] >= phWaitAllies))	//check only those allies that are dropping the same enemy and are potentially ready
			if((allyState[_temp] == stDrop) and (allyEnemy[_temp] == enemy))
			{
				if(allyPhase[_temp] < phSync)	//someone not loaded transporters yet
				{
					return FALSE;
				}
				else
				{
					dbg("Ally phase is " & allyPhase[_temp], me);
				}

				if((curBase[_temp][0] > 0) and (curBase[_temp][1] > 0))		//know where this ally is
				{
					_temp2 = distBetweenTwoPoints(curBase[_temp][0], curBase[_temp][1], curBase[enemy][0], curBase[enemy][1]);

					/* is he farther away than all */
					if(_temp2 > _range)
					{
						_range = _temp2;
						_temp3 = _temp;		//remember furtherst ally
					}
				}
			}

		}
		_temp = _temp + 1;
	}

	if(_temp3 == me)	//no ally is farther than us or we're the only player dropping
	{
		dbg("timeToDrop - i'm furthest!!!!!", me);
		return TRUE;	//we are first
	}

	/* check if anyone has started transporting already */
	if(dropStartTime == none)
	{
		return(FALSE);		//wait for the furtherst player to start dropping
	}

	/* check how much time passed since first ally started drop, assuming sped = 1 tile/s */
	_temp = distBetweenTwoPoints(curBase[_temp3][0], curBase[_temp3][1], curBase[enemy][0], curBase[enemy][1]) - distBetweenTwoPoints(baseX, baseY, curBase[enemy][0], curBase[enemy][1]);	//dist diff ((ally - enemy) - (me - enemy))
	if(((gameTime / 10) - dropStartTime) >= (_temp / 128))	//more time passed in secs than the diff in tiles between (furtherst ally - enemy) and (me - enemy)
	{
		dbg("timeToDrop() - syncing drop!!!!!", me);
		return(TRUE);	//now!!
	}

	return(FALSE);		//not yet, wait to sync drop
}

function void doDrop()
{
	if((transportX <= 0) or (transportY <= 0))
	{
		MsgBox("doDrop - transportX <= 0 (" & me & ")");
		return;
	}

	dbg("doDrop!!!", me);

	notifyStartDrop();		//tell we are starting to drop now

	/* if some units could not be loaded into transporters, add to defenders */
	if(transportGr.members > 0)
	{
		_temp = transportGr.members;
		groupAddGroup(defendGr, transportGr);
		dbg(" " & _temp & " units could not be loaded", me);
	}

	temp = 0;
	while(temp < numTransporters)
	{
		if(transporter[temp] != NULLOBJECT)
		{
			orderTranspDisembark(transporter[temp], transportX, transportY);
		}
		temp = temp + 1;
	}

	/* return those who were not loaded back to defenders */
	groupAddGroup(defendGr, transportGr);
}

//---------------------------------------------
//	order transporter to send
//---------------------------------------------
function void orderTranspDisembark(DROID _transporter, int _coordx, int _coordy)
{
	bTempResult = chooseValidLoc(ref temp2, ref temp3, _coordx, _coordy, me, -1);	//no threat check
	if(bTempResult)
	{
		dbg("ordered to disembark", me);
		orderDroidLoc(_transporter, DORDER_DISEMBARK, temp2, temp3);
	}
	else
	{
		dbg("couldn't find a valid location for DISEMBARK!!!!!!!!!!!", me);
	}
}

event transLanded(inactive)
{
	dbg("Transporter landed", me);

	if(tempGr.members == 0){exit;}

	if((state == stNone) or (state == stDefending))		//not doing anything, so unload to defenders
	{
		groupAddGroup(defendGr, tempGr);
	}
	else
	{
		dbg("Added " & tempGr.members & " units to sendAttackGr", me);
		groupAddGroup(sendAttackGr, tempGr);
	}

	/* check if have to fly it back to the base */
	//temp = isInMyBase(droid.x, droid.y);
	if(not isInMyBase(droid.x, droid.y))
	{
		dbg("ordering transporter back to base", me);

		findFreeSpotSmall(baseX, baseY);
		temp2 = retInt;	temp3 = retInt2;

		orderDroidLoc(droid, DORDER_MOVE, temp2, temp3);
	}
}

function bool checkTransportersLanded()
{
	local bool	_bLanded;

	_bLanded = TRUE;	//all landed
	temp = 0;

	while(temp < numTransporters)
	{
		if(transporter[temp] != NULLOBJECT)
		{
			if(transporterCapacity(transporter[temp]) < 10)	//not all unloaded
			{
				_bLanded = FALSE;
			}
		}
		temp = temp + 1;
	}

	return(_bLanded);
}

function int setNumDroppers()
{
	retInt = maxDroppers;

	/* check how much we will have to invest into this drop */
	if(playerPower(me) < highPower)
	{
		temp = numAvailableAttackers();

		/* attack force*/
		if((retInt - temp) > 10)		//can't afford building this many
		{
			retInt = medDroppers;
			dbg("Medium droppers", me);
		}

		temp = calcNumRequiredTransporters(retInt);

		temp2 = getNumTransporters();

		/* check transporters */
		if((temp - temp2) >= 1)		//allow to build only 1 new transp for every drop
		{
			retInt = (temp2 + 1) * 10;	//as many as we have transporters already + 1
			//if(temp2 <= 0)			//no transporters yet
			//{
			//	retInt = minDroppers;	//smallest drop possible
			//	dbg("Min droppers", me);
			//}

			dbg("Min droppers", me);

			/* make sure we stay in bounds */
			if(retInt > maxDroppers)
			{
				retInt = maxDroppers;
			}
		}
	}

	return(retInt);
}

function int calcNumRequiredTransporters(int _numUnits)
{
	/* decide how many transporters we need */
	_retInt = _numUnits / 10;
	if((_retInt * 10) != _numUnits)		//fix integer div
	{
		_retInt = _retInt + 1;
	}

	if(_retInt > maxTransporters)
	{
		_retInt = maxTransporters;
	}

	return(_retInt);
}

function void prepareTransporters()
{
	temp = 0;

	while(temp < numTransporters)
	{
		if(transporter[temp] != NULLOBJECT)
		{
			if(transportGr.members > 0)
			{
				temp2 = transportGr.x;
				temp3 = transportGr.y;

				circlePerimPoint(baseX, baseY, ref temp2, ref temp3, baseRange);

				findFreeSpotMedium(temp2, temp3);
				temp2 = retInt;	temp3 = retInt2;

				orderDroidLoc(transporter[temp], DORDER_MOVE, temp2, temp3);
			}
		}

		temp = temp + 1;
	}
}

function void updateDropPhase()
{
	/* check if already can build transporter */
	if(phase == phGettingTech)
	{
		//if(researchFinished(resUnitTransporter, me))
		//{
			phase = phGettingUnits;
		//}
	}

	if(phase == phGettingUnits)
	{
		result3 = getNumTransporters();

		/* if we hit unit limit, we'll never be able to build transporters */
		if((result3 < numTransporters) and (getDroidCount(me) >= unitLimit))
		{
			if(result3 > 0)		//got at least 1 transp
			{
				numTransporters = result3;		//continue with whatever we have
				numDroppers = numTransporters * 10;
			}
		}

		/* check if have enough units and transp for drop */
		//result = enoughDroppers();
		//result2 = enoughTransporters();

		if(enoughDroppers() and enoughTransporters())
		{
			/* notify allies and start waiting for other allies */
			notifyReadyToDrop();
			prepareTransporters();	//make sure units can reach them
			tWaitAlliesDrop = tMaxWaitAlliesDrop;		//start wait-for-allies timer

			phase = phWaitAllies;		//wait for others
		}
	}

	if(phase == phWaitAllies)
	{
		/* check if other allies are also ready to drop */
		if(alliesReadyToDrop() or (tWaitAlliesDrop <= 0))	//all ready or waited for too long
		{
			fillDroppers();

			startTransportState(sendAttackGr, curBase[enemy][0], curBase[enemy][1]);
		}
	}

	/* we are back from transport state */
	if(phase == phTransportDone)
	{
		stopDropState();		//can stop drop now and resume any paused state (if any)
	}
}

function void updateTransport()
{
	if(phase == phLoadingTransport)
	{
		if(transporterLoaded())				//loaded
		{
			phase = phSync;
			tSyncDrop = tMaxSyncDrop;		//start sync with allies countdown
			notifyLoadedTransporters();
			//exit;		//if just finished dropping enemy, give allies time to reset their states, otherwise will think they are still dropping some enemy
		}
		else if((tWaitLoadDrop <= 0) or (dropStartTime != none))		//waited too long, or someone has started drop already!!!, drop now
		{
			temp = numDroidsLoaded();

			temp2 = numAlliesDroppingPlayer(enemy);

			if((temp >= (numDroppers * 30 / 100)) or ((temp2 > 0) and (temp > 0)))				// 30% of all droppers were loaded or not the only one dropping and loaded something
			{
				phase = phSync;
				tSyncDrop = tMaxSyncDrop;		//start sync with allies countdown
				notifyLoadedTransporters();
				//exit;		//if just finished dropping enemy, give allies time to reset their states, otherwise will think they are still dropping this enemy
			}
			else
			{
				cancelTransportState();	//couldn't load enough
			}
		}
		else
		{
			dropLoadTransport();
		}
	}

	/* syncronize drop with allies, wait if needed */
	if(phase == phSync)
	{
		if(timeToDrop() or (tSyncDrop <= 0))		//can drop now or waited too long
		{
			if(tSyncDrop <= 0)
			{
				dbg("tSyncDrop timeout - time to drop!!!!", me);
			}
			else
			{
				dbg("timeToDrop() - time to drop!!!!", me);
			}

			phase = phSendDrop;		//on the way to the enemy
			doDrop();
		}
		else
		{
			dbg("waiting for my turn to drop", me);
		}
	}

	/* watch for transporters to arrive */
	if(phase == phSendDrop)
	{
		if( checkTransportersLanded() )		//all unloaded
		{
			dbg("Transporter landed!!!!!!!!!!!", me);
			stopTransportState();
		}
	}

	//dbg("phase = " & phase, me);
}

function void startTransportState(GROUP _groupToTransport, int _destinationX, int _destinationY)
{
	dbg("Starting transport phase!!!!!!", me);

	transportX = _destinationX;
	transportY = _destinationY;
	transportGr = _groupToTransport;

	temp = getNumTransporters();
	if(temp == 0)
	{
		cancelTransportState();
		return;
	}

	if(state != stNone)
	{
		saveCurrentState();
	}

	endState();		//init vars of the original state

	setState(stTransporting);
	phase = phLoadingTransport;

	tWaitLoadDrop = tMaxWaitLoadDrop;

	dropLoadTransport();
}

function void saveCurrentState()
{
	savedState = state;
	//savedPhase = phase;
	//savedEnemy = enemy;
}

function void loadSavedState()
{
	dbg("loading saved state!!!!!!!!", me);

	if(savedState == stDrop)
	{
		/* after drop complete start attacking enemy */

		dbg("loaded drop state!!!!!!!!", me);

		setState(savedState);
	}
	else	//?, just init state and phase vars
	{
		stopTransportState();
	}

	/* clear vars */
	eraseLoadSavedState();
}

function void eraseLoadSavedState()
{
	savedState = stNone;
	savedPhase = phNone;
	savedEnemy = none;
}

function void resortTransporters()
{
	temp = 0;
	while(temp < maxTransporters)
	{
		if(transporter[temp] == NULLOBJECT)
		{
			/* check if we have a droid up in the array */
			temp2 = temp + 1;	//go up from current, assume bottom fixed
			while((temp2 < maxTransporters) and (transporter[temp] == NULLOBJECT))
			{
				if(transporter[temp2] != NULLOBJECT)
				{
					/* swap in array */
					transporter[temp] = transporter[temp2];
					transporter[temp2] = NULLOBJECT;
				}

				temp2 = temp2 + 1;
			}
		}

		temp = temp + 1;
	}
}


function void startDropPhase()
{
	if(enemy < 0){MsgBox("startDropPhase - enemy < 0"); return;}
	if((curBase[enemy][0] <= 0) or (curBase[enemy][1] <= 0)){MsgBox("startDropPhase - enemy coords < 0"); return;}
	if(not knowBase[enemy]){MsgBox("startDropPhase - knowBase[enemy] == FALSE"); return;}

	setState(stDrop);
	phase = phGettingTech;

	tempReinfCount[enemy] = 0;		//reset here
	dropStartTime = none;
	tSyncDrop = 0;

	/* decide how many units we will drop */
	numDroppers = setNumDroppers();

	/* decide how many transporters we need */
	numTransporters = calcNumRequiredTransporters(numDroppers);

	dbg("Preparing drop at " & getPlayerName(enemy) & " with " & numDroppers & " units and " & numTransporters & " transporters!!", me);

	sendForceX = curBase[enemy][0];
	sendForceY = curBase[enemy][1];

	resortTransporters();	//resort array

	updateDropPhase();
}

function void updateStateCoord(int _newx, int _newy)
{
	sendForceX = _newx;
	sendForceY = _newy;
}

function void startAttack(int _enemy, int _x, int _y)
{
	if(_enemy < 0){MsgBox("startAttack - _enemy < 0"); return;}
	if((_x <= 0) or (_y <= 0)){MsgBox("startAttack - enemy coords < 0"); return;}
	//if(not knowBase[enemy]){MsgBox("startAttack - knowBase[enemy] == FALSE"); return;}

	//if(state != stNone){return;}

	dbg("Starting attack at " & getPlayerName(_enemy) & " !!!!!", me);

	setState(stAttacking);

	enemy = _enemy;
	sendForceX = _x;
	sendForceY = _y;

	/* Add required number of units from defendGr to attackGr */
	fillAttackers(TRUE);

	startMovePhase();

	/* reset notification stuff */
	bNotifiedReadyAttack = FALSE;
	notifyReadyAttackTime = 0;

	reinfCount[enemy] = reinfCount[enemy] + 1;
	tempReinfCount[enemy] = tempReinfCount[enemy] + 1;

	countTakeOil = 0;		//allow hunting oil again
}

//Attack enemy base with VTOLs
function void vStartAttackBase(int _enemy)
{
	if(_enemy < 0){MsgBox("startAttack - _enemy < 0"); return;}
	if((_x <= 0) or (_y <= 0)){MsgBox("startAttack - enemy coords < 0"); return;}
	if(not knowBase[_enemy]){return;}

	//if(state != stNone){return;}

	dbg("Starting attack at " & getPlayerName(_enemy) & " !!!!!", me);

	//vstate = stAttackBase;

	//venemy = _enemy;

	//sendForceX = curBase[venemy][0];
	//sendForceY = curBase[venemy][1];

	//VTOLAttackBase(venemy);
}

/*
function void vAttackBase(int _enemy)
{
	local BASEOBJ	_newTarget;

	if(vtolGr.members < minVtolAttackers)
	{
		vstopState();
		return;
	}

	//check if too well defended
	if(not vtolSafe(vsendForceX, vsendForceY))
	{
		vstopState();
		return;
	}

	//idle?
	if(idleGroup(vtolGr) >= (vtolGr.members / 2))
	{
		// need new target
		_newTarget = vBaseTarget(_enemy);

		if(_newTarget == NULLOBJECT)
		{
			vstopState();	//nothing to attack
			return;
		}

		vDoAttackObj(vtolGr, _newTarget);
	}
}
*/

function void startMovePhase()
{
	if((sendForceX <= 0) or (sendForceY <= 0)){MsgBox("startMovePhase() - sendForceXY <= 0"); return;}

	orderGroupLoc(sendAttackGr, DORDER_SCOUT, sendForceX, sendForceY);

	reinfTime = maxReinfTime;	//start "cancel attack" countdown

	phase = phMoveToBase;

	dbg("MOVE PHASE: started", me);
}

function void startTakeOil(STRUCTURE _enemyDerrick)
{
	if(_enemyDerrick == NULLOBJECT){MsgBox("startTakeOil - derrick == NULLOBJECT"); return;}

	//if(enemy < 0){MsgBox("startTakeOil - enemy < 0"); exit;}
	//if((sendForceX <= 0) or (sendForceY <= 0)){MsgBox("startTakeOil - sendForceXY <= 0"); exit;}

	setState(stTakingOil);

	enemy = _enemyDerrick.player;
	tempReinfCount[enemy] = 0;		//reset

	sendForceX = _enemyDerrick.x;
	sendForceY = _enemyDerrick.y;

	dbg("Starting taking " & getPlayerName(enemy) & "'s oil at " & sendForceX / 128 & " - " & sendForceY / 128 & "!!!!!", me);

	/* Add required number of units from defendGr to attackGr */
	fillAttackers(FALSE);	// low -priority task

	startMovePhase();

	timeGuardPos = 0;	//cancel countdown
	tTakeOil = tMaxTakeOil;

	countTakeOil = countTakeOil + 1;	//remember how many times we took oil

	//phase = phMoveToBase;
}

/* Changes state and returns old state */
function void setState(int _newState)
{
	local int	_oldState;

	/* Initialize state time */
	tState = 0;

	_oldState = state;
	state = _newState;

	//return _oldState;
}

/* Changes vtol state and returns old state */
function void vsetState(int _newState)
{
	local int	_oldState;

	/* Initialize state time */
	//tvState = 0;

	_oldState = vstate;
	vstate = _newState;

	//return _oldState;
}

//don't leave BBs in defend group
function void sortOutBBs()
{
	initIterateGroup(defendGr);
	tempDroid = iterateGroup(defendGr);
	while(tempDroid != NULLOBJECT)
	{
		if(tempDroid.weapon == weaponBB)
		{
			groupAddDroid(sendAttackGr,tempDroid);
		}
		tempDroid = iterateGroup(defendGr);
	}
}

function void doAttack()
{
	//dbg(" " & me & ")  doAttack()");

	//if(state != stAttacking){return;}

	//if going back to base, check if already there
	//-----------------------------------------------
/*
	if(phase == phRTB)
	{
		range = (20 * 128);		//attacker reached home base range
		initIterateGroup(sendAttackGr);
		droid = iterateGroup(sendAttackGr);
		while(droid != NULLOBJECT)
		{
			if(distBetweenTwoPoints(droid.x, droid.y, droid.orderx, droid.ordery) < range)
			{
				groupAddDroid(defendGr,droid);
			}//check if going back to base
			else if(distBetweenTwoPoints(baseX, baseY, droid.orderx, droid.ordery) >= range)
			{
				orderDroid(droid, DORDER_RTB);	//send back to base
			}

			droid = iterateGroup(sendAttackGr);
		}

		//Migration not over yet?
		if(sendAttackGr.members <= 5)
		{
			groupAddGroup(defendGr, sendAttackGr);
			phase = phNone;
			dbg("attackers backin the base !!!", me);
		}
	}
*/

	//all real attack stuff comes here
	//-----------------------------------------------


	if(enemy < 0){MsgBox("doAttack - enemy < 0");return;}

	/* check if someone has destroyed our enemy */
	//if(dead[enemy] or ((not knowBase[enemy]) and (phase < phAttackingBase)))	//only if phAttacking < attacking => someone else did it
	if(dead[enemy] and (phase < phAttackingBase))	//only if phAttacking < attacking => someone else did it
	{
		dbg("someone destroyed enemy, cancel attack", me);
		stopAttack();
		return;
	}

	if((curBase[enemy][0] <= 0) or (curBase[enemy][1] <= 0)){MsgBox("doAttack - enemy coords < 0"); return;}



	/* Update coordinates */
	//if(curBase[enemy][0] > 0 and curBase[enemy][1] > 0)	//only update if set?
	//{
		sendForceX = curBase[enemy][0];
		sendForceY = curBase[enemy][1];
	//}

	//------------------------------------------------------------------------------
	//if we lost enemy base, were looking for it and found it, switch back to attack
	//------------------------------------------------------------------------------
	if((phase == phSearchingForBase) and (seeBase[enemy]))
	{
		dbg("after revealing found enemy base again, attack (!!!!!!!!!!!!)", me);
		phase = phMoveToBase;	//go to the new enemy base location
	}

	//--------------------------------------------------
	//send reinforcements
	//--------------------------------------------------
	//result = defendGr.members - numDefenders;	//available units
	//if((result >= minSendUnits) or ((result >= minSendUnits / 2) and (attackGr.members >= numAttackers / 2)) )	//enough reinf, or still many attackers and some reinf


	//------------------------------------------------
	//manage attack
	//------------------------------------------------

	//if there are enemy structures left, move closer to them to attack, don't run away

	//if((phase == phAttackingBase) and (seeBase[enemy]))	//not revealing the base territory already

	if(phase != phSearchingForBase)		//not already revealing
	{
		if(not seeBase[enemy])	//no targets, check if any unrevealed territory left
		{
			//if this loc is not recalled from memory (loc will be invisible then)
			//if((curBase[enemy][0] != base[enemy][0]) or (curBase[enemy][1]) != base[enemy][1])
			if(mapRevealedInRange(sendForceX, sendForceY, (2 * 128), me))		//if revealed so can judge if there's nothing
			{
				dbg("ATTACK: No visible enemy structures left, revealing territory !!!!!", me);
				phase = phSearchingForBase;
			}
		}
	}


	//reveal territory near the enemy base
	if(phase == phSearchingForBase)
	{
		range = (16 * 128);		//search for enemy structures in en base range

		initIterateGroup(attackGr);
		droid = iterateGroup(attackGr);
		while(droid != NULLOBJECT)
		{
			if((droid.order == DORDER_NONE) and (droid.action != DACTION_ATTACK) and (droid.action != DACTION_MOVETOATTACK))
			{
				//reveal more territory in the range of the enemy base, no threat check
				if(fogTileInRange(ref x, ref y, droid.x, droid.y, sendForceX, sendForceY, range, me, -1))		//no threat check
				{
					orderDroidLoc(droid, DORDER_SCOUT, x, y);
				}
				else if(phase != phLostBase)
				{
					dbg("nothing to reveal anymore, lost enemy base !!!", me);
					phase = phLostBase;	//no move unrevealed territory
				}
			}
			droid = iterateGroup(attackGr);
		}
	}

	//dbg(" " & me & ")  END doAttack()");
}

/* range in world units!!!! */
function void findAttackBaseTarget(DROID _looker, int _x, int _y, int _radius)
{
	ASSERT(_looker != NULLOBJECT, "findAttackBaseTarget: _looker is NULLOBJECT", me);

	retObj = NULLOBJECT;

	//dbg(" " & me & ")              findAttackBaseTarget");

	//find a target
	if((_looker.order == DORDER_NONE) or (_looker.order == DORDER_SCOUT) or (_looker.order == DORDER_MOVE))
	//if(_looker.order != DORDER_ATTACK)
	{
		//dbg(" " & me & ")              no order");
		if(objHasWeapon(_looker))
		{
			//dbg(" " & me & ")              has weapon");

			/* Use weapon range if no radius specified */
			temp = _radius;
			if(_radius < 0)
			{
				_radius = objWeaponMaxRange(_looker);	//objWeaponMaxRange is in world units
				_radius = _radius + (2 * 128);	//target range = droid weapon range + 2 tiles
			}

			if(_radius > 0)
			{
				/* Use unit coords if no position set where to look for units */
				if(_x < 0)
					_x = _looker.x;

				if(_y < 0)
					_y = _looker.y;

				/* see any trucks? */
				tempDroid = getClosestEnemyDroidByType(_x, _y, _radius, DROID_CONSTRUCT, FALSE, me);

				if(tempDroid == NULLOBJECT)
				{
					/* any repairers? */
					tempDroid = getClosestEnemyDroidByType(_x, _y, _radius, DROID_REPAIR, FALSE, me);

					if(tempDroid != NULLOBJECT)
					{
						if(tempDroid.action == DACTION_REPAIR)	//only if repairing
						{
							retObj = tempDroid;
						}
					}

					if(retObj == NULLOBJECT)
					{
						if(((_looker.action == DACTION_NONE) or (_looker.action == DACTION_DROIDREPAIR)) and (_looker.order == DORDER_NONE))	//didn't see a target that is actually near it
						{
							retObj = getClosestEnemy(_x, _y, _radius, TRUE, FALSE, me);
						}
					}
				}
				else
				{
					retObj = tempDroid;
				}

			}
		}
	}
}

function void findBBAttackBaseTarget(DROID _looker)
{
	retObj = NULLOBJECT;

	//temp = (2 * 128);	//"reached the destination" range

	if(_looker.order != DORDER_ATTACK)
	{
		//dbg(" " & me & ")              BB no order");
		if(objHasWeapon(_looker))
		{
			//dbg(" " & me & ")              BB has weapon");

			temp = objWeaponMaxRange(_looker);	//objWeaponMaxRange is in world units
			if(temp > 0)
			{
				//dbg(" " & me & ")              BB has range");

				temp2 = (temp + (3 * 128));	//target range = droid weapon range + 3 tiles

				tempStruct = getClosestEnemyStructByType(_looker.x, _looker.y, temp2, REF_DEFENSE, me);
				if(tempStruct == NULLOBJECT)
				{
					tempStruct = getClosestEnemyStructByType(_looker.x, _looker.y, temp2, REF_WALL, me);
					if(tempStruct == NULLOBJECT)
					{
						tempStruct = getClosestEnemyStructByType(_looker.x, _looker.y, temp2, REF_WALLCORNER, me);
					}

					if(tempStruct == NULLOBJECT)
					{
						tempStruct = getClosestEnemyStructByType(_looker.x, _looker.y, temp2, -1, me);	//any structure
						if(tempStruct != NULLOBJECT)
						{
							//dbg(" " & me & ")  BB found some structure");
							retObj = tempStruct;
						}
					}
					else
					{
						//dbg(" " & me & ")  BB found wall");
						retObj = tempStruct;
					}
				}
				else
				{
					//dbg(" " & me & ")  BB found defense");
					retObj = tempStruct;
				}

			}
		}
	}
}

function void checkStopAttack()
{
	if(state != stAttacking){return;}	//exit if doAttack() already called stopAttack()

	if(enemy < 0)
	{
		MsgBox("checkStopAttack() - enemy < 0");
		cancelAttack();
		return;
	}

	//------------------------------------------------------------------------------
	//Check if we failed
	//------------------------------------------------------------------------------
	if((reinfTime <= 0) and (phase < phAttackingBase) and (sendAttackGr.members <= minAttackers))	//not actively attacking or searching for base
	{
		dbg("cancelling attack !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!", me);

		cancelAttack();
	}

	//------------------------------------------------------------------------------
	//Check we succeeded
	//------------------------------------------------------------------------------
	else if((phase == phLostBase) and (not seeBase[enemy]))	//no enemy structures left (found)
	{
		dbg("cancelling attack, RTB", me);

		//knowBase[enemy] = FALSE;	//disabled 15.05.05 because phSearchingFor base was skipped because of this

		killedBase[enemy] = TRUE;	//remember this one's done, but doesn't have to be completely dead, so no dead[x] = TRUE;

		notifyPlayerBaseDestroyed(enemy);

		stopAttack();
	}
}


function void gatewayDefenses()
{
	result = numTrucksSameOrder(DORDER_LINEBUILD);

	if(result > 0){return;}		//max 1 truck can be busy with gateway defenses

	droid = closestIdleTruck(baseX, baseY);

	if(droid == NULLOBJECT)
	{
		return;
	}

	bResult = TRUE;

	x = baseX;
	y = baseY;

	count = numGatewayDef - 1;
	count2 = none;
	while(bResult and (count >= 0) )
	{
		if(isStructureAvailable(gatewayDef[count],me))
		{
			count2 = count;
			bResult = FALSE;	//found best one
		}
		count = count - 1;
	}
	if(not bResult)
	{
		skDefenseLocationB(ref x,ref y,wall,gatewayDef[count2],droid,me);
	}
}

//---------------------------------------------------------
//	Store experience
//---------------------------------------------------------
function void storeBaseDefLocEv()
{
	if(obj2 == NULLOBJECT)
	{
		MsgBox("storeBaseDefLocEv - obj2 is NULLOBJECT");
		return;
	}

	//Don't store if not enough time passed since the last save, but store new locations in any case
	if((getBaseDefendLocIndex(me, obj2.x, obj2.y) < 0) or (storeBaseDefTime[obj2.player] <= 0))
	{
		//move coords closer to base

		//temp = obj.x;
		//temp2 = obj.y;

		learnBaseDefendLoc(me, obj2.player, obj2.x, obj2.y);

		storeBaseDefTime[obj2.player] = storeTime;		//start countdown
	}

}

function void storeOilDefLocEv()
{
	if(obj2 == NULLOBJECT)
	{
		MsgBox("storeOilDefLocEv - obj2 is NULLOBJECT");
		return;
	}

	//Don't store if not enough time passed since the last save, but store new locations in any case
	if((getOilDefendLocIndex(me, obj2.x, obj2.y) < 0) or (storeOilDefTime[obj2.player] <= 0))
	{
		learnOilDefendLoc(me, obj2.player, obj2.x, obj2.y);

		storeOilDefTime[obj2.player] = storeTime;		//start countdown
	}
}


//---------------------------------
//Go meet ally's force
//---------------------------------
function void joinForces(int _joinPlayer, int _x, int _y)
{
	dbg("joining forces with " & _joinPlayer, me);

	setState(stJoiningForces);
	enemy = _joinPlayer;
	phase = phMoveToBase;

	timeGuardPos = 0;		//reset countdown

	sendForceX = _x;
	sendForceY = _y;

	fillAttackers(FALSE);

	msg("coming" , me, enemy);	//allyInThreat
}

//make sure group is going to the right place
function void coordinateSendMovement(int _sendX, int _sendY, int _range, int _order, GROUP _coordinateGr)
{
	local DROID _droid;

	initIterateGroup(_coordinateGr);
	_droid = iterateGroup(_coordinateGr);
	while(_droid != NULLOBJECT)
	{
		/* too far away and not going there */
		if(distBetweenTwoPoints(_sendX, _sendY, _droid.x, _droid.y) > _range)
		{
			if(_droid.orderx > 0)	//has move order
			{
				/* busy and going to wrong palce */
				if(distBetweenTwoPoints(_sendX, _sendY, _droid.orderx, _droid.ordery) > _range)	//don't touch if already on the way back
				{
					orderDroidLoc(_droid, _order, _sendX, _sendY);
				}
			}
			else if(_droid.order == DORDER_NONE)	//idle
			{
				orderDroidLoc(_droid, _order, _sendX, _sendY);
			}
		}

		_droid = iterateGroup(_coordinateGr);
	}
}

//check if units reached destination, if yes, add to a different group
function void checkReachedDestination(int _destX, int _destY, GROUP _toCheckGr, GROUP _toAddToGr, int _range)
{
	initIterateGroup(_toCheckGr);
	tempDroid = iterateGroup(_toCheckGr);
	while(tempDroid != NULLOBJECT)
	{
		//Check if reached destination
		if(distBetweenTwoPoints(_destX, _destY, tempDroid.x, tempDroid.y) <= _range)
		{
			dbg("attacker reached", me);

			if(_toCheckGr == sendAttackGr)
				selectDroid(tempDroid, FALSE);	//deselect since left sendAttackGr

			groupAddDroid(_toAddToGr, tempDroid);	//add to the new group
		}

		tempDroid = iterateGroup(_toCheckGr);
	}
}

function void updateDrop()
{
	if(dead[enemy])
	{
		cancelState();	//have to cancel to unload units
	}

	updateDropPhase();
}

event coordinatePhases(inactive)
{
	local int _sendRange,_sendersOrder,_reachedDestinationRadius;

	if(state == stNone)
		exit;	//attackers idling

	/* main stuff begins here */
	if(enemy < 0)
	{
		MsgBox(" " & me & " coordinatePhases() - no player set");
		exit;
	}

	/* Set radius of the destination point units can't go outside and order to give senders */
	_sendRange = (6 * 128);
	_reachedDestinationRadius = (17 * 128);		//Units have reached destination when they are within this range from the destination
	_sendersOrder = DORDER_SCOUT;
	if(state == stHelpingAlly)
	{
		_sendersOrder = DORDER_MOVE;		//don't waste time on the way
		_sendRange = sendHelpRange;			//give helpers move freedom to pursue attackers around ally's base
		_reachedDestinationRadius = sendHelpRange;		//Don't need to come as close, start helping defend sooner
	}

	if((sendForceX <= 0) or (sendForceY <= 0))
	{
		if(state == stHelpingAlly)
			msg("I can't see your  base" , me, enemy);	//allyInThreat

		dbg("coordinatePhases - (sendForceX <= 0) or (sendForceY <= 0)", me);
		cancelState();
		exit;
	}

	/* drop phase */
	if(state == stDrop)
	{
		updateDrop();
		exit;
	}

	/* transport phase */
	if(state == stTransporting)
	{
		updateTransport();
		exit;
	}

	if(state == stDefending)
		exit;		//defenders are sent to defend automatically

	/* make sure sendAttackGr droids are going to the destination */
	coordinateSendMovement(sendForceX, sendForceY, _sendRange, _sendersOrder, sendAttackGr);

	/* don't drift too far away from the defend location if defending oil or joining forces */
	if(phase == phGuardingPos)
	{
		coordinateSendMovement(sendForceX, sendForceY, _sendRange, DORDER_SCOUT, attackGr);
	}

	/* add to attackGr when sendAttackGr droids reached the destination point */
	checkReachedDestination(sendForceX, sendForceY, sendAttackGr, attackGr, _reachedDestinationRadius);


	/* start action when first unit reached the destination point */
	if((state == stTakingOil) or (state == stAttacking) or (state == stHelpingAlly))
	{
		if((attackGr.members > 0) and (phase == phMoveToBase))	//if anyone reached already
		{
			dbg("MANAGE UNITS: reached destination !!!!!", me);
			phase = phAttackingBase;
		}
	}
	/* start action when *most* of the units are there */
	else if(state == stJoiningForces)
	{
		if(phase == phMoveToBase)
		{
			if(attackGr.members >= (sendAttackGr.members * 3))	//most of units arrived
			{
				msg("ok, i'm there" , me, enemy);
				timeGuardPos = maxTimeGuardPos;
				phase = phGuardingPos;
				//exit;				//must exit since vars are reset
			}
		}
	}

	/* Check if have to switch back to phMoveToBase if no attackers left */
	if((phase == phAttackingBase) and (attackGr.members == 0))
	{
		dbg("no attackers, phase = phMoveToBase !!!!!!!!", me);
		phase = phMoveToBase;
		timeGuardPos = 0;		//reset the oil guarding time
	}


	/* Manage attack */
	if((state != stHelpingAlly) and ((phase == phAttackingBase)
		or (phase == phGuardingPos)))	//we are at the destination, stHelpingAlly is handled in manageHelpAlly()
	{
		initIterateGroup(attackGr);
		droid = iterateGroup(attackGr);
		while(droid != NULLOBJECT)
		{
			//find a target to attack
			if(droid.weapon == weaponBB)
			{
				findBBAttackBaseTarget(droid);
			}
			else
			{
				findAttackBaseTarget(droid, -1, -1, -1);
			}


			//attack enemy target
			if(retObj != NULLOBJECT)
			{
				orderDroidObj(droid, DORDER_ATTACK, retObj);
			}

			//too far from attack location?
			if((droid.order == DORDER_NONE) or ((droid.action != DACTION_MOVETOATTACK) and
			(droid.action != DACTION_ROTATETOATTACK) and (droid.action != DACTION_ATTACK)))
			{
				//set range
				if(objHasWeapon(droid))
				{
					range = objWeaponMaxRange(droid);
				}
				else	//repairs etc
				{
					range = (8 * 128);
				}

				if(distBetweenTwoPoints(droid.x, droid.y, sendForceX, sendForceY) > range)
				{
					//make sure it's not far away because going around a big ramp: check destination
					if(distBetweenTwoPoints(droid.orderx, droid.ordery, sendForceX, sendForceY) > range)	//not heading to the right location
					{
						dbg("too far from attack loc, send back", me);
						orderDroidLoc(droid, DORDER_SCOUT, sendForceX, sendForceY);
					}
				}
			}

			droid = iterateGroup(attackGr);
		}
	}

	/* check if lost enemy base or ally we are helping disallied */
	if(state == stHelpingAlly)	//will reveal territory if lost base, don't cancel attack here
	{
		if(not knowBase[enemy])		//no visible structures left for this player
		{
			//if(state == stHelpingAlly)
			//{
				msg("I don't see your  base" , me, enemy);	//allyInThreat
			//}

			dbg("coordinatePhases - not haveBase", me);
			stopAllyDefense();
			exit;
		}

		//did player disally while we are helping him?
		if(not ally[enemy])		//no visible structures left for this player
		{
			msg("backstabber!!!", me, enemy);	//allyInThreat
			breakAlliance(me, enemy);
			cancelAllyDefense();
			exit;
		}
	}
	else if(state == stTakingOil)
	{
		//see if it's hopeless to go on
		if((sendAttackGr.members + attackGr.members) < 4)
		{
			dbg("TAKE OIL: little attackers left, cancel", me);
			stopTakingOil();
			exit;
		}

		//see if we can stop guarding this oil resource already
		if((phase == phGuardingPos) and (timeGuardPos <= 0))		//guarding oil long enough
		{
			dbg("TAKE OIL: waiting time is up!!!!!!!!!!!!!", me);
			stopTakingOil();
			exit;
		}

		/* something went wrong or we failed */
		if(tTakeOil <= 0)
		{
			dbg("TAKE OIL: takeoil timeout!!!!!!!!!!!!!", me);
			stopTakingOil();
			exit;
		}

		//check if we can cancel guarding oil since have defenses
		//if(numStructsByTypeInRange(me, me, REF_DEFENSE, sendForceX, sendForceY, (8 * 128)) >= 1)
		if(numFriendlyWeapStructsInRange(me, sendForceX, sendForceY,  (8 * 128)) >= 1)	//also include ally's defenses
		{
			//if(numEnemyObjInRange(me, sendForceX, sendForceY, (8 * 128), FALSE) == 0)
			if(numEnemyWeapObjInRange(me, sendForceX, sendForceY, (8 * 128), FALSE) == 0)
			{
				dbg("TAKE OIL: oil is well-defended, rtb!!!!!!!!!!!!!", me);
				stopTakingOil();
				exit;
			}
		}

		//see if it's hopeless to go on
		if((attackGr.members + sendAttackGr.members + 1) < numEnemyWeapObjInRange(me, sendForceX, sendForceY, (8 * 128), FALSE))
		{
			dbg("TAKE OIL: they have more than us", me);
			stopTakingOil();
			exit;
		}


		//see if we killed all defenses and can start guard oil countdown
		if(phase != phGuardingPos)	//not set yet
		{
			//if(numEnemyObjInRange(me, sendForceX, sendForceY, (8 * 128), FALSE) == 0)	//enemy derrick is destroyed and no enemy defenses left
			if(numEnemyWeapObjInRange(me, sendForceX, sendForceY, (8 * 128), FALSE) == 0)
			{
				if(attackGr.members > 0)	//if we reached destination
				{
					dbg("TAKE OIL: no enemies, started guarding", me);
					timeGuardPos = maxTimeGuardPos;
					phase = phGuardingPos;
				}
			}
		}
	}
	else if(state == stJoiningForces)	//check if waited long enougn
	{
		/* see if we can stop waiting at joining pos already */
		if((phase == phGuardingPos) and (timeGuardPos <= 0))
		{
			dbg("JOIN FORCES: waiting time is up!!!!!!!!!!!!!", me);
			if(random(2) == 1)
			{
				msg("I'm going back" , me, enemy);
			}
			stopJoiningForces();
			exit;
		}
	}

	/* check if we can send reinforcements, use more units if state == stHelpingAlly */
	if(enoughReinf(state == stHelpingAlly))		//got enough
	{
		fillReinforcements(state == stHelpingAlly);
	}

/*
	if(state == stHelpingAlly)	//use more units for help
	{
		//if(defendGr.members > minDefenders)
		//{
		//	if(((attackGr.members + sendAttackGr.members) < minSendUnits) or (defendGr.members > numDefenders))	//sent not enough or have too many anyway
		//	{
				dbg("HELP ALLY: sending reinforcements", me);
				fillReinforcements(TRUE);
				//fillHelpers();
		//	}
		//}
	}
	else
	{
		if(enoughReinf(FALSE))		//got enough
		{
			fillReinforcements();
		}
	}
*/

}

function void saveExperience()
{
	if(not bLearn){return;}

	savePlayerAIExperience(me, FALSE);	//silent save

	timeSaveExperience = maxTimeSaveExperience;

	dbg("Saved AI Experience (*)", me);
}

//---------------------------------------------------------
//Don't trigger experience callbacks too frequently
//---------------------------------------------------------
event everySecEv(inactive)
{


	/* Update research urgency */
	temp = curResUrgency + (numDefaultResearch - numBusyByType(resFac));	//minResearch = average, find out far we are from the average now, remember we need to make more later if lower than minResearch currently
	//can only be set manually outside of the bounds!
	if(temp > maxResUrgency)		//going outside of the highest boundry
	{
		temp = max(curResUrgency,maxResUrgency);	//trim to the highest value or to curResUrgency, if it was set manually to a higher value than the high boundry
	}
	else if(temp < minResUrgency)		//going outside of the lowest boundry
	{
		temp = min(curResUrgency,minResUrgency);	//trim to the lowest value or to curResUrgency, if it was set manually to a lower value than the low boundry
	}

	curResUrgency = temp;		//Update

	/* Update duration of current state */
	tState = tState + 1;

	/* Update Reinforcement Countdown */
	if(reinfTime > 0)
		reinfTime = reinfTime - 1;

	/* lasSat rechargement */
	if((lasSatState[me] == lsRecharging) or (lasSatState[me] == lsRequesterWaitingRecharging))	//only recharge if we built lasSat already and are not recharged already (would reset waiting state)
	{
		tLasSat = tLasSat + 1;		//continue recharging
	}

	/* wait for allies' lassat to recharge */
	//if(lasSatState[me] == lsWaiting)
	if(tLasSatCountdown >= 0)		//if we turned on the countdown for something (!= off)
	{
		tLasSatCountdown = tLasSatCountdown - 1;
	}

	/* requester has fired, now we fire with a little delay for more effectiveness, must be fired here, because every sec is important for the sync */
/*
	if(lasSatState[me] == lsDelayedFiring)
	{
		if(tLasSatCountdown <= 0)
		{
			lasSatTarget = findLasSatTarget(lasSatEnemy);
			if(lasSatTarget != NULLOBJECT)
			{
				fireLasSat(lasSatTarget);
			}
		}
	}
*/


	if(helpTime > 0)
		helpTime = helpTime - 1;

	if(timeGuardPos > 0)
		timeGuardPos = timeGuardPos - 1;

	if(requestHelpTime > 0)
		requestHelpTime = requestHelpTime - 1;

	if(collectTime > 0)
		collectTime = collectTime - 1;

	if(timeNotifyEnemyInBase > 0)
		timeNotifyEnemyInBase = timeNotifyEnemyInBase - 1;

	if(tWaitAlliesDrop > 0)
		tWaitAlliesDrop = tWaitAlliesDrop - 1;

	if(tWaitLoadDrop > 0)
		tWaitLoadDrop = tWaitLoadDrop - 1;

	if(tSyncDrop > 0)
		tSyncDrop = tSyncDrop - 1;

	if(tTakeOil > 0)
		tTakeOil = tTakeOil - 1;

	if(timeSaveExperience > 0)
	{
		timeSaveExperience = timeSaveExperience - 1;

		if(timeSaveExperience <= 0)
		{
			saveExperience();
		}
	}

	if(notifyReadyAttackTime > 0)
	{
		notifyReadyAttackTime = notifyReadyAttackTime - 1;

		if(notifyReadyAttackTime == 0)	//remember countdown is finished
		{
			bNotifiedReadyAttack = TRUE;
			dbg("bNotifiedReadyAttack == TRUE", me);
		}
	}

	//store exrepience countdown for every player
	_temp = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(storeOilDefTime[_temp] > 0)
		{
			storeOilDefTime[_temp] = storeOilDefTime[_temp] - 1;
		}

		if(storeBaseDefTime[_temp] > 0)
		{
			storeBaseDefTime[_temp] = storeBaseDefTime[_temp] - 1;
		}

		if(allyOfferTime[_temp] > 0)
		{
			allyOfferTime[_temp] = allyOfferTime[_temp] - 1;
		}

		if(tRequestStatus[_temp] > 0)
		{
			tRequestStatus[_temp] = tRequestStatus[_temp] - 1;
		}

		if(tWaitPlayerReply[_temp] > 0)
		{
			tWaitPlayerReply[_temp] = tWaitPlayerReply[_temp] - 1;
		}

		_temp = _temp + 1;
	}

	tLastResearch = tLastResearch + 1;	//will be reset by doResearch if research is not idle
}

function bool checkFollowAttackRequest(int _attackRequester, bool _bHighPriorityTask)
{
	if((state == stDefending) or (state == stAttacking) or
		(state == stDrop) or (state == stTransporting) or
		((state == stHelpingAlly) and (enemy != _attackRequester)))
	{
		notifyStatus(_attackRequester);
		return(FALSE);
	}

	if(not haveTheoretilcallyMinAttackers(_bHighPriorityTask))
	{
		msg("let me get more units", me, _attackRequester);
		return(FALSE);
	}

	return(TRUE);
}

function bool isCurrentOrder(int _state, int _enemy)
{
	local int _dummy;	//FIXME
	_dummy = 0;
	return ((_state == state) and (enemy == _enemy));
}

function bool canAlly(int _player)
{
	if(allianceExistsBetween(_player ,me))
	{
		return(FALSE);		//already allied
	}

	/* check if attacked by this player */
	if(state == stDefending)
	{
		if(numPlayerWeapObjInRange(_player, me, baseX, baseY, baseRange + (5 * 128), FALSE) > 5)	//attacking us
		{
			return(TRUE);
		}
	}

	if((state != stNone) and (enemy == _player))
	{
		return(FALSE);
	}

	/* check not allied to too many players already */
	if((numAllies(me) + 1) >= (multiPlayerMaxPlayers / 2))
	{
		return(FALSE);
	}

	return(TRUE);
}

//decide if last beacon was placed long ago
function bool beaconTimeout(int _player)
{
		if((tBeacon[_player] > 0) and (( tBeacon[_player] + tBeaconTimeout) < (gameTime / 10)))	//not too long ago
		{
			return TRUE;	//this beacon is still 'fresh'
		}

		return FALSE;
}

function bool haveBeacon(int _player)
{
		if((tBeacon[_player] > 0) and (not beaconTimeout(_player)))
		{
			return TRUE;	//have beacon for this player
		}

		return FALSE;
}

function void makeAlliances()
{
	/* find closest player */
	temp = bestAlliancePlayer();
	if(temp == none)
	{
		temp = random(multiPlayerMaxPlayers);
	}

	if(temp == me){return;}
	if(allianceExistsBetween(me, temp)){return;}	//my ally
	if(allyOfferTime[temp] > 0){return;}		//offered already


	/* don't offer alliance to a player we are attacking */
	if((state != stNone) and (enemy == temp))
	{
		return;
	}

	doOfferAlliance(temp);
}

function void doOfferAlliance(int _alliancePlayer)
{
	allyOfferTime[_alliancePlayer] = maxAllyOfferTime;

	msg("ally?" , me, _alliancePlayer);
}

function int bestAlliancePlayer()
{
	//return	- closest enemy index
	retInt = none;

	_temp3 = 99999;
	_temp = 0;
	_temp4 = 0;
	while(_temp < multiPlayerMaxPlayers)
	{
		if(knowBase[_temp] and (not dead[_temp]) and (not allianceExistsBetween(me, _temp)) and (_temp != me))
		{
			if(allyOfferTime[_temp] <= 0)
			{
				if(not((state != stNone) and (enemy == _temp)))		//attacking him?
				{
					intOK[_temp4] = _temp;	//store this one
					_temp4 = _temp4 + 1;	//how many available

					_temp2 = distBetweenTwoPoints(baseX, baseY, curBase[_temp][0], curBase[_temp][1]);
					if(_temp2 < _temp3)
					{
						_temp3 = _temp2;
						retInt = _temp;		//remember closest
					}
				}
			}
		}

		_temp = _temp + 1;
	}

	if((_temp4 > 0) and (random(4) <= 1))	//found at least 1 and 50%
	{
		retInt = intOK[random(_temp4)];		//choose one of the available
	}


	return(retInt);		//return closest or random available
}

event allianceOffered(inactive)
{
	if(temp2 != me){exit;}	//offered not to me

	//if(DEBUG_MSG and (not isHumanPlayer(temp))){exit;}	//don't ally with AIs for now

	if(not canAlly(temp))		//shouldn't ally
	{
		exit;
	}

	doAlly(temp);
}

event droidSeen(inactive)
{
	//droid	- that was seen
	//obj	- who saw

	if(droid == NULLOBJECT)
	{
		exit;
	}

	if(not isVtol(droid))
	{
		exit;
	}

	if(not hasVTOLs[droid.player])
	{
		hasVTOLs[droid.player] = TRUE;

		dbg(getPlayerName(droid.player) & " got VTOLs", me);

		/* notify allies about enemy using VTOLs */
		if(not allianceExistsBetween(me, droid.player))
		{
			notifyPlayerHasVTOLs(droid.player);
		}
	}
}

event objectSeen(inactive)
{
	//obj	- what was seen
	//obj2	- who saw

	if((obj == NULLOBJECT) or (obj2 == NULLOBJECT))
	{
		exit;
	}

	if((obj.player > 7) or (obj2.player > 7))	//skip scavengers
	{
		exit;
	}

	/* ignore walls and defenses */
	if(obj.type == OBJ_STRUCTURE)
	{
		_structure = objToStructure(obj);

		temp = getStructureType(_structure);
		if((_temp == 7) or (_temp == 8) or (_temp == 6) or (_temp == 6))	//wall, cornerwall, defense, rearm
		{
			exit;
		}
	}

	if(dead[obj.player])	//if we thought he was dead
	{
		rememberPlayerIsAlive(obj.player);

		//dbg("saw player " & obj.player & "'s object at " & (obj.x / 128) & " - " & (obj.y / 128), me);
		notifyPlayerAlive(obj.player);
	}
}

function void rememberPlayerIsAlive(int _alivePlayer)
{
	if(gameTime < 200){return;}	//engine bugs at startup

	dbg(getPlayerName(_alivePlayer) & " IS ALIVE!!!!!!!!!+++++++++++", me);

	dead[_alivePlayer] = FALSE;
	killedBase[_alivePlayer] = FALSE;
}

function void doAlly(int _playerOffered)
{
	createAlliance(_playerOffered, me);

	ally[_playerOffered] = TRUE;
	allyOfferTime[_playerOffered] = 0;	//reset, when disally, can immediately offer alliance again

	if((state != stNone) and (enemy == _playerOffered))
	{
		stopState();	//stop if were attacking him
	}

	/* Request help if in danger */
	if(state != stNone)
	{
		notifyStatus(_playerOffered);
	}
}

function void buildAA()
{
	best = findBestAA();
	if(best == none){return;}

	range = (7 * 128);	//too many on spot range

	temp = 0;
	while(temp < multiPlayerMaxPlayers)
	{
		if(not allianceExistsBetween(me, temp))
		{
				if(knowBase[temp] and (not dead[temp]) and hasVTOLs[temp])	//found his base and saw him using VTOLs
				{
					/* project enemy base to base perimeter */
					x = curBase[temp][0];	y = curBase[temp][1];
					circlePerimPoint(baseX, baseY, ref x, ref y, aaRange);

					/* make sure not too many AA defenses at that spot already */
					if(numAAinRange(me, me, x, y, range) < 5)
					{
						buildX = x;	buildY = y;
						/* make sure we can build and won't be built too far away from orig loc */
						if(not pickStructLocation(AA[best], ref buildX, ref buildY, me))
						{
							return;
						}

						if(distBetweenTwoPoints(buildX, buildY, x, y) > range)	//build loc moved too far away
						{
							return;	//original site was probably blocked, don't build too far away from orig site
						}

						/* it worked, build AA */
						buildOnMap(AA[best], buildX, buildY);
					}
				}
		}
		temp = temp + 1;
	}
}

function int findBestAA()
{
	//return	- defense index

	/* find best defense */
	_temp2 = none;
	_temp = 0;
	while(_temp < numAA)
	{
		if(isStructureAvailable(AA[_temp],me))
		{
			_temp2 = _temp;		//Best defense
		}
		_temp = _temp + 1;
	}

	return(_temp2);
}

event consoleEv(consoleTr)
{

	//turn on 'autogame'
	if(cstr == "autogame on" && (msgPlayer2 == me))
	{
		if(debugModeEnabled())
		{
			if(myResponsibility(me))
			{
				if(not bRunning)		//make sure current machine is responsible for this AI and it's not already active
				{
					console(getPlayerName(me) & " activated");
					mainInitialize();
				}
				else
				{
					console(getPlayerName(me) & " is already running");
				}
			}
			else
			{
				console(selectedPlayer & " is not responsible for " & me);
			}
		}
		else
		{
			console("debug mode failed");
		}
	}
	else
	{
		console("string failed");
	}

	//turn off 'autogames'
	if(cstr == "autogame off" && debugModeEnabled()  && (msgPlayer2 == me))
	{
		if(bRunning)		//make sure this AI is active
		{
			shutDown();
		}
	}

	if(not DEBUG_MSG){exit;}
	if(msgPlayer2 != me){exit;}

	if(strcmp(cstr, "/baserange"))
	{
		dbg("baseRange: " & (baseRange / 128), me);
	}
	else if(strcmp(cstr, "/request help"))
	{
		requestHelp();
	}
	else if(strcmp(cstr, "/defendcoord"))
	{
		dbg("x: " & (defendGr.x / 128) & " y: " & (defendGr.y / 128), me);
	}
	else if(strcmp(cstr, "/state"))
	{
		dbg("state: " & state, me);
	}
	else if(strcmp(cstr, "/phase"))
	{
		dbg("phase: " & phase, me);
	}
	else if(strcmp(cstr, "/stop"))
	{
		stopState();
	}
	else if(strcmp(cstr, "/cancel"))
	{
		cancelState();
	}
	else if(strcmp(cstr, "/numtrucks"))
	{
		_temp2 = numTemplatesInProduction(truck,me);
		_temp = buildGr.members;
		dbg("Trucks: " & _temp & "/" & _temp2, me);
	}
	else if(strcmp(cstr, "/see enemy?"))
	{
		if(enemy >= 0)
			dbg("seeBase[" & enemy & "] = " & seeBase[enemy], me);

		if(enemy == none)
			dbg("no enemy", me);
	}
	else if(strcmp(cstr, "/addallylassat"))
	{
		_temp = 0;
		while(_temp < 8)
		{
			if(allianceExistsBetween(_temp ,me) and me != _temp)
			{
				x = curBase[_temp][0];
				y = curBase[_temp][0];
				if(pickStructLocation(lasSat, ref x, ref y, _temp))
				{
					addStructure( lasSat, _temp, x, y);
				}
			}
			_temp = _temp + 1;
		}
	}
	else if(strcmp(cstr, "/addlassat"))
	{
		x = baseX;
		y = baseY;
		if(pickStructLocation(lasSat, ref x, ref y, me))
		{
			addStructure(lasSat, me, x, y);
			lasSatState[me] = lsRecharging;
		}
	}
	else if(strcmp(cstr, "/numfacs"))
	{
		temp = getNumStructures(fac,me);
		dbg("num facs: " & temp, me);
	}
	else if(strcmp(cstr, "/numtransp"))
	{
		dbg("numTransporters: " & numTransporters, me);
	}
	else if(strcmp(cstr, "/transpstatus"))
	{
		_temp = transporterCapacity(transporter[0]);
		dbg("action: " & transporter[0].action & ", order: " & transporter[0].order & ", capacity :" & _temp, me);
	}
/*
	else if(strcmp(cstr, "/numres"))
	{
		_temp = numResearchLeft(me, resUnitTransporter);
		dbg("num res until transport: " & _temp, me);
	}
*/
	else if(strcmp(cstr, "/numrepprod"))
	{
		_temp = numRepairersInProduction();
		dbg("repair units in production: " & _temp, me);
	}

	else if(strcmp(cstr, "/allystates"))
	{

		dbg("0: " & allyState[0], me);
		dbg("1: " & allyState[1], me);
		dbg("2: " & allyState[2], me);

		dbg("0: " & allyPhase[0], me);
		dbg("1: " & allyPhase[1], me);
		dbg("2: " & allyPhase[2], me);

		dbg("0: " & allyEnemy[0], me);
		dbg("1: " & allyEnemy[1], me);
		dbg("2: " & allyEnemy[2], me);
	}

	else if(strcmp(cstr, "/alert?"))
	{
		if(alert)
		{
			dbg("yes, alert", me);
		}
		else
		{
			dbg("no, no alert", me);
		}
	}
	else if(strcmp(cstr, "/takeoil"))
	{
		dbg("numTakeOil: " & numTakeOil & ", countTakeOil: " & countTakeOil, me);
	}
	else if(strcmp(cstr, "/sendForce"))
	{
		dbg("sendForceX: " & sendForceX / 128 & ", sendForceY: " & sendForceX / 128, me);
	}
	else if(strcmp(cstr, "/addpower"))
	{
		addPower(3000, me);
	}
	else if(strcmp(cstr, "/temp"))
	{
		count = 0;
		while(count <= 7)
		{
			//count2 = checkPlayerDead(count);
			dbg(getPlayerName(count) & " is dead = " & checkPlayerDead(count), me);
			count = count + 1;
		}
	}
	else if(strcmp(cstr, "/temp2"))	//4
	{
		count = 0;
		while(count <= 7)
		{
			dbg("knowBase " & getPlayerName(count) & " is = " & knowBase[count], me);
			count = count + 1;
		}
	}
	else if(strcmp(cstr, "/temp3"))	//0
	{
		count = 0;
		while(count <= 7)
		{
			dbg("seeBase " & getPlayerName(count) & " is = " & seeBase[count], me);
			count = count + 1;
		}
	}
	else if(strcmp(cstr, "/temp4"))	//-7
	{
		count = 0;
		while(count <= 7)
		{
			if(mapRevealedInRange(curBase[count][0],curBase[count][1], (2 * 128), me))
			{
				dbg("base revealed for " & count, me);
			}
			else
			{
				dbg("base not revealed for " & count, me);
			}
			count = count + 1;
		}
	}
	else if(strcmp(cstr, "/temp5"))
	{
		count = 0;
		while(count <= 7)
		{
			//count2 = canSeePlayer(count);		//can see any other objects?

			if(not canSeePlayer(count))
			{
				dbg("can't see " & getPlayerName(count), me);
			}
			else
			{
				dbg("can see " & getPlayerName(count), me);
			}
			count = count + 1;
		}
	}
	else if(strcmp(cstr, "/temp6"))	//0
	{
		count = 0;
		while(count <= 7)
		{
			dbg("dead " & count & " is = " & dead[count], me);
			count = count + 1;
		}
	}
	else if(strcmp(cstr, "/temp7"))	//0
	{
		count = 0;
		while(count <= 7)
		{
			if(allianceExistsBetween(count ,me))
			{
				MsgBox("dropBeacon for " & count);
				dropBeacon("help", count, me, baseX, baseY,0);
			}
			count = count + 1;
		}

	}
	else if(strcmp(cstr, "/fast"))
	{
		//maxTrucks = 4;
		//minTrucks = 2;

		numDefenders = 2;
		minAttackers = 3;
		numAttackers = 3;

		minSendUnits = 7;

		maxScouts = 1;

		numScouts = 1;

		dbg("FAST ATTACK MODE ON", me);
	}
	else if(strcmp(cstr, "/range on"))
	{
		showRangeAtPos(baseX, baseY, baseRange + defendCorridor);
	}
	else if(strcmp(cstr, "/range off"))
	{
		showRangeAtPos(baseX, baseY, -1);
	}
	else if(strcmp(cstr, "/msg on"))
	{
		dbgMsgOn(me, TRUE);
		console("turned on debug messages");
	}
	else if(strcmp(cstr, "/msg off"))
	{
		console("turned off debug messages");
		dbgMsgOn(me, FALSE);
	}
	else
	{
			/************************/
			/*	 offer 		*/
			/************************/
		temp2 = 0;
		while(temp2 < 8)
		{
			if(strcmp(cstr, "/offer " & temp2))
			{
				if(temp2 != me)
				{
					doOfferAlliance(temp2);
				}
				else
				{
					dbg("can't ally myself", me);
				}

				exit;
			}
			temp2 = temp2 + 1;
		}
	}

}

event beaconEv(inactive)
{
	local	int _players;
	local	string _processedString;

	if(msgPlayer >= 8)
	{
		MsgBox("beaconTr - msgPlayer >= 8");
		exit;
	}

	/* Get target players */
	_processedString = cstr;
	//_players = getTargetPlayers(ref _processedString);

	//dbg("beaconEv()!!!! = " & cstr & ", from " & msgPlayer, me);

	beaconX[msgPlayer] = x;
	beaconY[msgPlayer] = y;
	tBeacon[msgPlayer] = gameTime / 10;	//remember when got this msg, so can make it timeout

	processCommand(cstr, msgPlayer, TRUE);
	//dbg("beaconEv()!!!! END = " & cstr & ", from " & msgPlayer, me);
}

event multiMsgEv(inactive)
{
	local	int _players;
	local	string _processedString;
	if(msgPlayer == me)
		exit;

	/* Get target players */
	_processedString = cstr;
//	_players = getTargetPlayers(ref _processedString);

	dbg(" " & me & " multiMsgEv() = " & cstr & ", from " & msgPlayer, me);

	//dbg("multiMsgEv() = " & cstr & ", from " & msgPlayer, me);

	/* See if sender was referring to us */
	processCommand(cstr, msgPlayer, FALSE);


	//dbg("processDebugCommand() start = " & cstr & ", from " & msgPlayer, me);
	//process debug messages
	if(DEBUG_COMMANDS)
	{
		processDebugCommand(msgPlayer, cstr);
	}
	//dbg("multiMsgEv() END = " & cstr & ", from " & msgPlayer, me);
}

function void processDebugCommand(int _msgPlayer, STRING _cstr)
{
	if(strcmp(_cstr, "stop"))
	{
		stopState();
	}
	else if(strcmp(cstr, "see enemy?"))
	{
		if(enemy >= 0)
			dbg("seeBase[" & enemy & "] = " & seeBase[enemy], me);

		if(enemy == none)
			dbg("no enemy", me);
	}
	else if(strcmp(_cstr, "status?"))
	{
		if(alert){msg("alert = TRUE" , me, _msgPlayer);}	//alert
		else{msg("alert = FALSE" , me, _msgPlayer);}

		if(lowMilitary){msg("lowMilitary = TRUE" , me, _msgPlayer);}	//lowMilitary
		else{msg("lowMilitary = FALSE" , me, _msgPlayer);}

		msg("power = " & playerPower(me) , me, _msgPlayer);	//power
		msg("state: " & state, me, _msgPlayer);
		msg("phase: " & phase, me, _msgPlayer);
		msg("numres: " & numBusyByType(resFac), me, _msgPlayer);
	}
	else if(strcmp(cstr, "range on"))
	{
		showRangeAtPos(baseX, baseY, baseRange + defendCorridor);
	}
	else if(strcmp(cstr, "range off"))
	{
		showRangeAtPos(baseX, baseY, -1);
	}
	else if(strcmp(cstr, "msg on"))
	{
		dbgMsgOn(me, TRUE);
	}
	else if(strcmp(cstr, "msg off"))
	{
		dbgMsgOn(me, FALSE);
	}
	else if(strcmp(_cstr, "num res?"))
	{
		msg("num res=" & numBusyByType(resFac), me, _msgPlayer);
	}
	else if(strcmp(cstr, "fast"))
	{
		numDefenders = 2;
		minAttackers = 3;
		numAttackers = 3;

		minSendUnits = 7;

		maxScouts = 1;

		numScouts = 1;

		dbg("FAST ATTACK MODE ON", me);
	}
	else if(strcmp(cstr, "numres"))
	{
		temp = numBusyByType(resFac);
		dbg("numres: " & temp, me);
	}
}

//function void processCommand(int _msgPlayer, STRING _cstr, bool _bBlipMessage, string _processedString, int _targetPlayers)
function void processCommand(string _message, int _sender, bool _bBlipMessage)
{
	local	int 		_numMsgs,_curMsg,_addressedPlayers,_x,_y,_player;
	local	string		_msg,_processedString;

	//dbg("processCommand(" & _message & ", " & _sender & ")", me);

	if(dead[_sender] and (multiPlayerAlliancesType != ALLIANCES_TEAMS)){	//if we thought he was dead and teams are off
		rememberPlayerIsAlive(_sender);
	}

	/* Extract semantic information */
	_curMsg = 0;
	_numMsgs = processChatMsg(_message);

	debug(me & ") processCommand: '" & _message & "' from " & _sender);
	dbg("processCommand: '" & _message & "' from " & _sender, me);
	dbg("got " & _numMsgs & " commands", me);

	/* Process all messages */
	while(_curMsg < _numMsgs)
	{
		if(chatCmdIsPlayerAddressed(_curMsg, me))
		{
			dbg("i'm addressed", me);
			_msg = getChatCmdDescription(_curMsg);

			if(_msg == "ally me")
			{
				if(alliancesLocked())
				{
					return;
				}

				if(allianceExistsBetween(_sender ,me) and (random(2) == 1))
				{
					msg("already allied" , me, _sender);
				}

				if(not canAlly(_sender))		//shouldn't ally
				{
					if(random(2) == 1){msg("no" , me, _sender);}
					return;
				}

				msg("ok" , me, _sender);

				doAlly(_sender);
			}

			/* ally mesages only */
			if(not allianceExistsBetween(me , _sender))
				return;

			if(_msg == "go?")
			{
				allyState[_sender] = stNone;
				allyPhase[_sender] = phNone;
				allyEnemy[_sender] = none;

				/* tell him we are busy */
				if(not checkFollowAttackRequest(_sender, TRUE))
				{
					return;
				}

				/* tell him we are ready */
				msg("where" , me, _sender);
			}
			if(_msg == "go center")
			{
				/* tell him we are busy */
				if(not checkFollowAttackRequest(_sender, TRUE))
					return;

				/* cancel current state since not doing anything important */
				if(state != stNone)
					cancelState();

				joinForces(_sender, mapWidth*64,  mapHeight*64);		//to center

				return;
			}
			else if(_msg == "status?")
			{
				if(state == stNone)
				{
					msg("pumping units" , me, _sender);
				}
				else
				{
					notifyStatus(_sender);
				}
			}
			else if(_msg == "pumping units")
			{
				allyState[_sender] = stNone;
				allyPhase[_sender] = phNone;
				allyEnemy[_sender] = none;
			}
			else if(_msg == "stop")
			{
				if((state != stNone) and (enemy == _sender))
				{
					msg("ok" , me, _sender);
					stopState();
				}
			}
			else if(_msg == "got power?")
			{
				notifyPower(_sender);
			}
			//else if(strcmp(_msg, "cya"))	//player has lost
			//{
			//	if(allianceExistsBetween(me , _sender))
			//	{
			//		dead[_sender] = TRUE;
			//
			//		allyState[_sender] = stNone;
			//		allyPhase[_sender] = phNone;
			//		allyEnemy[_sender] = none;
			//	}
			//}
			else if(_msg == "go!")
			{
				/* tell him we are busy */
				if(not checkFollowAttackRequest(_sender, TRUE))
					return;

				/* cancel current state since not doing anything important */
				if(state != stNone)
					cancelState();

				/* know location? */
				if(not haveBeacon(_sender))
				{
					if(random(5) == 0)
					{
						msg("I can't read your thoughts", me, _sender);
					}
					msg("drop a beacon", me, _sender);
					return;
				}

				joinForces(_sender, beaconX[_sender], beaconY[_sender]);		//not to center
				return;
			}

			else if(_msg == "help me")
			{
				allyState[_sender] = stDefending;	//remember he's in trouble
				allyEnemy[_sender] = none;
				allyPhase[_sender] = phNone;

				if(_bBlipMessage)	//processing message from blip
				{
					curHelpX[_sender] = x;
					curHelpY[_sender] = y;
				}

				/* got beacon msg and are already doing this command => just correct the coords */
				if(isCurrentOrder(stHelpingAlly, _sender))
				{
					if(_bBlipMessage)	//processing message from blip
					{
						updateStateCoord(beaconX[_sender], beaconY[_sender]);
						helpTime = maxHelpTime;		//reset help timeout timer

						if(random(2)==0)
						{
							msg("roger", me, _sender);
						}
						return;
					}
					else	/* if a message, not a blip */
					{
						helpTime = maxHelpTime;		//reset help timeout timer
						msg("I am!", me, _sender);
						return;
					}
				}

				if(state == stHelpingAlly)		/* busy with something else */
				{
					//msg("defending player " & enemy & " already", me, _sender);
					notifyStatus(_sender);
					return;
				}

				if(state == stDefending)
				{
					//msg("there're after me too, you better help me", me, _sender);	//TODO: temporal solution
					//msg("there're after me too", me, _sender);
					return;
				}

				temp = totalDroids();
				if(temp < minAllyHelpers)
				{
					msg("have nothing", me, _sender);
					return;
				}

				if(curHelpX[_sender] <= 0)
				{
					msg("give vision", me, _sender);
					return;
				}

				if(state != stNone)
				{
					pauseState();		//resume when done helping
				}

				msg("coming, hold on", me, _sender);

				startHelpAlly(_sender, curHelpX[_sender], curHelpY[_sender]);
			}
			else if(_msg == "i'm ok")
			{
				allyState[_sender] = stNone;
				allyPhase[_sender] = phNone;
				allyEnemy[_sender] = none;

				if((state == stHelpingAlly) and (enemy == _sender))
				{
					msg("roger", me, _sender);
					stopAllyDefense();
				}

				/* remind allies we are in trouble */
				if(state == stDefending)
					requestHelp();
			}
			else if(_msg == "give vision")
			{
				giftRadar(me, _sender, FALSE);
			}
			else if(_msg == "can't see him")		//a reply after "go x"
			{
				//if(state == stAttacking)
				//{
				//	msg("go", me, _sender);		//just follow my units
				//}

				//todo: del
				//MsgBox("test");

				giftRadar(me, _sender, FALSE);
			}
			else if(_msg == "let's lassat someone")
			{
				lasSatState[_sender] = lsWaitingReply;

				if(lasSatState[me] == lsReady)
				{
					msg("ok", me, _sender);
					dbg("have a lassat requester********", me);
					lasSatState[me] = lsWaitingForRequester;	//join the strike
				}
				else if(lasSatState[me] == lsRecharging)	//tell him to wait, if we are almost finished recharging
				{
					if((tLasSatReady - tLasSat) < tLasSatWaitAlliesMax)	//not much left
					{
						lasSatState[me] = lsRequesterWaitingRecharging;
						msg("wait, lassat almost ready", me, _sender);
					}
				}
			}
			else if(_msg == "wait, lassat almost ready")
			{
				dbg("LASSAT: " & getPlayerName(_sender) & "has joined us********", me);
				lasSatState[_sender] = lsRequesterWaitingRecharging;	//remember ally is almost done recharging

			}
			else if(_msg == "lassat ready")
			{
				dbg("LASSAT: " & getPlayerName(_sender) & " waites for us********", me);
				lasSatState[_sender] = lsWaitingForRequester;	//remember ally is waiting for the requester to start lassat strike
			}
			else
			{
					/************************/
					/*	 ally 		*/
					/************************/
				if(DEBUG_MSG)
				{
					temp2 = 0;
					while(temp2 < 8)
					{
						if(_msg == "ally " & temp2 & "!")
						{
							if(temp2 != me)
							{
								doAlly(temp2);
							}
							else
							{
								dbg("can't ally myself", me);
							}

							return;
						}
						temp2 = temp2 + 1;
					}
				}

					/*************************/
					/*        go player         */
					/*************************/

				//if(match(_processedString,"go <player>", ref _player))
				if((_msg == "attack player") and (getNumArgsInCmd(_curMsg) == 1))
				{
					//get player index
					if(getChatCmdParam(ref _player, _curMsg, 0))
					{
						dbg("*************go " & _player, me);

						if((_player == me) or (ally[_player]))
						{
							msg(getPlayerName(_player) & "???", me, _sender);
							return;
						}

						if(dead[_player])
						{
							msg(getPlayerName(_player) & " is dead", me, _sender);
							return;
						}

						/* got beacon msg and are already doing this command => just correct the coords */
						if(isCurrentOrder(stAttacking, _player))
						{
							if(_bBlipMessage)	/* processing beacon msg */
							{
								updateStateCoord(beaconX[_sender], beaconY[_sender]);
								if(random(2)==0)
								{
									msg("roger", me, _sender);
								}
								return;
							}
							else	/* if a normal msg, and we are already doind it, say so, since the destination can only be tweaked with a beacon */
							{
								msg("I am", me, _sender);
								return;
							}
						}		/* we are doing something else already */
						else if(not checkFollowAttackRequest(_sender, TRUE))
						{
							return;
						}

						/* know location? */
						if(haveBeacon(_sender))
						{
							_x = beaconX[_sender];
							_y = beaconY[_sender];
						}
						else	/* no beacon provided, use the current enemy location */
						{
							if(killedBase[_player] and (not seeBase[_player]))	/* we have no idea where the enemy has rebuilt the base */
							{
								msg("drop a beacon", me, _sender);
								return;
							}
							else if(curBase[_sender][0] > 0)	/* remember or can directly see it */
							{
								_x = curBase[_sender][0];
								_y = curBase[_sender][1];
							}
							else
							{
								msg("drop a beacon", me, _sender);
								return;
							}
						}

						/* cancel current state since not doing anything important */
						if(state != stNone)
						{
							cancelState();
						}

						if(killedBase[_player])
						{
							msg("ok, but haven't we destroyed " & getPlayerName(_player) & "'s base already?", me, _sender);
						}
						else
						{
							msg("ok" , me, _sender);
						}

						allyState[_sender] = stAttacking;
						allyEnemy[_sender] = _player;
						allyPhase[_sender] = phMoveToBase;	//or phAttackingBase

						offeredEnemy = _player;	//remember the offer

						startAttack(_player, _x, _y);
						notifyAllies("going " & getPlayerName(_player), TRUE);
						return;
					}
				}

					/*************************/
					/* 	going player	 */
					/*************************/

				//if(match(_processedString,"going <player>", ref _player))
				if((_msg == "attacking player?") and (getNumArgsInCmd(_curMsg) == 1))
				{
					//get player index
					if(getChatCmdParam(ref _player, _curMsg, 0))
					{
						dbg("*************going " & _player, me);

						allyState[_sender] = stAttacking;
						allyEnemy[_sender] = _player;
						allyPhase[_sender] = phMoveToBase;	//or phAttackingBase

						if(_player == me)
						{
							msg("you bastard!", me, _sender);
							breakAlliance(me, _sender);
							return;
						}

						if(ally[_player]){return;}		//just exit quietly

						if(dead[_player])
						{
							msg("isn't " & getPlayerName(_player) & " dead already", me, _sender);
							return;
						}

						/* ignore if busy */
						if((state != stNone) and (enemy != _sender) and (phase != phGuardingPos))	//not idle and not dealing with this player somehow (defending etc) or psGuardingPos (is low prior)
						{
							return;			//just exit
						}

						/* also ignore if we are already attacking the SAME enemy, or "gonna take enemy derrick" msg is not gonna work properly */
						if(enemy == _player)
						{
							return;
						}

						if(not haveTheoretilcallyMinAttackers(TRUE))
						{
							return;		//ignore
						}

						/* know location? */
						if(haveBeacon(_sender))
						{
							_x = beaconX[_sender];
							_y = beaconY[_sender];
						}
						else	/* no beacon provided, use the current enemy location */
						{
							if(killedBase[_player] and (not seeBase[_player]))	/* we have no idea where the enemy has rebuilt the base */
							{
								msg("drop a beacon", me, _sender);
								return;
							}
							else if(curBase[_sender][0] > 0)	/* remember or can directly see it */
							{
								_x = curBase[_sender][0];
								_y = curBase[_sender][1];
							}
						}

						if(state != stNone)	//stop if dealing with the one who messaged
						{
							cancelState();
						}

						//enemy = _player;
						startAttack(_player, _x, _y);
						notifyAllies("going " & getPlayerName(_player), TRUE);
						return;
					}
				}

					/*****************************/
					/* 	x got VTOLs 	 */
					/*****************************/
				//if(match(_msg,"<player> got vtols", ref _player))
				if((_msg == "player has vtols") and (getNumArgsInCmd(_curMsg) == 1))
				{
					//get player index
					if(getChatCmdParam(ref _player, _curMsg, 0))
					{
						dbg("*************" & getPlayerName(_player) & " got vtols", me);

						if(random(2) == 0)
						{
							if(hasVTOLs[_player])
							{
								msg("I know", me, _sender);
							}
							else
							{
								msg("ok", me, _sender);
							}
						}

						hasVTOLs[_player] = TRUE;
						return;
					}
				}

					/*************************/
					/* 	take enemy oil x 	 */
					/*************************/

				//if(match(_processedString,"gonna get <player>'s derrick", ref _player))
				if((_msg == "getting player oil") and (getNumArgsInCmd(_curMsg) == 1))
				{
					//get player index
					if(getChatCmdParam(ref _player, _curMsg, 0))
					{
						dbg("*************gonna get " & getPlayerName(_player) & "'s derrick", me);

						allyState[_sender] = stTakingOil;
						allyEnemy[_sender] = _player;
						allyPhase[_sender] = phMoveToBase;	//or phAttackingBase

						if(_player == me)
						{
							msg("you bastard!", me, _sender);
							breakAlliance(me, _sender);
							return;
						}

						if(ally[_player])
							return;		//just exit quietly

						/* ignore if already attacking this enemy somehow */
						if(enemy == _player)
							return;

						if(dead[_player])
						{
							msg("isn't " & getPlayerName(_player) & " dead already", me, _sender);
							return;
						}

						/* ignore if busy */
						if((state != stNone) and (enemy != _sender) and (phase != phGuardingPos))	//not idle and not dealing with this player somehow (defending etc) or psGuardingPos (is low prior)
						{
							return;			//just exit
						}


						/* do we want to attack enemy's oil? */
						if(random(10) <= 6)
						{
							/* do we have enough units to start start attacking enemy derrick alone? */
							if(haveTheoretilcallyMinAttackers(TRUE))	/* don't need too many for the derrick, hence "TRUE" */
							{
								/* find a derrick */
								structure = findEnemyDerrick(_player);	/* find enemy derrick to attack */
								if(structure != NULLOBJECT)
								{
									/* don't go on if we know where ally is attacking oil and this oil is too close to the derrick we have choosen to attack */
									if(not (haveBeacon(_sender) and distBetweenTwoPoints(beaconX[_sender], beaconY[_sender], structure.x, structure.y) < (25 * 128)))
									{
										cancelState();		//stop if doing anything unimportant

										startTakeOil(structure);
										notifyTakeOil(structure.player, structure.x, structure.y);
										return;
									}
								}
							}
						}

						/* didn't start attacking derrick, decide if we want (and can) to attack the base directly */
						if(knowBase[_player] and haveTheoretilcallyMinAttackers(FALSE))
						{
							cancelState();	/* stop if doing anything unimportant */
							startAttack(_player, curBase[_player][0], curBase[_player][1]);
							dropAllyBeacon("going " & getPlayerName(_player), curBase[_player][0], curBase[_player][1]);
							notifyAllies("going " & getPlayerName(_player), TRUE);
							return;
						}

						return;
					}
				}


					/*************************/
					/* 	lassat player x 	 */
					/*************************/

				//if(match(_processedString,"lassat <player>", ref _player))
				if((_msg == "lassat player") and (getNumArgsInCmd(_curMsg) == 1))
				{
					//get player index
					if(getChatCmdParam(ref _player, _curMsg, 0))
					{
						dbg("*******lassat " & _player, me);

						/* remember he just lassatted */
						lasSatState[_sender] = lsRecharging;
						lasSatEnemy = _player;

						/* if we were waiting for him to start the attack, start delayed attack */
						if(lasSatState[me] == lsWaitingForRequester)
						{
							lasSatState[me] = lsDelayedFiring;
							tLasSatCountdown = 1 + (me * 9) + random(2);		//every ally (except for requester) fires with delay of at least 1 sec to be more effective (to finish damaged structures) (lassat delay == 8-9 sec)
						}
						return;
					}
				}

			}
			//else
			//{
			//	dbg("unknown message", me);
			//}
		}
		else
		{
			dbg("i'm not addressed", me);
		}
		_curMsg++;
	}

	//dbg("processCommand(" & _message & ", " & _sender & ") END------", me);
}

event	keyPressed(CALL_KEY_PRESSED, ref temp, ref temp2)
{
	//console("Key pressed: " & temp & ", meta key: " & temp2);
	if(DEBUG_MSG)
	{
		if (temp != KEY_ESC)
		{
			if(temp == KEY_SPACE)		//space
			{
				toggleDebugMenu();
			}
			else if(temp == KEY_A and temp2 == KEY_RCTRL)
			{
				console("temp == KEY_A and temp2 == KEY_RCTRL");
			}
			else if(temp == KEY_A)
			{
				console("temp == KEY_A");
			}

		}
	}
}

function void toggleDebugMenu()
{
	debugMenuUp = not debugMenuUp;
	debugMenu(debugMenuUp);
}

