name: Windows

on:
  push:
    branches-ignore:
      - 'l10n_**' # Push events to translation service branches (that begin with "l10n_")
  pull_request:
    # Match all pull requests...
    paths-ignore:
      # Except some text-only files / documentation
      - 'ChangeLog'
      # Except those that only include changes to stats
      - 'data/base/stats/**'
      - 'data/mp/stats/**'
      - 'data/mp/multiplay/script/functions/camTechEnabler.js'
      # Linux-specific example scripts
      - 'doc/hosting/linux_scripts/**'
  # Support running after "Draft Tag Release" workflow completes, as part of automated release process
  workflow_run:
    workflows: ["Draft Tag Release"]
    push:
      tags:
        - '*'
    types:
      - completed

env:
  # Controls whether release builds are signed
  WZ_CI_SIGN_RELEASE_BUILDS: true

jobs:
  windows-build:
    strategy:
      matrix:
        include:
          - compiler: "MSVC_2022"
            architecture: "x86"
            artifact_description: "msvc_x86"
            deploy_release: false
            support_sentry: true
          - compiler: "MSVC_2022"
            architecture: "x64"
            artifact_description: "msvc_x64"
            deploy_release: false
            support_sentry: true
          # - compiler: "MSVC_2022"
          #   architecture: "arm64"
          #   artifact_description: "msvc_arm64"
          #   deploy_release: false
          - compiler: "LLVM_MINGW"
            architecture: "x86"
            deploy_release: true
            support_sentry: true
            sentry_backend: breakpad
          - compiler: "LLVM_MINGW"
            architecture: "x64"
            deploy_release: true
            support_sentry: true
            sentry_backend: crashpad
          - compiler: "LLVM_MINGW"
            architecture: "arm64"
            deploy_release: true
            support_sentry: true
            sentry_backend: crashpad
      fail-fast: false
    env:
      WZ_COMPILER_VER: ${{ matrix.compiler }}
      WZ_TARGET_ARCH: ${{ matrix.architecture }}
      VSCMD_SKIP_SENDTELEMETRY: 1
      # MSVC parallel builds: https://devblogs.microsoft.com/cppblog/improved-parallelism-in-msbuild/
      UseMultiToolTask: true
      EnforceProcessCountAcrossBuilds: true
    name: '${{ matrix.architecture }} [${{ matrix.compiler }}]'
    permissions:
      contents: write # Needed to upload to releases
      # needed to generate artifact attestations, see: https://docs.github.com/en/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds
      id-token: write
      attestations: write
    runs-on: windows-2022
    if: "!contains(github.event.head_commit.message, '[ci skip]')"
    outputs:
      # Needed by the release job - despite this being a matrix job, this should be the same for all, so we can allow whatever is last to persist it
      WZ_GITHUB_REF: ${{ steps.checkout-config.outputs.WZ_GITHUB_REF }}
    steps:
    - uses: actions/checkout@v6
      with:
        fetch-depth: 0
        path: 'src'
    - name: Configure Repo Checkout
      id: checkout-config
      working-directory: '${{ github.workspace }}\src'
      shell: bash
      env:
        WORKFLOW_RUN_CONCLUSION: ${{ github.event.workflow_run.conclusion }}
        WORKFLOW_RUN_HEAD_SHA: ${{ github.event.workflow_run.head_sha }}
      run: |
        . .ci/githubactions/checkout_config.sh
    - name: Prepare Git Repo for autorevision
      working-directory: '${{ github.workspace }}\src'
      run: cmake -P .ci/githubactions/prepare_git_repo.cmake
    - name: Init Git Submodules
      working-directory: '${{ github.workspace }}\src'
      run: git submodule update --init --recursive
    # Workaround for https://github.com/actions/runner-images/issues/8598:
    - name: Remove Strawberry Perl from PATH
      run: |
        $env:PATH = $env:PATH -replace "C:\\Strawberry\\c\\bin;", ""
        "PATH=$env:PATH" | Out-File -FilePath $env:GITHUB_ENV -Append
    # - name: Output Runner Environment Information
    #   run: |
    #     Write-Host "------------------------------------------------------"
    #     Write-Host "Environment Variables"
    #     Write-Host "------------------------------------------------------"
    #     & gci env:* | sort-object name
    - name: Install Asciidoctor
      id: asciidoctor-dl
      run: |
        echo "Installing Asciidoctor"
        gem install asciidoctor -v 2.0.23 --no-document | Out-Null
        echo "Installing Asciidoctor... finished"
        $AsciidoctorBat = (Get-Command asciidoctor.bat).Path
        echo "Asciidoctor.bat: ${AsciidoctorBat}"
        $AsciidoctorBatPath = Split-Path -Path "${AsciidoctorBat}"
        echo "Asciidoctor.bat path: ${AsciidoctorBatPath}"
        echo "ASCIIDOCTOR_PATH=${AsciidoctorBatPath}" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
    - name: Generate Settings for Run [${{ matrix.compiler }}:${{ matrix.architecture }}]
      id: settings
      env:
        BUILD_SENTRY_SUPPORT: ${{ matrix.support_sentry }}
        WZ_DEPLOY_TO_RELEASE: ${{ matrix.deploy_release }}
      run: |
        # Basic variable setup
        # --------------------

        $WZ_VC_TARGET_PLATFORMNAME = "$env:WZ_TARGET_ARCH"
        $WZ_BUILD_DESC_PREFIX = "win"
        if ("${env:WZ_DEPLOY_TO_RELEASE}" -ne "true") {
          # Builds that aren't to be deployed to a release should have a different WZ_BUILD_DESC prefix (not "win_") for easier wildcard selection later
          $WZ_BUILD_DESC_PREFIX = "ci_only"
        }
        $WZ_BUILD_DESC = "${WZ_BUILD_DESC_PREFIX}_${env:WZ_TARGET_ARCH}"
        if (-not ([string]::IsNullOrEmpty("${{ matrix.artifact_description }}")))
        {
          $WZ_BUILD_DESC = "${WZ_BUILD_DESC_PREFIX}_${{ matrix.artifact_description }}"
        }

        if ($env:WZ_COMPILER_VER -eq "LLVM_MINGW") {
          $WZ_USING_MINGW = "true"
          if ($env:WZ_TARGET_ARCH -eq "x86") {
            $VCPKG_DEFAULT_TRIPLET = "x86-mingw-dynamic"
            $WZ_MINGW_PKG_PREFIX = "i686-w64-mingw32"
            $WZ_ASM_MASM_COMPILER = "llvm-ml"
          }
          elseif ($env:WZ_TARGET_ARCH -eq "x64") {
            $VCPKG_DEFAULT_TRIPLET = "x64-mingw-dynamic"
            $WZ_MINGW_PKG_PREFIX = "x86_64-w64-mingw32"
            $WZ_ASM_MASM_COMPILER = "llvm-ml;-m64"
          }
          elseif ($env:WZ_TARGET_ARCH -eq "arm64") {
            $VCPKG_DEFAULT_TRIPLET = "arm64-mingw-dynamic"
            $WZ_MINGW_PKG_PREFIX = "aarch64-w64-mingw32"
          }
          $VCPKG_DEFAULT_HOST_TRIPLET = "x64-mingw-static"
        }
        else {
          $WZ_USING_MINGW = "false"
          if ($env:WZ_TARGET_ARCH -eq "x86") {
            $VCPKG_DEFAULT_TRIPLET = "x86-windows"
            $WZ_VC_TARGET_PLATFORMNAME = "Win32" # special case, map "x86" -> "Win32"
          }
          elseif ($env:WZ_TARGET_ARCH -eq "x64") {
            $VCPKG_DEFAULT_TRIPLET = "x64-windows"
          }
          elseif ($env:WZ_TARGET_ARCH -eq "arm64") {
            $VCPKG_DEFAULT_TRIPLET = "arm64-windows"
          }
          $VCPKG_DEFAULT_HOST_TRIPLET = "x64-windows"
        }

        $WZ_FULL_POWERSHELL_PATH = (Get-Command powershell.exe).Path
        $WZ_FULL_GIT_PATH = Split-Path -Path ((Get-Command git.exe).Path)
        echo "WZ_FULL_GIT_PATH=${WZ_FULL_GIT_PATH}"
        $WZ_FULL_CMAKE_PATH = Split-Path -Path ((Get-Command cmake.exe).Path)
        echo "WZ_FULL_CMAKE_PATH=${WZ_FULL_CMAKE_PATH}"

        # ------------------------------
        # Install Gettext tools

        $origPath = $env:PATH
        $env:PATH = "C:\msys64\mingw64\bin;C:\msys64\usr\bin;$origPath"

        pacman --noconfirm -S --needed gettext
        if ($LastExitCode -ne 0) {
            throw "Failed to install gettext with exit code: $LastExitCode"
        }

        $WZ_FULL_MSGMERGE_PATH = Split-Path -Path ((Get-Command msgmerge.exe).Path)
        echo "WZ_FULL_MSGMERGE_PATH=${WZ_FULL_MSGMERGE_PATH}"
        $WZ_FULL_MSGFMT_PATH = Split-Path -Path ((Get-Command msgfmt.exe).Path)
        echo "WZ_FULL_MSGFMT_PATH=${WZ_FULL_MSGFMT_PATH}"

        $env:PATH = $origPath

        # ------------------------------
        # MSVC version / generator info

        $WZ_VISUAL_STUDIO_INSTALL_PATH = ""
        if ($env:WZ_COMPILER_VER -eq "MSVC_2022") {
          $WZ_VC_GENERATOR = "Visual Studio 17 2022"
          #$env:WZ_VC_TOOLCHAIN = "v143"
          # Get the installation path for a specific version of MSVC (2022)
          $WZ_VISUAL_STUDIO_INSTALL_PATH = & "vswhere.exe" -latest -property installationPath -version "[17.0,18.0)"
          if ($LastExitCode -ne 0)
          {
            echo "::warning ::Could not find MSVC 2022"
            $WZ_VISUAL_STUDIO_INSTALL_PATH = ""
          }
        }

        if ([string]::IsNullOrWhitespace(${WZ_VISUAL_STUDIO_INSTALL_PATH}))
        {
          $WZ_VISUAL_STUDIO_INSTALL_PATH = & "vswhere.exe" -latest -property installationPath
          if ($env:WZ_COMPILER_VER -ne "LLVM_MINGW") {
            echo "::warning ::Default to 'latest' MSVC: `"${WZ_VISUAL_STUDIO_INSTALL_PATH}`""
          }
        }

        $WZ_VISUAL_STUDIO_INSTALL_VERSION = & "vswhere.exe" -path "${WZ_VISUAL_STUDIO_INSTALL_PATH}" -property installationVersion
        echo "WZ_VISUAL_STUDIO_INSTALL_VERSION = ${WZ_VISUAL_STUDIO_INSTALL_VERSION}"

        $VCPKG_VISUAL_STUDIO_PATH = "${WZ_VISUAL_STUDIO_INSTALL_PATH}"
        #$CMAKE_GENERATOR_INSTANCE = "${WZ_VISUAL_STUDIO_INSTALL_PATH}"

        # -------------
        # Sentry crash-handler support

        $WZ_ENABLE_SENTRY = "false"
        if ("${env:BUILD_SENTRY_SUPPORT}" -eq "true") {
          # Fully enable for master branch pushes (development builds) and workflow runs (draft tag release builds)
          if (("${env:GITHUB_EVENT_NAME}" -eq "push") -and ("${env:GITHUB_REF}" -eq "refs/heads/master")) {
            $WZ_ENABLE_SENTRY = "true"
          }
          elseif (("${env:GITHUB_EVENT_NAME}" -eq "workflow_run")) {
            $WZ_ENABLE_SENTRY = "true"
          }
        }

        # -------------
        # Distributor

        $WZ_DISTRIBUTOR = "UNKNOWN"
        if (${env:GITHUB_REPOSITORY} -eq "Warzone2100/warzone2100") {
          $WZ_DISTRIBUTOR = "wz2100.net"
        }

        # ----------------
        # Determine vcpkg binary cache directory

        $VCPKG_BINARYCACHE_DIR = "${{ github.workspace }}\vcpkg_cache"
        $VCPKG_BINARY_SOURCES = "clear;files,${VCPKG_BINARYCACHE_DIR},readwrite"

        echo "VCPKG_BINARYCACHE_DIR = ${VCPKG_BINARYCACHE_DIR}"

        # ----------------
        # Export Variables

        $WZ_REPO_PATH = "${{ github.workspace }}\src"

        # Export everything important to environment variables (for future steps)
        echo "WZ_USING_MINGW=${WZ_USING_MINGW}" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
        echo "WZ_MINGW_PKG_PREFIX=${WZ_MINGW_PKG_PREFIX}" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
        echo "WZ_ASM_MASM_COMPILER=${WZ_ASM_MASM_COMPILER}" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
        echo "WZ_FULL_POWERSHELL_PATH=${WZ_FULL_POWERSHELL_PATH}" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
        echo "WZ_FULL_GIT_PATH=${WZ_FULL_GIT_PATH}" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
        echo "WZ_FULL_CMAKE_PATH=${WZ_FULL_CMAKE_PATH}" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
        echo "WZ_FULL_MSGMERGE_PATH=${WZ_FULL_MSGMERGE_PATH}" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
        echo "WZ_FULL_MSGFMT_PATH=${WZ_FULL_MSGFMT_PATH}" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
        echo "WZ_REPO_PATH=${WZ_REPO_PATH}" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
        echo "WZ_ENABLE_SENTRY=${WZ_ENABLE_SENTRY}" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
        echo "WZ_REPO_PATH=${WZ_REPO_PATH}" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        echo "VCPKG_DEFAULT_TRIPLET=${VCPKG_DEFAULT_TRIPLET}" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        echo "VCPKG_DEFAULT_HOST_TRIPLET=${VCPKG_DEFAULT_HOST_TRIPLET}" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        echo "WZ_VC_TARGET_PLATFORMNAME=${WZ_VC_TARGET_PLATFORMNAME}" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        echo "WZ_BUILD_DESC=${WZ_BUILD_DESC}" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
        echo "WZ_BUILD_DESC=${WZ_BUILD_DESC}" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        echo "WZ_VC_GENERATOR=${WZ_VC_GENERATOR}" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        #echo "WZ_VC_TOOLCHAIN=${WZ_VC_TOOLCHAIN}" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        echo "WZ_VISUAL_STUDIO_INSTALL_PATH=${WZ_VISUAL_STUDIO_INSTALL_PATH}" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        echo "WZ_VISUAL_STUDIO_INSTALL_VERSION=${WZ_VISUAL_STUDIO_INSTALL_VERSION}" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
        echo "VCPKG_VISUAL_STUDIO_PATH=${VCPKG_VISUAL_STUDIO_PATH}" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        echo "WZ_DISTRIBUTOR=${WZ_DISTRIBUTOR}" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        echo "VCPKG_BINARYCACHE_DIR=${VCPKG_BINARYCACHE_DIR}" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
        echo "VCPKG_BINARY_SOURCES=${VCPKG_BINARY_SOURCES}" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        echo "VCPKG_BINARY_SOURCES=${VCPKG_BINARY_SOURCES}" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
    #####################################################
    - name: 'Download & Install Vulkan SDK'
      run: |
        Start-Sleep -Milliseconds 1 # See: https://stackoverflow.com/a/49859001

        $VerbosePreference = "Continue"
        . "${env:WZ_REPO_PATH}\.ci\powershell\request.ps1"

        Write-Host "Current value of env:VULKAN_SDK:${env:VULKAN_SDK}"

        $VULKAN_DL_URL = "https://sdk.lunarg.com/sdk/download/1.4.321.1/windows/vulkansdk-windows-X64-1.4.321.1.exe?Human=true"
        $VULKAN_DL_SHA256 = "baaa4f7ca11ed3d82aa1c102b21208915485bbaa473068c763daa425cca468bd"

        $VK_DL_BASEDIR = "${{ github.workspace }}\dl"
        $VK_DL_PATH = "${VK_DL_BASEDIR}\vulkan.exe"
        New-Item -ItemType Directory -Force -Path "$VK_DL_BASEDIR"

        $req = Req -Params @{ 'Method'='GET';'Uri'="$VULKAN_DL_URL";'OutFile'="${VK_DL_PATH}" } -Retries 3 -SecondsDelay 10 -ExpectedHash "${VULKAN_DL_SHA256}" -Algorithm SHA256

        Write-Host "Running Vulkan SDK installer..."
        Start-Process "${VK_DL_PATH}" -ArgumentList "--accept-licenses","--default-answer","--confirm-command","install" -Wait
        Write-Host "Vulkan SDK installer completed"

        $machineEnvironment = [Environment]::GetEnvironmentVariables("Machine")
        if (-not ($machineEnvironment.Contains("VULKAN_SDK")))
        {
          Write-Error "Failed to find updated VULKAN_SDK system environment variable"
        }
        Write-Host "New system VULKAN_SDK environment variable: $($machineEnvironment["VULKAN_SDK"])"

        # Ensure future steps pick up the new VULKAN_SDK environment variable
        echo "VULKAN_SDK=$($machineEnvironment["VULKAN_SDK"])" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
    - name: 'Check environment'
      run: |
        if ([string]::IsNullOrWhitespace(${env:VULKAN_SDK}))
        {
          Write-Error "Missing env:VULKAN_SDK in next step: ${env:VULKAN_SDK}"
        }
        else
        {
          # Verify the VULKAN_SDK path exists
          if (-not (Test-Path "${env:VULKAN_SDK}"))
          {
            Write-Error "env:VULKAN_SDK path does not exist: `"${env:VULKAN_SDK}`""
          }
        }
        Write-Output "env:VULKAN_SDK configured for the following steps: `"${env:VULKAN_SDK}`""
    - name: Create directories
      run: |
        New-Item -ItemType Directory -Force -Path "${{ github.workspace }}\build"
        New-Item -ItemType Directory -Force -Path "${{ github.workspace }}\output"
        New-Item -ItemType Directory -Force -Path "${{ github.workspace }}\output\portable"
        New-Item -ItemType Directory -Force -Path "${{ github.workspace }}\output\installer"
        New-Item -ItemType Directory -Force -Path "${{ github.workspace }}\output\debugsymbols"
        New-Item -ItemType Directory -Force -Path "${{ github.workspace }}\output\archive"
        New-Item -ItemType Directory -Force -Path "${{ github.workspace }}\logs\error_logs"
        New-Item -ItemType Directory -Force -Path "${{ github.workspace }}\sentry_output\sentry_source_bundles"
        New-Item -ItemType Directory -Force -Path "${{ github.workspace }}\sentry_artifacts"
    - name: 'Download & Install Ninja-Build'
      id: ninja-dl
      run: |
        Start-Sleep -Milliseconds 1 # See: https://stackoverflow.com/a/49859001

        $VerbosePreference = "Continue"
        . "${env:WZ_REPO_PATH}\.ci\powershell\request.ps1"

        Write-Host "Current value of env:VULKAN_SDK:${env:VULKAN_SDK}"

        $NINJA_DL_URL = "https://github.com/ninja-build/ninja/releases/download/v1.12.1/ninja-win.zip"
        $NINJA_DL_SHA512 = "d6715c6458d798bcb809f410c0364dabd937b5b7a3ddb4cd5aba42f9fca45139b2a8a3e7fd9fbd88fd75d298ed99123220b33c7bdc8966a9d5f2a1c9c230955f"

        $NINJA_DL_BASEDIR = "${{ github.workspace }}\dl"
        $NINJA_DL_PATH = "${NINJA_DL_BASEDIR}\ninja-win.zip"
        if (!(Test-Path -Path "$NINJA_DL_BASEDIR")) { New-Item -ItemType Directory -Force -Path "$NINJA_DL_BASEDIR" }

        $req = Req -Params @{ 'Method'='GET';'Uri'="$NINJA_DL_URL";'OutFile'="${NINJA_DL_PATH}" } -Retries 3 -SecondsDelay 10 -ExpectedHash "${NINJA_DL_SHA512}" -Algorithm SHA512

        Write-Host "Extracting Ninja-Build..."
        $NINJA_INSTALL_PATH = "${{ github.workspace }}\buildtools\ninja"
        New-Item -ItemType Directory -Force -Path "${NINJA_INSTALL_PATH}"
        Expand-Archive -LiteralPath "${NINJA_DL_PATH}" -DestinationPath "${NINJA_INSTALL_PATH}"

        # Export the NINJA executable path
        echo "NINJA_INSTALL_PATH=${NINJA_INSTALL_PATH}" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
        echo "NINJA_INSTALL_PATH=${NINJA_INSTALL_PATH}" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
    - name: Setup LLVM-MINGW
      if: success() && (steps.settings.outputs.WZ_USING_MINGW == 'true')
      run: |
        Start-Sleep -Milliseconds 1 # See: https://stackoverflow.com/a/49859001

        $VerbosePreference = "Continue"
        . "${env:WZ_REPO_PATH}\.ci\powershell\request.ps1"

        $LLVM_MINGW_RELEASE = "20250709";
        $LLVM_MINGW_PKG = "llvm-mingw-${LLVM_MINGW_RELEASE}-ucrt-x86_64"
        $LLVM_MINGW_DL_URL = "https://github.com/mstorsjo/llvm-mingw/releases/download/${LLVM_MINGW_RELEASE}/${LLVM_MINGW_PKG}.zip"
        $LLVM_MINGW_DL_SHA512 = "e080a8928d7ae6263a54d506949421ca03e269a1829f7fdaae53accb9b060a404ec1e6c32eb8b08e051769edd943437635e0dd8beb16ed06b9b04e9423609714"

        $LLVM_MINGW_DL_BASEDIR = "${{ github.workspace }}\dl"
        $LLVM_MINGW_DL_PATH = "${LLVM_MINGW_DL_BASEDIR}\llvm-mingw.zip"
        if (!(Test-Path -Path "$LLVM_MINGW_DL_BASEDIR")) { New-Item -ItemType Directory -Force -Path "$LLVM_MINGW_DL_BASEDIR" }

        $req = Req -Params @{ 'Method'='GET';'Uri'="$LLVM_MINGW_DL_URL";'OutFile'="${LLVM_MINGW_DL_PATH}" } -Retries 3 -SecondsDelay 10 -ExpectedHash "${LLVM_MINGW_DL_SHA512}" -Algorithm SHA512

        Write-Host "Extracting LLVM-mingw..."
        $LLVM_MINGW_INSTALL_PATH = "${{ github.workspace }}\buildtools\llvm-mingw"
        New-Item -ItemType Directory -Force -Path "${LLVM_MINGW_INSTALL_PATH}"
        Expand-Archive -LiteralPath "${LLVM_MINGW_DL_PATH}" -DestinationPath "${LLVM_MINGW_INSTALL_PATH}"

        # Export the LLVM-mingw install path
        $LLVM_MINGW_INSTALL_PATH = "${LLVM_MINGW_INSTALL_PATH}\${LLVM_MINGW_PKG}"
        echo "LLVM_MINGW_INSTALL_PATH=${LLVM_MINGW_INSTALL_PATH}" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
        echo "LLVM_MINGW_INSTALL_PATH=${LLVM_MINGW_INSTALL_PATH}" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

        # Prepend bin path to the system PATH
        echo "Path to LLVM-mingw bin folder: ${LLVM_MINGW_INSTALL_PATH}\bin"
        echo "${LLVM_MINGW_INSTALL_PATH}\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
    - name: Prep MINGW Environment
      id: mingwsettings
      if: success() && (steps.settings.outputs.WZ_USING_MINGW == 'true')
      working-directory: '${{ github.workspace }}\build'
      env:
        WZ_FULL_GIT_PATH: ${{ steps.settings.outputs.WZ_FULL_GIT_PATH }}
        NINJA_INSTALL_PATH: ${{ steps.ninja-dl.outputs.NINJA_INSTALL_PATH }}
        ASCIIDOCTOR_PATH: ${{ steps.asciidoctor-dl.outputs.ASCIIDOCTOR_PATH }}
        WZ_FULL_POWERSHELL_PATH: ${{ steps.settings.outputs.WZ_FULL_POWERSHELL_PATH }}
        WZ_FULL_MSGMERGE_PATH: ${{ steps.settings.outputs.WZ_FULL_MSGMERGE_PATH }}
        WZ_FULL_MSGFMT_PATH: ${{ steps.settings.outputs.WZ_FULL_MSGFMT_PATH }}
        WZ_MINGW_PKG_PREFIX: '${{ steps.settings.outputs.WZ_MINGW_PKG_PREFIX }}'
      run: |
        echo "PATH=${env:PATH}"
        echo "WZ_FULL_GIT_PATH=${env:WZ_FULL_GIT_PATH}"
        echo "NINJA_INSTALL_PATH=${env:NINJA_INSTALL_PATH}"
        echo "ASCIIDOCTOR_PATH=${env:ASCIIDOCTOR_PATH}"
        $POWERSHELL_FOLDER = Split-Path -Path "${env:WZ_FULL_POWERSHELL_PATH}"
        $WZ_MINGW_DIST_PATH = "${env:LLVM_MINGW_INSTALL_PATH}\${env:WZ_MINGW_PKG_PREFIX}\bin"
        echo "WZ_MINGW_DIST_PATH=\"${WZ_MINGW_DIST_PATH}\""
        $WZ_MINGW_ENV_PATH = "${env:LLVM_MINGW_INSTALL_PATH}\bin;${env:WZ_FULL_GIT_PATH};${POWERSHELL_FOLDER};C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;${env:NINJA_INSTALL_PATH};${env:ASCIIDOCTOR_PATH};${env:WZ_FULL_MSGMERGE_PATH}"
        if ("${env:WZ_FULL_MSGMERGE_PATH}" -ne "${env:WZ_FULL_MSGFMT_PATH}") {
          $WZ_MINGW_ENV_PATH = "${WZ_MINGW_ENV_PATH};${env:WZ_FULL_MSGFMT_PATH}"
        }
        echo "WZ_MINGW_ENV_PATH=\"${WZ_MINGW_ENV_PATH}\""
        echo "WZ_MINGW_ENV_PATH=${WZ_MINGW_ENV_PATH}" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        echo "WZ_MINGW_ENV_PATH=${WZ_MINGW_ENV_PATH}" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
        echo "WZ_MINGW_DIST_PATH=${WZ_MINGW_DIST_PATH}" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        echo "WZ_MINGW_DIST_PATH=${WZ_MINGW_DIST_PATH}" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
    - name: Cache vcpkg dependencies
      id: vcpkg-cache
      if: success() && !(github.event_name == 'workflow_run' && github.event.workflow_run.name == 'Draft Tag Release')
      uses: actions/cache@v4
      with:
        path: ${{ steps.settings.outputs.VCPKG_BINARYCACHE_DIR }}
        key: ${{ runner.os }}-${{ matrix.compiler }}-${{ matrix.architecture }}-${{ steps.settings.outputs.WZ_VISUAL_STUDIO_INSTALL_VERSION }}-${{ hashFiles('**/get-dependencies_win.ps1') }}-${{ hashFiles('**/vcpkg.json') }}-${{ hashFiles('**/.ci/vcpkg/**') }}
        restore-keys: |
          ${{ runner.os }}-${{ matrix.compiler }}-${{ matrix.architecture }}-${{ steps.settings.outputs.WZ_VISUAL_STUDIO_INSTALL_VERSION }}-${{ hashFiles('**/get-dependencies_win.ps1') }}-${{ hashFiles('**/vcpkg.json') }}
          ${{ runner.os }}-${{ matrix.compiler }}-${{ matrix.architecture }}-${{ steps.settings.outputs.WZ_VISUAL_STUDIO_INSTALL_VERSION }}-${{ hashFiles('**/get-dependencies_win.ps1') }}-
    - name: Build vcpkg + dependencies
      working-directory: '${{ github.workspace }}\build'
      env:
        WZ_USING_MINGW: ${{ steps.settings.outputs.WZ_USING_MINGW }}
        WZ_FULL_POWERSHELL_PATH: ${{ steps.settings.outputs.WZ_FULL_POWERSHELL_PATH }}
      run: |
        Write-Host "env:VCPKG_DEFAULT_TRIPLET=`"${env:VCPKG_DEFAULT_TRIPLET}`""
        Write-Host "env:VCPKG_VISUAL_STUDIO_PATH=`"${env:VCPKG_VISUAL_STUDIO_PATH}`""
        Write-Host "env:VCPKG_BINARY_SOURCES=`"${env:VCPKG_BINARY_SOURCES}`""
        Write-Host "env:PATH=`"${env:PATH}`""

        if ("${env:WZ_USING_MINGW}" -eq "true") {
          $env:PATH = "${env:WZ_MINGW_ENV_PATH}";
          Write-Host "env:PATH=`"${env:PATH}`""
        }
        else {
          # Workaround: https://github.com/actions/runner-images/issues/10004
          $env:CXXFLAGS = "${env:CXXFLAGS} /D_DISABLE_CONSTEXPR_MUTEX_CONSTRUCTOR"
        }

        & "${env:WZ_FULL_POWERSHELL_PATH}" "${env:WZ_REPO_PATH}\get-dependencies_win.ps1" -VCPKG_BUILD_TYPE "release"
    - name: Clean vcpkg temp files
      working-directory: '${{ github.workspace }}\build'
      run: |
        # Remove the vcpkg\buildtrees folder. (Once all dependencies are installed, it isn't needed, and it takes up a lot of space in the cache.)
        if (Test-Path .\vcpkg\buildtrees) { Remove-Item .\vcpkg\buildtrees -Force -Recurse -ErrorAction SilentlyContinue; }

        # Clean the build remnants of vcpkg itself. (Since it's rebuilt fresh - even from a cached vcpkg directory - these aren't needed.)
        . "${env:WZ_REPO_PATH}\.ci\powershell\importVCvars.ps1"
        Import-VCVarsEnv "${env:WZ_VISUAL_STUDIO_INSTALL_PATH}" "-arch=${env:WZ_TARGET_ARCH} -host_arch=x64"
    - name: CMake Configure (MSVC)
      if: success() && (steps.settings.outputs.WZ_USING_MINGW != 'true')
      working-directory: '${{ github.workspace }}\build'
      env:
        BUILD_SENTRY_SUPPORT: ${{ matrix.support_sentry }}
        WZ_ENABLE_SENTRY: ${{ steps.settings.outputs.WZ_ENABLE_SENTRY }}
        SENTRY_IO_DSN: '${{ secrets.CRASHREPORTING_SENTRY_IO_DSN }}'
        DISCORD_RPC_APPID: '${{ secrets.DISCORD_RPC_APPID }}'
        WZ_FULL_MSGMERGE_PATH: ${{ steps.settings.outputs.WZ_FULL_MSGMERGE_PATH }}
        WZ_FULL_MSGFMT_PATH: ${{ steps.settings.outputs.WZ_FULL_MSGFMT_PATH }}
      run: |
        $ADDITIONAL_CMAKE_PARAMS = "-DWZ_MSVC_MULTITHREADED_COMPILATION:BOOL=ON -DENABLE_GNS_NETWORK_BACKEND:BOOL=ON"
        $WZ_BUILD_SENTRY_VALUE = "OFF"
        if ("${env:BUILD_SENTRY_SUPPORT}" -eq "true") {
          $WZ_BUILD_SENTRY_VALUE = "ON"
          if (("${env:WZ_ENABLE_SENTRY}" -eq "true") -and (-not ([string]::IsNullOrEmpty("${env:SENTRY_IO_DSN}")))) {
            $ADDITIONAL_CMAKE_PARAMS = "$ADDITIONAL_CMAKE_PARAMS -DSENTRY_IO_DSN:STRING=${env:SENTRY_IO_DSN}"
          }
        }
        $env:PATH = "${env:PATH};${env:WZ_FULL_MSGMERGE_PATH}";

        # Workaround: https://github.com/actions/runner-images/issues/10004
        $env:CXXFLAGS = "${env:CXXFLAGS} /D_DISABLE_CONSTEXPR_MUTEX_CONSTRUCTOR"

        # Use CMake to configure with the appropriate Visual Studio (MSBUILD) generator, toolchain, and target platform
        echo "::add-matcher::${{ github.workspace }}\src\.ci\githubactions\pattern_matchers\cmake.json"
        cmake -DCMAKE_TOOLCHAIN_FILE="${{ github.workspace }}\build\vcpkg\scripts\buildsystems\vcpkg.cmake" -DCPACK_PACKAGE_FILE_NAME:STRING="warzone2100_portable" -DWZ_DISTRIBUTOR:STRING="${env:WZ_DISTRIBUTOR}" -DCMAKE_GENERATOR_INSTANCE="${env:WZ_VISUAL_STUDIO_INSTALL_PATH}" -DENABLE_DISCORD:BOOL=ON -DDISCORD_RPC_APPID:STRING="${env:DISCORD_RPC_APPID}" -DWZ_BUILD_SENTRY:BOOL="${WZ_BUILD_SENTRY_VALUE}" ${ADDITIONAL_CMAKE_PARAMS} -G "${env:WZ_VC_GENERATOR}" -A "${env:WZ_VC_TARGET_PLATFORMNAME}" "${env:WZ_REPO_PATH}"
        echo "::remove-matcher owner=cmake::"
    - name: CMake Configure (MINGW)
      if: success() && (steps.settings.outputs.WZ_USING_MINGW == 'true')
      working-directory: '${{ github.workspace }}\build'
      env:
        BUILD_SENTRY_SUPPORT: ${{ matrix.support_sentry }}
        WZ_ENABLE_SENTRY: ${{ steps.settings.outputs.WZ_ENABLE_SENTRY }}
        SENTRY_IO_DSN: '${{ secrets.CRASHREPORTING_SENTRY_IO_DSN }}'
        SENTRY_BACKEND_OVERRIDE: '${{ matrix.sentry_backend }}'
        DISCORD_RPC_APPID: '${{ secrets.DISCORD_RPC_APPID }}'
        WZ_FULL_CMAKE_PATH: '${{ steps.settings.outputs.WZ_FULL_CMAKE_PATH }}'
        WZ_MINGW_PKG_PREFIX: '${{ steps.settings.outputs.WZ_MINGW_PKG_PREFIX }}'
        WZ_MINGW_CHAINLOAD_TOOLCHAIN_FILE: '${{ steps.settings.outputs.WZ_REPO_PATH }}\.ci\cmake\toolchains\${{ steps.settings.outputs.WZ_MINGW_PKG_PREFIX }}.cmake'
        WZ_ASM_MASM_COMPILER: '${{ steps.settings.outputs.WZ_ASM_MASM_COMPILER }}'
      run: |
        $SENTRY_DSN_PARAM = ""
        $WZ_BUILD_SENTRY_VALUE = "OFF"
        if ("${env:BUILD_SENTRY_SUPPORT}" -eq "true") {
          $WZ_BUILD_SENTRY_VALUE = "ON"
          if (("${env:WZ_ENABLE_SENTRY}" -eq "true") -and (-not ([string]::IsNullOrEmpty("${env:SENTRY_IO_DSN}")))) {
            $SENTRY_DSN_PARAM = "-DSENTRY_IO_DSN:STRING=${env:SENTRY_IO_DSN}"
          }
        }
        $SENTRY_BACKEND_PARAM = ""
        if (-not ([string]::IsNullOrEmpty("${env:SENTRY_BACKEND_OVERRIDE}"))) {
          $SENTRY_BACKEND_PARAM = "-DSENTRY_BACKEND:STRING=${env:SENTRY_BACKEND_OVERRIDE}"
        }
        echo "::add-matcher::${{ github.workspace }}\src\.ci\githubactions\pattern_matchers\cmake.json"
        $env:PATH = "${env:WZ_MINGW_ENV_PATH}";
        & "${env:WZ_FULL_CMAKE_PATH}\cmake.exe" -DCMAKE_ASM_MASM_COMPILER="${env:WZ_ASM_MASM_COMPILER}" -DWZ_MINGW_DIST_PATH="${env:WZ_MINGW_DIST_PATH}" -DCMAKE_TOOLCHAIN_FILE="${{ github.workspace }}\build\vcpkg\scripts\buildsystems\vcpkg.cmake" -DVCPKG_CHAINLOAD_TOOLCHAIN_FILE="${env:WZ_MINGW_CHAINLOAD_TOOLCHAIN_FILE}" -DCMAKE_BUILD_TYPE=Release -DWZ_DISTRIBUTOR:STRING="${env:WZ_DISTRIBUTOR}" -DENABLE_DISCORD:BOOL=ON -DDISCORD_RPC_APPID:STRING="${env:DISCORD_RPC_APPID}" -DWZ_BUILD_SENTRY:BOOL=${WZ_BUILD_SENTRY_VALUE} ${SENTRY_DSN_PARAM} ${SENTRY_BACKEND_PARAM} -DENABLE_GNS_NETWORK_BACKEND:BOOL=ON -G "Ninja" "${{ steps.settings.outputs.WZ_REPO_PATH }}"
        echo "::remove-matcher owner=cmake::"
    - name: Upload vcpkg logs (on failure)
      uses: actions/upload-artifact@v5
      if: failure()
      with:
        name: failure_${{ steps.settings.outputs.WZ_BUILD_DESC }}_${{ matrix.architecture }}_vcpkg_logs
        path: |
          ${{ github.workspace }}\build\vcpkg\buildtrees\*\*.log
          ${{ github.workspace }}\build\vcpkg\buildtrees\*\*.txt
        if-no-files-found: 'warn'
        retention-days: 1
    - name: CMake Build (MSVC)
      if: success() && (steps.settings.outputs.WZ_USING_MINGW != 'true')
      working-directory: '${{ github.workspace }}\build'
      run: |
        # Workaround: https://github.com/actions/runner-images/issues/10004
        $env:CXXFLAGS = "${env:CXXFLAGS} /D_DISABLE_CONSTEXPR_MUTEX_CONSTRUCTOR"

        echo "::add-matcher::${{ github.workspace }}\src\.ci\githubactions\pattern_matchers\msvc.json"
        & cmake --build . --config Release --target warzone2100 -- /m
        echo "::remove-matcher owner=msvc::"
    - name: CMake Build (MINGW)
      if: success() && (steps.settings.outputs.WZ_USING_MINGW == 'true')
      working-directory: '${{ github.workspace }}\build'
      run: |
        echo "::add-matcher::${{ github.workspace }}\src\.ci\githubactions\pattern_matchers\clang.json"
        & cmake --build . --config Release --target warzone2100 -- -k0
        echo "::remove-matcher owner=clang::"
    - name: Archive .ZIP of Regular build
      if: success() && (matrix.deploy_release == true)
      working-directory: '${{ github.workspace }}\build'
      env:
        FULL_CMAKE_PATH: '${{ steps.settings.outputs.WZ_FULL_CMAKE_PATH }}'
      run: |
        . "${env:WZ_REPO_PATH}\.ci\powershell\importVCvars.ps1"
        Import-VCVarsEnv "${env:WZ_VISUAL_STUDIO_INSTALL_PATH}" "-arch=${env:WZ_TARGET_ARCH} -host_arch=x64"
        # Run CPack
        & "${env:FULL_CMAKE_PATH}\cpack.exe" -D CPACK_PACKAGE_FILE_NAME="warzone2100_archive" -D CPACK_INCLUDE_TOPLEVEL_DIRECTORY=OFF -D CPACK_ARCHIVE_COMPONENT_INSTALL=ON -D CPACK_COMPONENTS_ALL_IN_ONE_PACKAGE=ON -G ZIP -C "Release"
        # Rename the archive
        Move-Item -LiteralPath ".\warzone2100_archive.zip" -Destination "${{ github.workspace }}\output\archive\warzone2100_$($env:WZ_BUILD_DESC)_archive.zip"
    - name: Archive Debug Symbols
      if: success() && (matrix.deploy_release == true)
      working-directory: '${{ github.workspace }}\build'
      env:
        FULL_CMAKE_PATH: '${{ steps.settings.outputs.WZ_FULL_CMAKE_PATH }}'
      run: |
        . "${env:WZ_REPO_PATH}\.ci\powershell\importVCvars.ps1"
        Import-VCVarsEnv "${env:WZ_VISUAL_STUDIO_INSTALL_PATH}" "-arch=${env:WZ_TARGET_ARCH} -host_arch=x64"
        # Run CPack
        & "${env:FULL_CMAKE_PATH}\cpack.exe" -D CPACK_PACKAGE_FILE_NAME="warzone2100_debugsymbols" -D CPACK_COMPONENTS_ALL="DebugSymbols;AdditionalDebugSymbols" -D CPACK_INCLUDE_TOPLEVEL_DIRECTORY=OFF -D CPACK_ARCHIVE_COMPONENT_INSTALL=ON -G 7Z -C "Release"
        # Rename the archive
        Move-Item -LiteralPath ".\warzone2100_debugsymbols.7z" -Destination "${{ github.workspace }}\output\debugsymbols\warzone2100_$($env:WZ_BUILD_DESC).DEBUGSYMBOLS.7z"
    - name: Compare Build Outputs
      if: success() && (matrix.deploy_release == true)
      working-directory: '${{ github.workspace }}\output'
      run: |
        # Log hashes of the build output
        Write-Host "SHA512 Hashes:"
        Write-Host "`nwarzone2100_$($env:WZ_BUILD_DESC)_archive.zip`n`t-> SHA512: $((Get-FileHash -LiteralPath ".\archive\warzone2100_$($env:WZ_BUILD_DESC)_archive.zip" -Algorithm SHA512).Hash)`n`t`-> Size (bytes): $((Get-Item -LiteralPath ".\archive\warzone2100_$($env:WZ_BUILD_DESC)_archive.zip").Length)"
        Write-Host ""
    #####################################################
    # Upload build artifacts
    #####################################################
    - name: 'Upload Artifact - (Debug Symbols)'
      uses: actions/upload-artifact@v5
      if: success() && (matrix.deploy_release == true) && (github.repository == 'Warzone2100/warzone2100')
      with:
        name: warzone2100_${{ steps.settings.outputs.WZ_BUILD_DESC }}_DEBUGSYMBOLS
        path: '${{ github.workspace }}\output\debugsymbols'
        if-no-files-found: 'error'
    - name: 'Upload Artifact - (Archive)'
      uses: actions/upload-artifact@v5
      if: success() && (matrix.deploy_release == true)
      with:
        name: warzone2100_${{ steps.settings.outputs.WZ_BUILD_DESC }}_archive
        path: '${{ github.workspace }}\output\archive'
        if-no-files-found: 'error'
    #####################################################
    # Generate artifact attestations
    #####################################################
    - name: 'Generate artifact attestation - (Archive)'
      # Run on push to master branch (development build), or tag release automation build
      if: success() && (matrix.deploy_release == true) && ((github.event_name == 'push' && github.ref == 'refs/heads/master') || (github.event_name == 'workflow_run' && github.event.workflow_run.name == 'Draft Tag Release'))
      uses: actions/attest-build-provenance@v3
      continue-on-error: true
      with:
        subject-path: '${{ github.workspace }}\output\archive\*'
    #########################################################
    # Create Sentry source bundle (for releasable artifacts)
    #########################################################
    - name: Create Sentry source bundle
      if: success() && (matrix.support_sentry == true) && (matrix.deploy_release == true)
      id: create-sentry-source-bundle
      continue-on-error: true
      working-directory: '${{ github.workspace }}\sentry_artifacts'
      env:
        WZ_REPO_PATH: ${{ steps.settings.outputs.WZ_REPO_PATH }}
        WZ_ARCHIVE_PATH: '${{ github.workspace }}\output\archive\warzone2100_${{ steps.settings.outputs.WZ_BUILD_DESC }}_archive.zip'
        WZ_DEBUGSYMBOLS_PATH: '${{ github.workspace }}\output\debugsymbols\warzone2100_${{ steps.settings.outputs.WZ_BUILD_DESC }}.DEBUGSYMBOLS.7z'
        SOURCE_BUNDLE_OUTPUT_DIR: '${{ github.workspace }}\sentry_output\sentry_source_bundles'
      run: |
        # Download sentry-cli
        echo "::group::Downloading sentry-cli ..."
        cmake -P "${env:WZ_REPO_PATH}/.ci/githubactions/FetchSentryCLI.cmake"
        echo "Downloading sentry-cli ... Done"
        echo "::endgroup::"
        # Extract the WZ archive to a temporary path
        echo "::group::Expanding archive ..."
        Expand-Archive -LiteralPath "${env:WZ_ARCHIVE_PATH}" -DestinationPath "$(pwd)\wz_extracted"
        echo "Expanding archive ... Done"
        # Extract the debug symbols to the temporary path's "bin" directory
        $SYMBOLS_OUTPUT_DIR = "$(pwd)\wz_extracted"
        echo "Extracting debug symbols ..."
        Start-Process "7z" -ArgumentList "x","${env:WZ_DEBUGSYMBOLS_PATH}","-o${SYMBOLS_OUTPUT_DIR}","-aos" -Wait
        echo "Extracting debug symbols ... Done"
        # Remove any .sym files from extracted archive
        Remove-Item "$(pwd)\wz_extracted\bin\*" -Recurse -Include *.sym
        Get-ChildItem -Path "$(pwd)\wz_extracted\bin" -Recurse
        echo "::endgroup::"
        # Create the Sentry source bundle
        echo "sentry-cli difutil bundle-sources ..."
        & "$(pwd)\sentry-cli\sentry-cli.exe" difutil bundle-sources -o "${env:SOURCE_BUNDLE_OUTPUT_DIR}" "$(pwd)\wz_extracted\bin\warzone2100.pdb"
        echo "sentry-cli difutil bundle-sources ... Done"
        # List output bundles
        Get-ChildItem -Path "${env:SOURCE_BUNDLE_OUTPUT_DIR}" -Recurse
    - name: Upload Sentry source bundles
      if: success() && (github.repository == 'Warzone2100/warzone2100') && (matrix.support_sentry == true) && (matrix.deploy_release == true) && (steps.settings.outputs.WZ_ENABLE_SENTRY == 'true') && (steps.create-sentry-source-bundle.outcome == 'success')
      uses: actions/upload-artifact@v5
      with:
        name: 'debug_sourcebundles_${{ steps.settings.outputs.WZ_BUILD_DESC }}'
        path: '${{ github.workspace }}\sentry_output\sentry_source_bundles'
        retention-days: 1
        if-no-files-found: 'warn'
  combined-installer-build:
    name: 'Build Installer'
    permissions:
      contents: read
      # needed to generate artifact attestations, see: https://docs.github.com/en/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds
      id-token: write
      attestations: write
    runs-on: windows-latest
    needs: windows-build
    outputs:
      combined-installer-artifact-id: ${{ steps.upload-combined-installer-artifact.outputs.artifact-id }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0
          path: 'src'
      - name: Configure Repo Checkout
        id: checkout-config
        working-directory: '${{ github.workspace }}\src'
        shell: bash
        env:
          WORKFLOW_RUN_CONCLUSION: ${{ github.event.workflow_run.conclusion }}
          WORKFLOW_RUN_HEAD_SHA: ${{ github.event.workflow_run.head_sha }}
        run: |
          . .ci/githubactions/checkout_config.sh
      - name: Prepare Git Repo for autorevision
        working-directory: '${{ github.workspace }}\src'
        run: cmake -P .ci/githubactions/prepare_git_repo.cmake
      - name: Init Git Submodules
        working-directory: '${{ github.workspace }}\src'
        run: |
          # To save time, only init the submodules in the pkg/win_installer/ folder
          git submodule update --init --recursive -- pkg/win_installer/innohelperscripts pkg/win_installer/resources
      - name: Prep Environment
        id: settings
        shell: bash
        run: |
          mkdir dependency-dl
          mkdir innosetup
          mkdir innosetup-deps
          mkdir innosetup-unofficial-translations
          mkdir built-archives
          mkdir tmp
          mkdir combined-staging
          mkdir output
      - name: Install Inno Setup
        env:
          INNOSETUP_INSTALL_PATH: '${{ github.workspace }}\innosetup'
        run: |
          Start-Sleep -Milliseconds 1 # See: https://stackoverflow.com/a/49859001
          $VerbosePreference = "Continue"
          . "src\.ci\powershell\request.ps1"

          $INNOSETUP_DL_URL = "https://files.jrsoftware.org/is/6/innosetup-6.5.3.exe"
          $INNOSETUP_DL_SHA256 = "9345ee029faa0b7aed0818c3d5b227699ef9a496cce79e20c19eb9d6ef2e2c2d"

          $INNOSETUP_DL_PATH = ".\dependency-dl\innosetup.exe"
          $req = Req -Params @{ 'Method'='GET';'Uri'="$INNOSETUP_DL_URL";'OutFile'="${INNOSETUP_DL_PATH}" } -Retries 3 -SecondsDelay 10 -ExpectedHash "${INNOSETUP_DL_SHA256}" -Algorithm SHA256

          # Install portably (to avoid conflict with any version that's shipped in the GitHub Actions images)
          Write-Host "Installing Inno Setup..."
          Start-Process -FilePath "${INNOSETUP_DL_PATH}" -ArgumentList /portable=1,"/DIR=${env:INNOSETUP_INSTALL_PATH}",/CURRENTUSER,/NOICONS,/VERYSILENT,/SUPPRESSMSGBOXES,/NORESTART -NoNewWindow -Wait
          Write-Host "Finished installing Inno Setup"

          echo "WZ_INNOSETUP_PATH=${env:INNOSETUP_INSTALL_PATH}" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          echo "WZ_INNOSETUP_PATH=${env:INNOSETUP_INSTALL_PATH}" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
      - name: Install Install Script Dependencies
        id: script-dependencies
        env:
          SCRIPT_DEP_INSTALL_PATH: '${{ github.workspace }}\innosetup-deps'
        run: |
          Start-Sleep -Milliseconds 1 # See: https://stackoverflow.com/a/49859001
          $VerbosePreference = "Continue"
          . "src\.ci\powershell\request.ps1"

          $FILECHECK_DL_URL = "https://github.com/past-due/innofilecheck/releases/download/v1.0.1/innofilecheck.dll"
          $FILECHECK_DL_SHA512 = "a2983b025c56c8c134427360dcc1b07a55b14b9e4700ea7ccdb99d0a23537adb41e1d19f116b7358747def2c2f27c773fdc3f8bb4faf3acb516d2f8b288de194"

          $FILECHECK_DL_PATH = ".\dependency-dl\innofilecheck.dll"
          $req = Req -Params @{ 'Method'='GET';'Uri'="$FILECHECK_DL_URL";'OutFile'="${FILECHECK_DL_PATH}" } -Retries 3 -SecondsDelay 10 -ExpectedHash "${FILECHECK_DL_SHA512}" -Algorithm SHA512

          $installLocation = "$(Join-Path "${env:SCRIPT_DEP_INSTALL_PATH}" "innofilecheck.dll")"
          Move-Item -Path "${FILECHECK_DL_PATH}" -Destination "$installLocation" -Force -ErrorAction Stop

          echo "WZ_INNOSETUP_SCRIPT_DEPENDENCIES_PATH=${env:SCRIPT_DEP_INSTALL_PATH}" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
      - name: Fetch Unofficial Base Setup Translations
        id: unofficial-base-translations
        env:
          UNOFFICIAL_TRANSLATIONS_INSTALL_PATH: '${{ github.workspace }}\innosetup-unofficial-translations'
        run: |
          Start-Sleep -Milliseconds 1 # See: https://stackoverflow.com/a/49859001
          $VerbosePreference = "Continue"
          . "src\.ci\powershell\request.ps1"

          $TRANSLATIONS_COMMIT_DL_URL = "https://github.com/jrsoftware/issrc/archive/bf7dc5d0fce1c1743167f07a89dff8d224acba51.zip"
          $TRANSLATIONS_COMMIT_DL_SHA512 = "0faf94c9639b69fbfcfb06edd23a00baa39704dab3a4c097f4a0c8e9a654d4f98d855c861b391f7f44cb38a4c7d0b4efb9c9f0811477930b3f5ca2d6dbd8a63e"

          $TRANSLATIONS_COMMIT_DL_PATH = ".\dependency-dl\translations_commit.zip"
          $req = Req -Params @{ 'Method'='GET';'Uri'="$TRANSLATIONS_COMMIT_DL_URL";'OutFile'="${TRANSLATIONS_COMMIT_DL_PATH}" } -Retries 3 -SecondsDelay 10 -ExpectedHash "${TRANSLATIONS_COMMIT_DL_SHA512}" -Algorithm SHA512

          echo "::group::Expanding archive ..."
          $TRANSLATIONS_EXTRACTED_PATH = "$(pwd)\dependency-dl\translations_commit_extracted"
          Expand-Archive -LiteralPath "${TRANSLATIONS_COMMIT_DL_PATH}" -DestinationPath "${TRANSLATIONS_EXTRACTED_PATH}"
          echo "Expanding archive ... Done"

          Copy-Item -Path "${TRANSLATIONS_EXTRACTED_PATH}\*\Files\Languages\Unofficial\*.isl" -Destination "${env:UNOFFICIAL_TRANSLATIONS_INSTALL_PATH}" -ErrorAction Stop

          echo "WZ_INNOSETUP_UNOFFICIAL_TRANSLATIONS_PATH=${env:UNOFFICIAL_TRANSLATIONS_INSTALL_PATH}" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
      - name: Download Architecture Archives
        uses: actions/download-artifact@v6
        with:
          pattern: 'warzone2100_win_*_archive'
          path: .\built-archives
          merge-multiple: true
      - name: Log Archive Details
        working-directory: '${{ github.workspace }}\built-archives'
        run: |
          Write-Host "SHA512 Hashes:"
          $files = Get-ChildItem -Path . -File
          foreach ($file in $files) {
            Write-Host "`n$($file.Name)`n`t-> SHA512: $((Get-FileHash -Path "$file" -Algorithm SHA512).Hash)`n`t`-> Size (bytes): $((Get-Item -Path "$file").Length)"
          }
          Write-Host ""
      - name: Create Combined Staging of Arch Builds
        env:
          BASE_WORKING_PATH: '${{ github.workspace }}'
        run: |
          $VerbosePreference = "Continue"
          $InformationPreference = "Continue"
          . "src\pkg\win_combined_archive\build_win_combined_arch.ps1"
          Build-WinCombinedArchDir -InputArchivesDir "${env:BASE_WORKING_PATH}\built-archives" -TmpExtractDir "${env:BASE_WORKING_PATH}\tmp" -BuildDir "${env:BASE_WORKING_PATH}\combined-staging"
          Get-ChildItem -Path "${env:BASE_WORKING_PATH}\combined-staging" -Recurse -File
      - name: Build Combined Installer
        id: build-installer
        env:
          INSTALLER_SOURCE_DIR: '${{ github.workspace }}\combined-staging'
          INSTALLER_OUTPUT_DIR: '${{ github.workspace }}\output'
          INNOFILECHECK_DLL_DIR: '${{ steps.script-dependencies.outputs.WZ_INNOSETUP_SCRIPT_DEPENDENCIES_PATH }}'
          UNOFFICIAL_TRANSLATIONS_DIR: '${{ steps.unofficial-base-translations.outputs.WZ_INNOSETUP_UNOFFICIAL_TRANSLATIONS_PATH }}'
        run: |
          & "${env:WZ_INNOSETUP_PATH}\ISCC.exe" "/O${env:INSTALLER_OUTPUT_DIR}" "/DSOURCE_DIR=${env:INSTALLER_SOURCE_DIR}" "/DINNOFILECHECK_DLL_DIR=${env:INNOFILECHECK_DLL_DIR}" "/DUNOFFICIAL_TRANSLATIONS_DIR=${env:UNOFFICIAL_TRANSLATIONS_DIR}" "src\pkg\win_installer\warzone2100.iss"
          if ($? -eq $false) {
            Write-Error "Failed building installer"
            Exit 1
          }
          $OutputFile = "$(Join-Path "${env:INSTALLER_OUTPUT_DIR}" "warzone2100_win_installer.exe")"
          Write-Host "Finished building installer:"
          Write-Host "`n$($OutputFile)`n`t-> SHA512: $((Get-FileHash -Path "$OutputFile" -Algorithm SHA512).Hash)`n`t`-> Size (bytes): $((Get-Item -Path "$OutputFile").Length)"
          echo "INSTALLER_OUTPUT_DIR=${env:INSTALLER_OUTPUT_DIR}" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          echo "INSTALLER_EXE=${OutputFile}" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
      - name: Debug Output - Install Manifest
        env:
          INSTALLER_OUTPUT_DIR: '${{ steps.build-installer.outputs.INSTALLER_OUTPUT_DIR }}'
        run: |
          Get-Content "${env:INSTALLER_OUTPUT_DIR}\setup-manifest.txt"
      - name: 'Upload Artifact - (Combined Installer)'
        id: upload-combined-installer-artifact
        uses: actions/upload-artifact@v5
        if: success() && (github.repository == 'Warzone2100/warzone2100')
        with:
          name: warzone2100_win_installer
          path: ${{ steps.build-installer.outputs.INSTALLER_EXE }}
          if-no-files-found: 'error'
      - name: 'Generate Artifact Attestation'
        # Run on push to master branch (development build), or tag release automation build
        if: success() && ((github.event_name == 'push' && github.ref == 'refs/heads/master') || (github.event_name == 'workflow_run' && github.event.workflow_run.name == 'Draft Tag Release'))
        uses: actions/attest-build-provenance@v3
        continue-on-error: true
        with:
          subject-path: '${{ steps.build-installer.outputs.INSTALLER_EXE }}'
  sign-release-installers:
    # Sign the Windows installer binaries using our Signpath certificate.  Note that this involves sending the binary to the
    # remote SignPath service where the signing actually happens.  We need to have an account and credentials with
    # that service to use it, so this step can't be done in forked repositories.
    #
    # Various settings here have to align with the "warzone2100" project in the "Warzone 2100 [OSS]" organization
    # registered at https://app.signpath.io/.
    #
    # In particular, the repository needs to have a "sign_release" environment configured with the following secret:
    #
    #    SIGNPATH_API_TOKEN - As generated in app.signpath.io from the user profile page for the CI user
    #
    # We also add the following GitHub Actions variable (see
    # https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/store-information-in-variables):
    #
    #    SIGNPATH_ORGANIZATION_ID - Set to the organization ID (a UUID) for "Warzone 2100 [OSS]" in app.signpath.io
    #
    # One reason not to hard code SIGNPATH_ORGANIZATION_ID is that we use its existence to signal that the above
    # secrets are available - i.e. that we can do the build signing.
    name: 'Sign Release Installers'
    permissions:
      actions: read
      contents: read
      # needed to generate artifact attestations, see: https://docs.github.com/en/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds
      id-token: write
      attestations: write
    runs-on: windows-latest
    needs: [combined-installer-build]
    environment: sign_release
    if: success() && (github.event_name == 'workflow_run' && github.event.workflow_run.name == 'Draft Tag Release') && (github.repository == 'Warzone2100/warzone2100')
    outputs:
      signedfiles: ${{ steps.output-result.outputs.signedfiles }}
    steps:
      # Download all releasable artifacts that need signing
      - name: Prep Environment
        id: settings
        shell: bash
        run: mkdir unsigned-installers && mkdir signed-installers
      - name: Download Release Installer
        if: success() && env.WZ_CI_SIGN_RELEASE_BUILDS == 'true' && vars.SIGNPATH_ORGANIZATION_ID != ''
        uses: actions/download-artifact@v6
        with:
          artifact-ids: '${{ needs.combined-installer-build.outputs.combined-installer-artifact-id }}'
          path: .\unsigned-installers
          merge-multiple: true
      - name: Log Unsigned Installer Details
        if: success() && env.WZ_CI_SIGN_RELEASE_BUILDS == 'true' && vars.SIGNPATH_ORGANIZATION_ID != ''
        working-directory: '${{ github.workspace }}\unsigned-installers'
        run: |
          Write-Host "SHA512 Hashes:"
          $files = Get-ChildItem -Path . -File
          foreach ($file in $files) {
            Write-Host "`n$($file.Name)`n`t-> SHA512: $((Get-FileHash -Path "$file" -Algorithm SHA512).Hash)`n`t`-> Size (bytes): $((Get-Item -Path "$file").Length)"
          }
          Write-Host ""
      - name: SignPath - Request Signing of Installer EXE
        if: success() && env.WZ_CI_SIGN_RELEASE_BUILDS == 'true' && vars.SIGNPATH_ORGANIZATION_ID != ''
        id: signpath-sign
        continue-on-error: true
        uses: signpath/github-action-submit-signing-request@v2.0
        env:
          SIGNPATH_SIGNING_POLICY_SLUG: ${{ (github.event_name == 'workflow_run' && github.event.workflow_run.name == 'Draft Tag Release') && 'release-signing' || 'test-signing' }}
        with:
          api-token: '${{ secrets.SIGNPATH_API_TOKEN }}'
          organization-id: '${{ vars.SIGNPATH_ORGANIZATION_ID }}'
          project-slug: 'warzone2100' # Has to match slug in https://app.signpath.io/ "warzone2100" project
          signing-policy-slug: '${{ env.SIGNPATH_SIGNING_POLICY_SLUG }}'
          github-artifact-id: '${{ needs.combined-installer-build.outputs.combined-installer-artifact-id }}'
          wait-for-completion: true
          # 4h to manually approve the request
          wait-for-completion-timeout-in-seconds: 14400
          output-artifact-directory: '${{ github.workspace }}\signed-installers\'
      - name: Log Signed Build Outputs
        if: (steps.signpath-sign.outcome == 'success')
        working-directory: '${{ github.workspace }}\signed-installers\'
        run: |
          # Log hashes of the signed setup EXEs
          Write-Host "SHA512 Hashes:"
          $files = Get-ChildItem -Path . -File
          foreach ($file in $files) {
            Write-Host "`n$($file.Name)`n`t-> SHA512: $((Get-FileHash -Path "$file" -Algorithm SHA512).Hash)`n`t`-> Size (bytes): $((Get-Item -Path "$file").Length)"
          }
          Write-Host ""
      - name: 'Generate artifact attestations - (Signed Installers)'
        if: (steps.signpath-sign.outcome == 'success') && ((github.event_name == 'push' && github.ref == 'refs/heads/master') || (github.event_name == 'workflow_run' && github.event.workflow_run.name == 'Draft Tag Release'))
        uses: actions/attest-build-provenance@v3
        continue-on-error: true
        with:
          subject-path: '${{ github.workspace }}\signed-installers\*'
      - name: 'Upload Artifact - All Signed Installer EXEs'
        if: (steps.signpath-sign.outcome == 'success')
        uses: actions/upload-artifact@v5
        with:
          name: warzone2100_installers_signed
          path: '${{ github.workspace }}\signed-installers\*'
          if-no-files-found: 'error'
      - name: Output Result
        id: output-result
        env:
          SIGN_STEP_OUTCOME: ${{ steps.signpath-sign.outcome }}
        run: |
          $signedfiles = "false"
          if ("${env:SIGN_STEP_OUTCOME}" -eq "success") {
            $signedfiles = "true"
          }
          echo "signedfiles=${signedfiles}"
          echo "signedfiles=${signedfiles}" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
  upload-release-assets:
    name: 'Upload Release Assets'
    permissions:
      contents: write # Needed to upload to releases
    runs-on: ubuntu-latest
    # Run on tag release automation build
    if: success() && (github.event_name == 'workflow_run' && github.event.workflow_run.name == 'Draft Tag Release') && (github.repository == 'Warzone2100/warzone2100')
    needs: [windows-build, combined-installer-build, sign-release-installers]
    env:
      WZ_GITHUB_REF: ${{needs.windows-build.outputs.WZ_GITHUB_REF}}
    steps:
      - name: Prep Environment
        id: settings
        run: mkdir upload-assets && mkdir upload-assets-signed
      - name: Download Release Artifacts
        uses: actions/download-artifact@v6
        with:
          # Includes the release artifacts: installer, debug symbols, and archive
          pattern: 'warzone2100_win_*'
          path: ./upload-assets
          merge-multiple: true
      - name: List Assets
        run: ls -LRl ./upload-assets
      - name: Download Signed Release Artifacts
        if: success() && env.WZ_CI_SIGN_RELEASE_BUILDS == 'true' && (needs.sign-release-installers.outputs.signedfiles == 'true')
        uses: actions/download-artifact@v6
        with:
          name: 'warzone2100_installers_signed'
          path: ./upload-assets-signed
          merge-multiple: true
      - name: Replace Unsigned with Signed Release Artifacts
        if: success() && env.WZ_CI_SIGN_RELEASE_BUILDS == 'true' && (needs.sign-release-installers.outputs.signedfiles == 'true')
        run: |
          for file in ./upload-assets-signed/*; do
            filename="${file##*/}"
            dest="./upload-assets/${filename}"
            if [ ! -f "${dest}" ]; then
              echo "::warning ::Missing original (unsigned) file - ${filename} ?"
            fi
            echo "Replacing with signed: ${filename}"
            mv -f "${file}" "${dest}"
          done
          ls -LRl ./upload-assets
      - name: Upload Release Assets
        working-directory: '${{ github.workspace }}/upload-assets/'
        run: |
          SOURCE_TAG="${WZ_GITHUB_REF#refs/tags/}"
          for file in ./warzone2100_win_*; do
            echo "Uploading: $file"
            gh release upload "${SOURCE_TAG}" "$file"
          done
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_REPO: ${{ github.repository }}
  upload-debug-symbols:
    strategy:
      matrix:
        architecture: ["x86", "x64", "arm64"]
      fail-fast: false
    env:
      WZ_TARGET_ARCH: ${{ matrix.architecture }}
    name: 'Upload Debug Symbols (${{ matrix.architecture }})'
    permissions:
      contents: read
    runs-on: ubuntu-latest
    # Run on push to master branch (development build), or tag release automation build
    if: (github.repository == 'Warzone2100/warzone2100') && ((github.event_name == 'push' && github.ref == 'refs/heads/master') || (github.event_name == 'workflow_run' && github.event.workflow_run.name == 'Draft Tag Release'))
    needs: windows-build
    environment: upload_symbols
    # For this job to work, the following secrets must be set in the 'upload_symbols' environment:
    # SENTRY_AUTH_TOKEN
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 1
          path: 'src'
      - name: Prep Environment
        id: settings
        run: |
          mkdir dl-archive
          mkdir dl-sourcebundle
          OUTPUTDIR="wz-${WZ_TARGET_ARCH}"
          echo "OUTPUTDIR=${OUTPUTDIR}" >> $GITHUB_ENV
          echo "ARCHIVEDIR=${OUTPUTDIR}" >> $GITHUB_OUTPUT
          echo "WZ_REPO_PATH=$(pwd)/src" >> $GITHUB_ENV
      - name: Download Archive Artifact
        uses: actions/download-artifact@v6
        with:
          name: 'warzone2100_win_${{ matrix.architecture }}_archive'
          path: ./dl-archive
      - name: Extract archive
        run: |
          ZIPFILE="./dl-archive/warzone2100_win_${WZ_TARGET_ARCH}_archive.zip"
          unzip -o "${ZIPFILE}" -d "${OUTPUTDIR}" && rm "${ZIPFILE}"
      - name: Download Debug Symbols Artifact
        continue-on-error: true
        uses: actions/download-artifact@v6
        with:
          name: 'warzone2100_win_${{ matrix.architecture }}_DEBUGSYMBOLS'
          path: ./dl-archive
      - name: Extract Debug Symbols
        continue-on-error: true
        run: |
          ZIPFILE="./dl-archive/warzone2100_win_${WZ_TARGET_ARCH}.DEBUGSYMBOLS.7z"
          7z x "${ZIPFILE}" -o${OUTPUTDIR} -aos && rm "${ZIPFILE}"
      - name: Cleanup breakpad symbols
        run: |
          # Remove the breakpad symbols (so they are never selected instead of the PDB)
          BREAKPAD_SYM="${OUTPUTDIR}/bin/warzone2100.sym"
          if [[ -f "${BREAKPAD_SYM}" ]]; then
            echo "Removing breakpad .sym"
            rm "${BREAKPAD_SYM}"
          fi
      - name: Download Source Bundle
        continue-on-error: true
        uses: actions/download-artifact@v6
        with:
          name: 'debug_sourcebundles_win_${{ matrix.architecture }}'
          path: ./dl-sourcebundle
      - name: 'Upload debug symbols'
        env:
          SENTRY_AUTH_TOKEN: '${{ secrets.SENTRY_AUTH_TOKEN }}'
          WZ_ARCHIVE_DIR: '${{ steps.settings.outputs.ARCHIVEDIR }}'
          WZ_SOURCEBUNDLES_DIR: './dl-sourcebundle'
        run: |
          if [[ -z "${SENTRY_AUTH_TOKEN}" ]]; then
            echo "No SENTRY_AUTH_TOKEN - skipping"
            exit 0
          fi
          # Download sentry-cli
          echo "::group::Downloading sentry-cli ..."
          cmake -P "${WZ_REPO_PATH}/.ci/githubactions/FetchSentryCLI.cmake"
          echo "Downloading sentry-cli ... Done"
          echo "::endgroup::"
          # Upload symbols
          echo "::group::sentry-cli debug-files upload"
          ./sentry-cli/sentry-cli debug-files upload --no-zips -o warzone2100 -p warzone2100 --wait "${WZ_ARCHIVE_DIR}"
          ./sentry-cli/sentry-cli debug-files upload --type sourcebundle -o warzone2100 -p warzone2100 "${WZ_SOURCEBUNDLES_DIR}"
          ./sentry-cli/sentry-cli difutil check "${WZ_ARCHIVE_DIR}/bin/warzone2100.exe"
          echo "::endgroup::"
  trigger-updates-json:
    name: 'Trigger Info Update'
    permissions:
      contents: read
    runs-on: ubuntu-latest
    if: (github.repository == 'Warzone2100/warzone2100') && (github.ref == 'refs/heads/master')
    needs: windows-build
    environment: update_dispatch
    # For this job to work, the following secrets must be set in the 'update_dispatch' environment:
    # SITE_DISPATCH_ACCESS_TOKEN
    steps:
      - name: 'Trigger updates.json update'
        run: |
          curl -X POST \
          -H "Accept: application/vnd.github+json" \
          -H "Authorization: Bearer ${{ secrets.SITE_DISPATCH_ACCESS_TOKEN }}" \
          -H "X-GitHub-Api-Version: 2022-11-28" \
          https://api.github.com/repos/Warzone2100/update-data/dispatches \
          --data '{"event_type": "development_build_update", "client_payload": { "repository": "'"$GITHUB_REPOSITORY"'" }}'
